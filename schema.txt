-- SUPABASE COMPLETE SETUP SCRIPT (Version 3.2 - Improved Filtering & Fixed RPC)
-- Tác giả: Vu Duc Minh (Original) / AI Assistant (Refinements) - Ngày: [Ngày hiện tại]
--
-- MỤC TIÊU: Cung cấp một cấu trúc database hoàn chỉnh, an toàn, logic và
--           tối ưu hóa nghiệp vụ cho cửa hàng nước hoa trên Supabase.
--           **Phiên bản 3.2 sửa lỗi RPC filter_products, tối ưu hóa và giữ FTS.**
--
-- CÁC TÍNH NĂNG CHÍNH (Kế thừa và Cải tiến):
--   - Quản lý sản phẩm chi tiết (thương hiệu, danh mục, thuộc tính, biến thể, hình ảnh...).
--   - Kim tự tháp hương (Note Pyramid) chính xác.
--   - Quản lý người dùng và địa chỉ.
--   - Giỏ hàng và quy trình đặt hàng.
--   - Xử lý đơn hàng với trạng thái chi tiết, trigger logic.
--   - Vai trò người giao hàng (Shipper) nội bộ.
--   - Hỗ trợ thanh toán COD và Online.
--   - Theo dõi lịch sử tồn kho chi tiết, RPC điều chỉnh kho an toàn.
--   - Quản lý mã giảm giá.
--   - Đánh giá sản phẩm (có duyệt).
--   - Danh sách yêu thích.
--   - Tra cứu đơn hàng an toàn cho khách vãng lai.
--   - Ghi log hoạt động Admin/Staff chi tiết.
--   - Cài đặt chung cho cửa hàng.
--   - Tối ưu hóa hiệu năng với Indexes đầy đủ VÀ các index bổ sung cho lọc/FTS.
--   - Hỗ trợ Full-Text Search (FTS) cho tìm kiếm sản phẩm.
--   - **RPC `filter_products` đã sửa lỗi và hoạt động hiệu quả hơn.**
--   - Bảo mật với Row Level Security (RLS) chi tiết.
--   - Quản lý file với Storage Buckets & Policies.
--   - Trigger đảm bảo chỉ có 1 ảnh chính cho mỗi sản phẩm.
--
-- LƯU Ý QUAN TRỌNG CHO BACKEND DEVELOPER (V3.2):
--   - Cần cấu hình Roles ('admin', 'staff', 'shipper') trong Auth User Metadata.
--   - Logic Webhook (Momo, cổng thanh toán khác) là BẮT BUỘC ở backend.
--   - Logic gửi Email là BẮT BUỘC ở backend.
--   - Logic gán đơn hàng cho Shipper cần thực hiện qua Admin UI/Backend.
--   - Logic tự động hoàn thành đơn hàng cần Cron Job (Edge Function).
--   - **BẢO MẬT SHIPPER:** Khuyến nghị tạo VIEW/RPC riêng trả về *chỉ các cột cần thiết* cho Shipper.
--   - Sử dụng RPC `adjust_stock` cho mọi thao tác điều chỉnh kho thủ công.
--   - **Sử dụng RPC `filter_products` (đã sửa lỗi) cho trang danh sách sản phẩm.**
-- ============================================================================

-- Required Extensions
create extension if not exists "uuid-ossp";
create extension if not exists "unaccent";

-- ============================================================================
-- SECTION: TABLES (Database Structure) V3.2
-- ============================================================================

-- Địa chỉ người dùng
create table if not exists public.addresses (
    id bigint generated by default as identity primary key,
    user_id uuid references auth.users on delete cascade not null,
    recipient_name text not null,
    recipient_phone text not null,
    province_city text not null,
    district text not null,
    ward text not null,
    street_address text not null,
    postal_code text,
    is_default boolean default false not null,
    created_at timestamptz default now() not null,
    updated_at timestamptz default now() not null
);
comment on table public.addresses is '[V3.2] Lưu trữ các địa chỉ giao hàng/thanh toán của người dùng đã đăng nhập.';

-- Thông tin mở rộng của người dùng
create table if not exists public.profiles (
    id uuid not null primary key references auth.users on delete cascade,
    display_name text,
    phone_number text,
    gender text,
    birth_date date,
    avatar_url text,
    default_address_id bigint references public.addresses on delete set null,
    created_at timestamptz default now() not null,
    updated_at timestamptz default now() not null
);
comment on table public.profiles is '[V3.2] Bảng mở rộng thông tin cho auth.users, được tạo tự động khi có user mới.';

-- Thương hiệu nước hoa
create table if not exists public.brands (
    id bigint generated by default as identity primary key,
    name text unique not null,
    description text,
    logo_url text,
    created_at timestamptz default now() not null,
    updated_at timestamptz default now() not null
);
comment on table public.brands is '[V3.2] Quản lý danh sách các thương hiệu nước hoa.';

-- Giới tính (Áp dụng cho nước hoa)
create table if not exists public.genders (
    id smallint generated by default as identity primary key,
    name text unique not null,
    created_at timestamptz default now() not null,
    updated_at timestamptz default now() not null
);
comment on table public.genders is '[V3.2] Phân loại giới tính cho sản phẩm nước hoa.';

-- Loại nước hoa (phân khúc)
create table if not exists public.perfume_types (
    id smallint generated by default as identity primary key,
    name text unique not null,
    created_at timestamptz default now() not null,
    updated_at timestamptz default now() not null
);
comment on table public.perfume_types is '[V3.2] Phân loại nước hoa theo phân khúc (Designer, Niche...).';

-- Nồng độ tinh dầu
create table if not exists public.concentrations (
    id smallint generated by default as identity primary key,
    name text unique not null,
    description text,
    created_at timestamptz default now() not null,
    updated_at timestamptz default now() not null
);
comment on table public.concentrations is '[V3.2] Phân loại nồng độ tinh dầu nước hoa.';

-- Danh mục sản phẩm
create table if not exists public.categories (
    id bigint generated by default as identity primary key,
    name text not null unique,
    slug text unique,
    description text,
    image_url text,
    is_featured boolean default false not null,
    display_order int default 0 not null,
    parent_category_id bigint references public.categories on delete set null,
    created_at timestamptz default now() not null,
    updated_at timestamptz default now() not null
);
comment on table public.categories is '[V3.2] Quản lý danh mục sản phẩm, hỗ trợ phân cấp cha-con.';

-- Sản phẩm nước hoa chính
create table if not exists public.products (
    id bigint generated by default as identity primary key,
    name text not null,
    slug text unique,
    product_code text,
    short_description text,
    long_description text,
    brand_id bigint references public.brands on delete set null,
    gender_id smallint references public.genders on delete set null,
    perfume_type_id smallint references public.perfume_types on delete set null,
    concentration_id smallint references public.concentrations on delete set null,
    origin_country text,
    release_year smallint,
    style text,
    sillage text,
    longevity text,
    created_at timestamptz default now() not null,
    updated_at timestamptz default now() not null,
    deleted_at timestamptz,
    fts tsvector -- [V3.2 FTS] Column for Full-Text Search
);
comment on table public.products is '[V3.2] Lưu thông tin cốt lõi của một dòng nước hoa. Bao gồm cột fts cho tìm kiếm text.';
comment on column public.products.fts is '[V3.2 FTS] Pre-calculated tsvector for full-text search on name, descriptions.';

-- Các nhóm mùi hương
create table if not exists public.scents (
    id bigint generated by default as identity primary key,
    name text unique not null,
    description text,
    created_at timestamptz default now() not null,
    updated_at timestamptz default now() not null
);
comment on table public.scents is '[V3.2] Quản lý các nhóm mùi hương chính.';

-- Thành phần nước hoa
create table if not exists public.ingredients (
    id bigint generated by default as identity primary key,
    name text unique not null,
    created_at timestamptz default now() not null,
    updated_at timestamptz default now() not null
);
comment on table public.ingredients is '[V3.2] Quản lý danh sách các thành phần (note) cụ thể.';

-- Phiên bản sản phẩm
create table if not exists public.product_variants (
    id bigint generated by default as identity primary key,
    product_id bigint not null references public.products on delete cascade,
    volume_ml integer not null,
    price numeric not null check (price >= 0),
    sale_price numeric check (sale_price >= 0),
    sku text unique,
    stock_quantity integer not null default 0 check (stock_quantity >= 0),
    created_at timestamptz default now() not null,
    updated_at timestamptz default now() not null,
    deleted_at timestamptz,
    constraint price_check check (sale_price is null or sale_price <= price)
);
comment on table public.product_variants is '[V3.2] Các phiên bản khác nhau của một sản phẩm (theo dung tích, giá). Quản lý tồn kho.';

-- Liên kết Sản phẩm - Thành phần - Tầng hương
create table if not exists public.product_ingredients (
    id bigint generated by default as identity primary key,
    product_id bigint not null references public.products on delete cascade,
    ingredient_id bigint not null references public.ingredients on delete cascade,
    scent_type text not null check (scent_type in ('top', 'middle', 'base')),
    constraint product_ingredients_product_id_ingredient_id_scent_type_key unique (product_id, ingredient_id, scent_type)
);
comment on table public.product_ingredients is '[V3.2] Bảng N-N cốt lõi cho Kim tự tháp hương.';
comment on column public.product_ingredients.scent_type is 'Tầng hương (top, middle, base).';

-- Hình ảnh sản phẩm
create table if not exists public.product_images (
    id bigint generated by default as identity primary key,
    product_id bigint not null references public.products on delete cascade,
    image_url text not null,
    alt_text text,
    is_main boolean default false not null,
    display_order int default 0 not null,
    created_at timestamptz default now() not null,
    updated_at timestamptz default now() not null
);
comment on table public.product_images is '[V3.2] Quản lý nhiều hình ảnh cho một sản phẩm.';

-- Liên kết Sản phẩm - Danh mục
create table if not exists public.product_categories (
    id bigint generated by default as identity primary key,
    product_id bigint not null references public.products on delete cascade,
    category_id bigint not null references public.categories on delete cascade,
    unique (product_id, category_id)
);
comment on table public.product_categories is '[V3.2] Liên kết sản phẩm với các danh mục.';

-- Nhãn sản phẩm (Tags)
create table if not exists public.product_labels (
    id bigint generated by default as identity primary key,
    name text unique not null,
    color_code varchar(7),
    created_at timestamptz default now() not null,
    updated_at timestamptz default now() not null
);
comment on table public.product_labels is '[V3.2] Định nghĩa các loại nhãn sản phẩm.';

-- Gán nhãn cho sản phẩm
create table if not exists public.product_label_assignments (
    id bigint generated by default as identity primary key,
    product_id bigint not null references public.products on delete cascade,
    label_id bigint not null references public.product_labels on delete cascade,
    valid_until timestamptz,
    unique (product_id, label_id)
);
comment on table public.product_label_assignments is '[V3.2] Gán nhãn cụ thể cho sản phẩm, có thể có thời hạn.';

-- Liên kết Sản phẩm - Nhóm hương (N-N)
create table if not exists public.product_scents (
    id bigint generated by default as identity primary key,
    product_id bigint not null references public.products on delete cascade,
    scent_id bigint not null references public.scents on delete cascade,
    created_at timestamptz default now() not null,
    updated_at timestamptz default now() not null,
    constraint product_scents_product_id_scent_id_key unique (product_id, scent_id) -- Đảm bảo một sản phẩm không bị gán cùng 1 nhóm hương nhiều lần
);
comment on table public.product_scents is '[V3.2] Bảng N-N liên kết Sản phẩm với các Nhóm hương chính.';
comment on column public.product_scents.product_id is 'Khóa ngoại tham chiếu đến sản phẩm.';
comment on column public.product_scents.scent_id is 'Khóa ngoại tham chiếu đến nhóm hương.';

-- Mã giảm giá
create table if not exists public.discounts (
    id bigint generated by default as identity primary key,
    code text unique not null,
    description text,
    start_date timestamptz,
    end_date timestamptz,
    max_uses integer check (max_uses is null or max_uses >= 0),
    remaining_uses integer check (remaining_uses is null or remaining_uses >= 0),
    min_order_value numeric check (min_order_value is null or min_order_value >= 0),
    max_discount_amount numeric check (max_discount_amount is null or max_discount_amount >= 0),
    discount_percentage numeric check (discount_percentage is null or (discount_percentage > 0 and discount_percentage <= 100)),
    is_active boolean default true not null,
    created_at timestamptz default now() not null,
    updated_at timestamptz default now() not null
);
comment on table public.discounts is '[V3.2] Quản lý các mã giảm giá và điều kiện áp dụng.';

-- Giỏ hàng
create table if not exists public.shopping_carts (
    id bigint generated by default as identity primary key,
    user_id uuid references auth.users on delete cascade unique not null,
    created_at timestamptz default now() not null,
    updated_at timestamptz default now() not null
);
comment on table public.shopping_carts is '[V3.2] Đại diện cho giỏ hàng của mỗi người dùng đã đăng nhập.';

-- Các sản phẩm trong giỏ hàng
create table if not exists public.cart_items (
    id bigint generated by default as identity primary key,
    cart_id bigint not null references public.shopping_carts on delete cascade,
    variant_id bigint not null references public.product_variants on delete cascade,
    quantity integer not null check (quantity > 0),
    created_at timestamptz default now() not null,
    updated_at timestamptz default now() not null,
    unique(cart_id, variant_id)
);
comment on table public.cart_items is '[V3.2] Chi tiết các sản phẩm (biến thể) và số lượng trong một giỏ hàng.';

-- Trạng thái đơn hàng
create table if not exists public.order_statuses (
    id smallint generated by default as identity primary key,
    name text unique not null,
    description text
);
comment on table public.order_statuses is '[V3.2] Danh sách các trạng thái xử lý đơn hàng.';

-- Phương thức thanh toán
create table if not exists public.payment_methods (
    id smallint generated by default as identity primary key,
    name text unique not null,
    description text,
    is_active boolean default true not null
);
comment on table public.payment_methods is '[V3.2] Danh sách các phương thức thanh toán được chấp nhận.';

-- Đơn hàng
create table if not exists public.orders (
    id bigint generated by default as identity primary key,
    access_token uuid not null default uuid_generate_v4() unique,
    user_id uuid references auth.users on delete set null,
    assigned_shipper_id uuid references auth.users on delete set null,
    guest_name text,
    guest_email text,
    guest_phone text,
    recipient_name text not null,
    recipient_phone text not null,
    province_city text not null,
    district text not null,
    ward text not null,
    street_address text not null,
    order_date timestamptz default now() not null,
    delivery_notes text,
    payment_method_id smallint references public.payment_methods(id),
    payment_status text check (payment_status in ('Pending', 'Paid', 'Failed')) default 'Pending' not null,
    order_status_id smallint references public.order_statuses(id),
    discount_id bigint references public.discounts on delete set null,
    subtotal_amount numeric not null default 0 check (subtotal_amount >= 0),
    discount_amount numeric default 0 check (discount_amount >= 0),
    shipping_fee numeric default 0 check (shipping_fee >= 0),
    total_amount numeric not null default 0 check (total_amount >= 0),
    cancellation_reason text,
    cancelled_by text check (cancelled_by in ('user', 'admin')),
    cancelled_by_user_id uuid references auth.users on delete set null,
    delivery_failure_reason text,
    delivery_failure_timestamp timestamptz,
    completed_at timestamptz,
    created_at timestamptz default now() not null,
    updated_at timestamptz default now() not null
);
comment on table public.orders is '[V3.2] Bảng trung tâm lưu trữ mọi thông tin về đơn hàng.';
comment on column public.orders.delivery_failure_reason is 'Lý do giao hàng thất bại (do shipper ghi nhận lần gần nhất)';
comment on column public.orders.delivery_failure_timestamp is 'Thời điểm ghi nhận giao hàng thất bại lần gần nhất';

-- Chi tiết các sản phẩm trong đơn hàng
create table if not exists public.order_items (
    id bigint generated by default as identity primary key,
    order_id bigint not null references public.orders on delete cascade,
    variant_id bigint not null references public.product_variants on delete restrict,
    product_name text not null,
    variant_volume_ml integer not null,
    quantity integer not null check (quantity > 0),
    unit_price_at_order numeric not null check (unit_price_at_order >= 0),
    created_at timestamptz default now() not null,
    updated_at timestamptz default now() not null
);
comment on table public.order_items is '[V3.2] Lưu chi tiết từng sản phẩm trong một đơn hàng.';

-- Thông tin thanh toán chi tiết
create table if not exists public.payments (
    id bigint generated by default as identity primary key,
    order_id bigint not null references public.orders on delete cascade,
    payment_date timestamptz default now() not null,
    payment_method_id smallint references public.payment_methods(id),
    transaction_id text,
    amount numeric not null check (amount >= 0),
    status text check (status in ('Pending', 'Completed', 'Failed')) default 'Pending' not null,
    payment_details jsonb,
    created_at timestamptz default now() not null,
    updated_at timestamptz default now() not null
);
comment on table public.payments is '[V3.2] Chi tiết từng giao dịch thanh toán.';

-- Lịch sử thay đổi kho hàng
create table if not exists public.inventory (
    id bigint generated by default as identity primary key,
    variant_id bigint not null references public.product_variants on delete cascade,
    change_amount integer not null,
    reason text not null,
    order_id bigint references public.orders on delete set null,
    stock_after_change integer not null,
    updated_by uuid references auth.users on delete set null,
    timestamp timestamptz default now() not null,
    created_at timestamptz default now() not null,
    updated_at timestamptz default now() not null,
    constraint inventory_change_amount_check check (change_amount != 0),
    constraint inventory_stock_after_change_check check (stock_after_change >= 0)
);
comment on table public.inventory is '[V3.2] Nhật ký ghi lại mọi thay đổi về số lượng tồn kho.';
comment on column public.inventory.reason is 'Lý do thay đổi tồn kho (BẮT BUỘC)';
comment on column public.inventory.stock_after_change is 'Số lượng tồn kho SAU KHI thay đổi (BẮT BUỘC, không âm)';
comment on column public.inventory.updated_by is 'Admin/Staff thực hiện điều chỉnh thủ công (NULL nếu là hệ thống)';

-- Đánh giá sản phẩm
create table if not exists public.reviews (
    id bigint generated by default as identity primary key,
    product_id bigint not null references public.products on delete cascade,
    user_id uuid not null references auth.users on delete cascade,
    order_item_id bigint references public.order_items on delete set null,
    rating smallint not null check (rating >= 1 and rating <= 5),
    comment text,
    is_approved boolean default false not null,
    approved_by uuid references auth.users on delete set null,
    approved_at timestamptz,
    created_at timestamptz default now() not null,
    updated_at timestamptz default now() not null,
    unique(user_id, product_id)
);
comment on table public.reviews is '[V3.2] Lưu trữ đánh giá của khách hàng về sản phẩm, cần được duyệt.';

-- Phản hồi đánh giá
create table if not exists public.review_replies (
    id bigint generated by default as identity primary key,
    review_id bigint not null references public.reviews on delete cascade,
    staff_id uuid not null references auth.users on delete cascade,
    reply_text text not null,
    created_at timestamptz default now() not null,
    updated_at timestamptz default now() not null
);
comment on table public.review_replies is '[V3.2] Lưu trữ các phản hồi của Admin/Staff đối với đánh giá.';

-- Danh sách yêu thích
create table if not exists public.wishlists (
    id bigint generated by default as identity primary key,
    user_id uuid not null references auth.users on delete cascade,
    product_id bigint not null references public.products on delete cascade,
    added_at timestamptz default now() not null,
    unique (user_id, product_id)
);
comment on table public.wishlists is '[V3.2] Lưu danh sách các sản phẩm mà người dùng đánh dấu yêu thích.';

-- Log hoạt động của Admin/Staff
create table if not exists public.admin_activity_log (
    id bigint generated by default as identity primary key,
    admin_user_id uuid references auth.users on delete set null,
    activity_type text not null,
    description text,
    entity_type text,
    entity_id text,
    details jsonb,
    timestamp timestamptz default now() not null
);
comment on table public.admin_activity_log is '[V3.2] Nhật ký ghi lại các hành động quan trọng do Admin/Staff thực hiện.';

-- Banner quảng cáo
create table if not exists public.banners (
    id bigint generated by default as identity primary key,
    title text not null,
    subtitle text,
    image_url text not null,
    link_url text,
    is_active boolean default true not null,
    display_order int default 0 not null,
    start_date timestamptz,
    end_date timestamptz,
    created_at timestamptz default now() not null,
    updated_at timestamptz default now() not null
);
comment on table public.banners is '[V3.2] Quản lý các banner quảng cáo.';

-- Cài đặt chung của cửa hàng
create table if not exists public.shop_settings (
    id smallint primary key default 1,
    shop_name text not null,
    shop_logo_url text,
    contact_email text,
    contact_phone text,
    address text,
    facebook_url text,
    messenger_url text,
    zalo_url text,
    instagram_url text,
    tiktok_url text,
    youtube_url text,
    refund_policy_text text,
    shipping_policy_text text,
    privacy_policy_text text,
    terms_conditions_text text,
    default_shipping_fee numeric default 0 check (default_shipping_fee >= 0) not null,
    order_confirmation_sender_email text,
    created_at timestamptz default now() not null,
    updated_at timestamptz default now() not null,
    constraint single_row check (id = 1)
);
comment on table public.shop_settings is '[V3.2] Lưu trữ các cài đặt và thông tin chung của toàn bộ cửa hàng.';

-- ============================================================================
-- SECTION: ROW LEVEL SECURITY (RLS) Activation V3.2
-- Kích hoạt RLS cho tất cả các bảng để bảo mật dữ liệu.
-- ============================================================================

alter table public.addresses enable row level security;
alter table public.profiles enable row level security;
alter table public.brands enable row level security;
alter table public.genders enable row level security;
alter table public.perfume_types enable row level security;
alter table public.concentrations enable row level security;
alter table public.categories enable row level security;
alter table public.products enable row level security;
alter table public.scents enable row level security;
alter table public.ingredients enable row level security;
alter table public.product_variants enable row level security;
alter table public.product_ingredients enable row level security;
alter table public.product_images enable row level security;
alter table public.product_categories enable row level security;
alter table public.product_labels enable row level security;
alter table public.product_label_assignments enable row level security;
alter table public.discounts enable row level security;
alter table public.shopping_carts enable row level security;
alter table public.cart_items enable row level security;
alter table public.order_statuses enable row level security;
alter table public.payment_methods enable row level security;
alter table public.orders enable row level security;
alter table public.order_items enable row level security;
alter table public.payments enable row level security;
alter table public.inventory enable row level security;
alter table public.reviews enable row level security;
alter table public.review_replies enable row level security;
alter table public.wishlists enable row level security;
alter table public.admin_activity_log enable row level security;
alter table public.banners enable row level security;
alter table public.shop_settings enable row level security;
alter table public.product_scents enable row level security;
-- Kích hoạt RLS cho auth.users (nếu chưa)
ALTER TABLE auth.users ENABLE ROW LEVEL SECURITY;

-- ============================================================================
-- SECTION: FUNCTIONS & TRIGGERS (Tự động hóa & Hàm hỗ trợ) V3.2
-- ============================================================================

-- FUNCTION: Tự động tạo profile khi user mới đăng ký
-- DROP FUNCTION IF EXISTS public.handle_new_user(); -- Không cần drop nếu dùng CREATE OR REPLACE
CREATE OR REPLACE FUNCTION public.handle_new_user()
RETURNS TRIGGER LANGUAGE plpgsql SECURITY DEFINER SET search_path = public AS $$
BEGIN
  INSERT INTO public.profiles (id, display_name, phone_number)
  VALUES (NEW.id, NEW.raw_user_meta_data->>'display_name', NEW.raw_user_meta_data->>'phone_number');
  RETURN NEW;
END;
$$;
comment on function public.handle_new_user() is '[V3.2] Tự động tạo bản ghi trong public.profiles khi có người dùng mới.';

-- TRIGGER: Gọi hàm handle_new_user
DROP TRIGGER IF EXISTS on_auth_user_created_profile ON auth.users;
CREATE TRIGGER on_auth_user_created_profile
AFTER INSERT ON auth.users FOR EACH ROW EXECUTE PROCEDURE public.handle_new_user();

-- FUNCTION: Tự động tạo giỏ hàng cho user mới
-- DROP FUNCTION IF EXISTS public.create_shopping_cart_for_new_user();
CREATE OR REPLACE FUNCTION public.create_shopping_cart_for_new_user()
RETURNS TRIGGER LANGUAGE plpgsql SECURITY DEFINER SET search_path = public AS $$
BEGIN
  INSERT INTO public.shopping_carts (user_id) VALUES (NEW.id);
  RETURN NEW;
END;
$$;
comment on function public.create_shopping_cart_for_new_user() is '[V3.2] Tự động tạo giỏ hàng trống cho người dùng mới.';

-- TRIGGER: Gọi hàm create_shopping_cart_for_new_user
DROP TRIGGER IF EXISTS on_auth_user_created_cart ON auth.users;
CREATE TRIGGER on_auth_user_created_cart
AFTER INSERT ON auth.users FOR EACH ROW EXECUTE PROCEDURE public.create_shopping_cart_for_new_user();

-- FUNCTION: Tự động cập nhật trường 'updated_at'
-- DROP FUNCTION IF EXISTS public.handle_updated_at();
CREATE OR REPLACE FUNCTION public.handle_updated_at()
RETURNS TRIGGER LANGUAGE plpgsql SECURITY DEFINER SET search_path = public AS $$
BEGIN
  NEW.updated_at = now();
  RETURN NEW;
END;
$$;
comment on function public.handle_updated_at() is '[V3.2] Tự động cập nhật trường updated_at.';

-- TRIGGERS: Áp dụng hàm handle_updated_at (Sử dụng DROP IF EXISTS để an toàn khi chạy lại)
DROP TRIGGER IF EXISTS set_updated_at ON public.addresses; CREATE TRIGGER set_updated_at BEFORE UPDATE ON public.addresses FOR EACH ROW EXECUTE PROCEDURE public.handle_updated_at();
DROP TRIGGER IF EXISTS set_updated_at ON public.profiles; CREATE TRIGGER set_updated_at BEFORE UPDATE ON public.profiles FOR EACH ROW EXECUTE PROCEDURE public.handle_updated_at();
DROP TRIGGER IF EXISTS set_updated_at ON public.brands; CREATE TRIGGER set_updated_at BEFORE UPDATE ON public.brands FOR EACH ROW EXECUTE PROCEDURE public.handle_updated_at();
DROP TRIGGER IF EXISTS set_updated_at ON public.genders; CREATE TRIGGER set_updated_at BEFORE UPDATE ON public.genders FOR EACH ROW EXECUTE PROCEDURE public.handle_updated_at();
DROP TRIGGER IF EXISTS set_updated_at ON public.perfume_types; CREATE TRIGGER set_updated_at BEFORE UPDATE ON public.perfume_types FOR EACH ROW EXECUTE PROCEDURE public.handle_updated_at();
DROP TRIGGER IF EXISTS set_updated_at ON public.concentrations; CREATE TRIGGER set_updated_at BEFORE UPDATE ON public.concentrations FOR EACH ROW EXECUTE PROCEDURE public.handle_updated_at();
DROP TRIGGER IF EXISTS set_updated_at ON public.categories; CREATE TRIGGER set_updated_at BEFORE UPDATE ON public.categories FOR EACH ROW EXECUTE PROCEDURE public.handle_updated_at();
DROP TRIGGER IF EXISTS set_updated_at ON public.products; CREATE TRIGGER set_updated_at BEFORE UPDATE ON public.products FOR EACH ROW EXECUTE PROCEDURE public.handle_updated_at();
DROP TRIGGER IF EXISTS set_updated_at ON public.scents; CREATE TRIGGER set_updated_at BEFORE UPDATE ON public.scents FOR EACH ROW EXECUTE PROCEDURE public.handle_updated_at();
DROP TRIGGER IF EXISTS set_updated_at ON public.ingredients; CREATE TRIGGER set_updated_at BEFORE UPDATE ON public.ingredients FOR EACH ROW EXECUTE PROCEDURE public.handle_updated_at();
DROP TRIGGER IF EXISTS set_updated_at ON public.product_variants; CREATE TRIGGER set_updated_at BEFORE UPDATE ON public.product_variants FOR EACH ROW EXECUTE PROCEDURE public.handle_updated_at();
DROP TRIGGER IF EXISTS set_updated_at ON public.product_images; CREATE TRIGGER set_updated_at BEFORE UPDATE ON public.product_images FOR EACH ROW EXECUTE PROCEDURE public.handle_updated_at();
DROP TRIGGER IF EXISTS set_updated_at ON public.product_labels; CREATE TRIGGER set_updated_at BEFORE UPDATE ON public.product_labels FOR EACH ROW EXECUTE PROCEDURE public.handle_updated_at();
DROP TRIGGER IF EXISTS set_updated_at ON public.discounts; CREATE TRIGGER set_updated_at BEFORE UPDATE ON public.discounts FOR EACH ROW EXECUTE PROCEDURE public.handle_updated_at();
DROP TRIGGER IF EXISTS set_updated_at ON public.shopping_carts; CREATE TRIGGER set_updated_at BEFORE UPDATE ON public.shopping_carts FOR EACH ROW EXECUTE PROCEDURE public.handle_updated_at();
DROP TRIGGER IF EXISTS set_updated_at ON public.cart_items; CREATE TRIGGER set_updated_at BEFORE UPDATE ON public.cart_items FOR EACH ROW EXECUTE PROCEDURE public.handle_updated_at();
DROP TRIGGER IF EXISTS set_updated_at ON public.orders; CREATE TRIGGER set_updated_at BEFORE UPDATE ON public.orders FOR EACH ROW EXECUTE PROCEDURE public.handle_updated_at();
DROP TRIGGER IF EXISTS set_updated_at ON public.order_items; CREATE TRIGGER set_updated_at BEFORE UPDATE ON public.order_items FOR EACH ROW EXECUTE PROCEDURE public.handle_updated_at();
DROP TRIGGER IF EXISTS set_updated_at ON public.payments; CREATE TRIGGER set_updated_at BEFORE UPDATE ON public.payments FOR EACH ROW EXECUTE PROCEDURE public.handle_updated_at();
DROP TRIGGER IF EXISTS set_updated_at ON public.inventory; CREATE TRIGGER set_updated_at BEFORE UPDATE ON public.inventory FOR EACH ROW EXECUTE PROCEDURE public.handle_updated_at();
DROP TRIGGER IF EXISTS set_updated_at ON public.reviews; CREATE TRIGGER set_updated_at BEFORE UPDATE ON public.reviews FOR EACH ROW EXECUTE PROCEDURE public.handle_updated_at();
DROP TRIGGER IF EXISTS set_updated_at ON public.review_replies; CREATE TRIGGER set_updated_at BEFORE UPDATE ON public.review_replies FOR EACH ROW EXECUTE PROCEDURE public.handle_updated_at();
DROP TRIGGER IF EXISTS set_updated_at ON public.banners; CREATE TRIGGER set_updated_at BEFORE UPDATE ON public.banners FOR EACH ROW EXECUTE PROCEDURE public.handle_updated_at();
DROP TRIGGER IF EXISTS set_updated_at ON public.shop_settings; CREATE TRIGGER set_updated_at BEFORE UPDATE ON public.shop_settings FOR EACH ROW EXECUTE PROCEDURE public.handle_updated_at();
DROP TRIGGER IF EXISTS set_updated_at ON public.product_scents; CREATE TRIGGER set_updated_at BEFORE UPDATE ON public.product_scents FOR EACH ROW EXECUTE PROCEDURE public.handle_updated_at();

-- FUNCTION: Lấy vai trò (role) của người dùng
-- DROP FUNCTION IF EXISTS public.get_auth_role();
CREATE OR REPLACE FUNCTION public.get_auth_role()
RETURNS TEXT LANGUAGE sql STABLE SECURITY DEFINER SET search_path = public AS $$
  SELECT CASE
    WHEN auth.uid() IS NULL THEN 'anon'
    ELSE coalesce((SELECT raw_app_meta_data->>'role' FROM auth.users WHERE id = auth.uid()), 'authenticated')
  END;
$$;
comment on function public.get_auth_role() is '[V3.2] Lấy vai trò người dùng (admin, staff, shipper, authenticated, anon).';

-- FUNCTION: Kiểm tra Admin
-- DROP FUNCTION IF EXISTS public.is_admin();
CREATE OR REPLACE FUNCTION public.is_admin()
RETURNS BOOLEAN LANGUAGE sql STABLE SECURITY DEFINER SET search_path = public
AS $$ SELECT public.get_auth_role() = 'admin'; $$;
comment on function public.is_admin() is '[V3.2] Kiểm tra người dùng hiện tại có vai trò "admin".';

-- FUNCTION: Kiểm tra Staff hoặc Admin
-- DROP FUNCTION IF EXISTS public.is_staff();
CREATE OR REPLACE FUNCTION public.is_staff()
RETURNS BOOLEAN LANGUAGE sql STABLE SECURITY DEFINER SET search_path = public
AS $$ SELECT public.get_auth_role() IN ('staff', 'admin'); $$;
comment on function public.is_staff() is '[V3.2] Kiểm tra người dùng hiện tại có vai trò "staff" hoặc "admin".';

-- FUNCTION: Kiểm tra Shipper
-- DROP FUNCTION IF EXISTS public.is_shipper();
CREATE OR REPLACE FUNCTION public.is_shipper()
RETURNS BOOLEAN LANGUAGE sql STABLE SECURITY DEFINER SET search_path = public
AS $$ SELECT public.get_auth_role() = 'shipper'; $$;
comment on function public.is_shipper() is '[V3.2] Kiểm tra người dùng hiện tại có vai trò "shipper".';

-- FUNCTION: Kiểm tra user đã mua sản phẩm chưa
-- DROP FUNCTION IF EXISTS public.has_user_purchased_product(bigint);
CREATE OR REPLACE FUNCTION public.has_user_purchased_product(p_product_id bigint)
RETURNS boolean LANGUAGE plpgsql STABLE SECURITY DEFINER SET search_path = public AS $$
DECLARE completed_status_ids smallint[];
BEGIN
  SELECT array_agg(id) INTO completed_status_ids FROM public.order_statuses WHERE name IN ('Đã giao', 'Đã hoàn thành');
  RETURN EXISTS (
    SELECT 1
    FROM public.orders o
    JOIN public.order_items oi ON o.id = oi.order_id
    JOIN public.product_variants pv ON oi.variant_id = pv.id
    WHERE o.user_id = auth.uid()
      AND pv.product_id = p_product_id
      AND o.order_status_id = ANY(completed_status_ids)
  );
END; $$;
comment on function public.has_user_purchased_product(bigint) is '[V3.2] Kiểm tra xem người dùng đăng nhập đã mua sản phẩm chưa.';

-- FUNCTION: Cập nhật tồn kho KHI đơn hàng chuyển sang 'Đã giao'
-- DROP FUNCTION IF EXISTS public.update_inventory_on_order_shipped();
CREATE OR REPLACE FUNCTION public.update_inventory_on_order_shipped()
RETURNS TRIGGER LANGUAGE plpgsql SECURITY DEFINER SET search_path = public AS $$
DECLARE
  shipped_status_id smallint; item record; current_stock integer;
BEGIN
  SELECT id INTO shipped_status_id FROM public.order_statuses WHERE name = 'Đã giao';
  IF NEW.order_status_id = shipped_status_id AND OLD.order_status_id IS DISTINCT FROM shipped_status_id THEN
    FOR item IN SELECT variant_id, quantity FROM public.order_items WHERE order_id = NEW.id LOOP
      UPDATE public.product_variants pv SET stock_quantity = stock_quantity - item.quantity
      WHERE id = item.variant_id RETURNING stock_quantity INTO current_stock;
      IF current_stock < 0 THEN RAISE WARNING '[INVENTORY WARNING] Tồn kho âm (%) cho variant_id % sau khi giao đơn hàng %.', current_stock, item.variant_id, NEW.id; END IF;
      INSERT INTO public.inventory (variant_id, change_amount, reason, order_id, stock_after_change, updated_by)
      VALUES (item.variant_id, -item.quantity, 'Đơn hàng đã giao', NEW.id, current_stock, NULL);
    END LOOP;
  END IF;
  RETURN NEW;
END;
$$;
comment on function public.update_inventory_on_order_shipped is '[V3.2] Tự động giảm tồn kho và ghi log khi đơn hàng chuyển sang "Đã giao".';

-- TRIGGER: Gọi hàm update_inventory_on_order_shipped
DROP TRIGGER IF EXISTS trigger_update_inventory_on_order_shipped ON public.orders;
CREATE TRIGGER trigger_update_inventory_on_order_shipped
AFTER UPDATE OF order_status_id ON public.orders
FOR EACH ROW EXECUTE PROCEDURE public.update_inventory_on_order_shipped();

-- FUNCTION: Kiểm tra tồn kho trước khi thêm/cập nhật giỏ hàng
-- DROP FUNCTION IF EXISTS public.validate_stock_before_cart_change();
CREATE OR REPLACE FUNCTION public.validate_stock_before_cart_change()
RETURNS TRIGGER LANGUAGE plpgsql SECURITY DEFINER SET search_path = public AS $$
DECLARE available_stock integer; variant_info text; requested_increase integer;
BEGIN
  SELECT pv.stock_quantity, p.name || ' (' || pv.volume_ml || 'ml)' INTO available_stock, variant_info
  FROM public.product_variants pv JOIN public.products p ON pv.product_id = p.id
  WHERE pv.id = NEW.variant_id AND pv.deleted_at IS NULL;
  IF available_stock IS NULL THEN RAISE EXCEPTION 'Sản phẩm không tồn tại hoặc đã bị xóa.'; END IF;
  IF TG_OP = 'INSERT' THEN
      IF available_stock < NEW.quantity THEN RAISE EXCEPTION 'Không đủ hàng cho "%". Chỉ còn % sản phẩm.', variant_info, available_stock; END IF;
  ELSIF TG_OP = 'UPDATE' THEN
      IF NEW.quantity > OLD.quantity THEN
          -- Lấy lại tồn kho mới nhất trước khi kiểm tra
          SELECT pv.stock_quantity INTO available_stock FROM public.product_variants pv WHERE pv.id = NEW.variant_id AND pv.deleted_at IS NULL;
          IF available_stock < NEW.quantity THEN RAISE EXCEPTION 'Không đủ hàng cho "%". Chỉ còn % sản phẩm trong kho.', variant_info, available_stock; END IF;
      END IF;
  END IF;
  RETURN NEW;
END; $$;
comment on function public.validate_stock_before_cart_change is '[V3.2] Kiểm tra tồn kho trước khi thêm/update số lượng vào cart_items.';

-- TRIGGER: Gọi hàm validate_stock_before_cart_change
DROP TRIGGER IF EXISTS trigger_validate_stock_before_cart_change ON public.cart_items;
CREATE TRIGGER trigger_validate_stock_before_cart_change
BEFORE INSERT OR UPDATE OF quantity ON public.cart_items
FOR EACH ROW EXECUTE PROCEDURE public.validate_stock_before_cart_change();

-- FUNCTION: Tạo slug
-- DROP FUNCTION IF EXISTS public.generate_slug(text);
CREATE OR REPLACE FUNCTION public.generate_slug(name_input text)
RETURNS text LANGUAGE sql IMMUTABLE STRICT SECURITY DEFINER SET search_path = public AS $$
  SELECT trim(BOTH '-' FROM regexp_replace(regexp_replace(lower(unaccent(trim(name_input))), '[^a-z0-9]+', '-', 'g'), '-{2,}', '-', 'g'));
$$;
comment on function public.generate_slug(text) is '[V3.2] Tạo chuỗi slug thân thiện URL.';

-- FUNCTION: Tự động tạo slug sản phẩm
-- DROP FUNCTION IF EXISTS public.set_product_slug();
CREATE OR REPLACE FUNCTION public.set_product_slug()
RETURNS TRIGGER LANGUAGE plpgsql SECURITY DEFINER SET search_path = public AS $$
DECLARE base_slug text; final_slug text; counter integer := 0; BEGIN
  IF (TG_OP = 'INSERT' OR NEW.name IS DISTINCT FROM OLD.name) AND (NEW.slug IS NULL OR NEW.slug = '' OR NEW.name IS DISTINCT FROM OLD.name) THEN
    base_slug := public.generate_slug(NEW.name);
    IF base_slug = '' THEN base_slug := 'san-pham'; END IF;
    final_slug := base_slug;
    WHILE EXISTS (SELECT 1 FROM public.products WHERE slug = final_slug AND id IS DISTINCT FROM NEW.id) LOOP
      counter := counter + 1; final_slug := base_slug || '-' || counter::text;
    END LOOP;
    NEW.slug := final_slug;
  END IF;
  RETURN NEW;
END; $$;
comment on function public.set_product_slug() is '[V3.2] Tự động tạo/cập nhật products.slug.';

-- TRIGGER: Gọi hàm set_product_slug
DROP TRIGGER IF EXISTS trigger_set_product_slug ON public.products;
CREATE TRIGGER trigger_set_product_slug BEFORE INSERT OR UPDATE OF name, slug ON public.products
FOR EACH ROW EXECUTE PROCEDURE public.set_product_slug();

-- FUNCTION: Tự động tạo slug danh mục
-- DROP FUNCTION IF EXISTS public.set_category_slug();
CREATE OR REPLACE FUNCTION public.set_category_slug()
RETURNS TRIGGER LANGUAGE plpgsql SECURITY DEFINER SET search_path = public AS $$
DECLARE base_slug text; final_slug text; counter integer := 0; BEGIN
  IF (TG_OP = 'INSERT' OR NEW.name IS DISTINCT FROM OLD.name) AND (NEW.slug IS NULL OR NEW.slug = '' OR NEW.name IS DISTINCT FROM OLD.name) THEN
    base_slug := public.generate_slug(NEW.name);
    IF base_slug = '' THEN base_slug := 'danh-muc'; END IF;
    final_slug := base_slug;
    WHILE EXISTS (SELECT 1 FROM public.categories WHERE slug = final_slug AND id IS DISTINCT FROM NEW.id) LOOP
      counter := counter + 1; final_slug := base_slug || '-' || counter::text;
    END LOOP;
    NEW.slug := final_slug;
  END IF;
  RETURN NEW;
END; $$;
comment on function public.set_category_slug() is '[V3.2] Tự động tạo/cập nhật categories.slug.';

-- TRIGGER: Gọi hàm set_category_slug
DROP TRIGGER IF EXISTS trigger_set_category_slug ON public.categories;
CREATE TRIGGER trigger_set_category_slug BEFORE INSERT OR UPDATE OF name, slug ON public.categories
FOR EACH ROW EXECUTE PROCEDURE public.set_category_slug();

-- FUNCTION: Tính toán tổng tiền đơn hàng
-- DROP FUNCTION IF EXISTS public.calculate_order_total();
CREATE OR REPLACE FUNCTION public.calculate_order_total()
RETURNS TRIGGER LANGUAGE plpgsql SECURITY DEFINER SET search_path = public AS $$
DECLARE items_total numeric; disc_amt numeric := 0; ship_fee numeric; d public.discounts%rowtype; s public.shop_settings%rowtype;
BEGIN
  items_total := NEW.subtotal_amount;
  IF items_total IS NULL THEN RAISE EXCEPTION 'Lỗi logic: subtotal_amount phải được cung cấp trước khi tính tổng đơn hàng.'; END IF;
  SELECT * INTO s FROM public.shop_settings WHERE id = 1;
  ship_fee := coalesce(NEW.shipping_fee, s.default_shipping_fee, 0);
  IF NEW.discount_id IS NOT NULL THEN
    SELECT * INTO d FROM public.discounts WHERE id = NEW.discount_id AND is_active = true;
    IF d IS NOT NULL THEN
      IF d.discount_percentage IS NOT NULL THEN
        disc_amt := items_total * (d.discount_percentage / 100.0);
        IF d.max_discount_amount IS NOT NULL AND disc_amt > d.max_discount_amount THEN disc_amt := d.max_discount_amount; END IF;
      ELSIF d.max_discount_amount IS NOT NULL THEN
         disc_amt := d.max_discount_amount;
         IF disc_amt > items_total THEN disc_amt := items_total; END IF;
      END IF;
    END IF;
  END IF;
  NEW.discount_amount := disc_amt;
  NEW.shipping_fee := ship_fee;
  NEW.total_amount := items_total - disc_amt + ship_fee;
  IF NEW.total_amount < 0 THEN NEW.total_amount := 0; END IF;
  RETURN NEW;
END; $$;
comment on function public.calculate_order_total() is '[V3.2] Tự động tính discount_amount, shipping_fee, total_amount. Yêu cầu subtotal_amount.';

-- TRIGGER: Gọi hàm calculate_order_total (CHẠY TRƯỚC validate_discount_code)
DROP TRIGGER IF EXISTS trigger_calculate_order_total ON public.orders;
CREATE TRIGGER trigger_calculate_order_total
BEFORE INSERT OR UPDATE ON public.orders
FOR EACH ROW EXECUTE PROCEDURE public.calculate_order_total();

-- FUNCTION: Kiểm tra mã giảm giá hợp lệ
-- DROP FUNCTION IF EXISTS public.validate_discount_code();
CREATE OR REPLACE FUNCTION public.validate_discount_code()
RETURNS TRIGGER LANGUAGE plpgsql SECURITY DEFINER SET search_path = public AS $$
DECLARE d public.discounts%rowtype;
BEGIN
  IF NEW.discount_id IS NOT NULL AND (NEW.discount_id IS DISTINCT FROM OLD.discount_id OR NEW.subtotal_amount IS DISTINCT FROM OLD.subtotal_amount) THEN
    SELECT * INTO d FROM public.discounts WHERE id = NEW.discount_id;
    IF d IS NULL THEN RAISE EXCEPTION 'Mã giảm giá không hợp lệ.'; END IF;
    IF d.is_active = false THEN RAISE EXCEPTION 'Mã "%" không hoạt động.', d.code; END IF;
    IF d.start_date IS NOT NULL AND d.start_date > now() THEN RAISE EXCEPTION 'Mã "%" chưa đến ngày sử dụng.', d.code; END IF;
    IF d.end_date IS NOT NULL AND d.end_date < now() THEN RAISE EXCEPTION 'Mã "%" đã hết hạn.', d.code; END IF;
    IF d.remaining_uses IS NOT NULL AND d.remaining_uses <= 0 THEN RAISE EXCEPTION 'Mã "%" đã hết lượt sử dụng.', d.code; END IF;
    IF d.min_order_value IS NOT NULL AND d.min_order_value > NEW.subtotal_amount THEN RAISE EXCEPTION 'Đơn hàng chưa đủ giá trị tối thiểu % để dùng mã "%".', d.min_order_value, d.code; END IF;
    IF TG_OP = 'INSERT' AND d.remaining_uses IS NOT NULL THEN
       UPDATE public.discounts SET remaining_uses = remaining_uses - 1 WHERE id = NEW.discount_id;
    END IF;
  ELSIF TG_OP = 'UPDATE' AND OLD.discount_id IS NOT NULL AND NEW.discount_id IS NULL THEN
      SELECT * INTO d FROM public.discounts WHERE id = OLD.discount_id;
      IF d IS NOT NULL AND d.remaining_uses IS NOT NULL THEN
          UPDATE public.discounts SET remaining_uses = remaining_uses + 1 WHERE id = OLD.discount_id;
      END IF;
  END IF;
  RETURN NEW;
END; $$;
comment on function public.validate_discount_code() is '[V3.2] Kiểm tra tính hợp lệ của mã giảm giá. Tự động giảm/hoàn trả lượt dùng.';

-- TRIGGER: Gọi hàm validate_discount_code (CHẠY SAU calculate_order_total)
DROP TRIGGER IF EXISTS trigger_validate_discount_code ON public.orders;
CREATE TRIGGER trigger_validate_discount_code
BEFORE INSERT OR UPDATE ON public.orders
FOR EACH ROW EXECUTE PROCEDURE public.validate_discount_code();

-- FUNCTION: Ngăn chặn thay đổi trạng thái đơn hàng không hợp lệ
-- DROP FUNCTION IF EXISTS public.prevent_invalid_status_transitions();
CREATE OR REPLACE FUNCTION public.prevent_invalid_status_transitions()
RETURNS TRIGGER LANGUAGE plpgsql SECURITY DEFINER SET search_path = public AS $$
DECLARE old_status_name text; new_status_name text; processing_statuses text[] := ARRAY['Đang xử lý', 'Đang giao', 'Đã giao', 'Đã hoàn thành'];
BEGIN
  IF TG_OP = 'INSERT' THEN RETURN NEW; END IF;
  SELECT name INTO old_status_name FROM public.order_statuses WHERE id = OLD.order_status_id;
  SELECT name INTO new_status_name FROM public.order_statuses WHERE id = NEW.order_status_id;
  IF OLD.order_status_id = NEW.order_status_id THEN RETURN NEW; END IF;
  IF old_status_name = 'Đã hủy' THEN RAISE EXCEPTION 'Không thể thay đổi trạng thái của đơn hàng đã hủy.'; END IF;
  IF old_status_name = 'Đã hoàn thành' AND new_status_name != 'Đã hủy' THEN RAISE EXCEPTION 'Không thể thay đổi trạng thái của đơn hàng đã hoàn thành (trừ khi Admin hủy).'; END IF;
  IF new_status_name = ANY(processing_statuses) AND OLD.payment_status = 'Failed' AND NEW.payment_status IS DISTINCT FROM 'Paid' THEN RAISE EXCEPTION 'Không thể xử lý/giao/hoàn thành đơn hàng có thanh toán thất bại (Trạng thái hiện tại: %).', OLD.payment_status; END IF;
  IF old_status_name IN ('Đang giao', 'Đã giao') AND new_status_name NOT IN ('Đã hoàn thành', 'Đã hủy', 'Đang giao') THEN RAISE EXCEPTION 'Không thể chuyển trạng thái từ "%" về "%".', old_status_name, new_status_name; END IF;
  IF old_status_name = 'Chờ xác nhận' AND new_status_name IN ('Đã giao', 'Đã hoàn thành') THEN RAISE EXCEPTION 'Phải chuyển sang "Đã xác nhận" hoặc "Đang xử lý" trước.'; END IF;
  IF new_status_name = 'Đã hoàn thành' AND OLD.payment_status != 'Paid' AND NEW.payment_status != 'Paid' THEN RAISE EXCEPTION 'Không thể hoàn thành đơn hàng chưa được thanh toán.'; END IF;
  RETURN NEW;
END;
$$;
comment on function public.prevent_invalid_status_transitions() is '[V3.2] Ngăn chặn các thay đổi trạng thái đơn hàng không hợp logic.';

-- TRIGGER: Gọi hàm prevent_invalid_status_transitions
DROP TRIGGER IF EXISTS trigger_prevent_invalid_status_transitions ON public.orders;
CREATE TRIGGER trigger_prevent_invalid_status_transitions
BEFORE UPDATE OF order_status_id ON public.orders
FOR EACH ROW EXECUTE PROCEDURE public.prevent_invalid_status_transitions();

-- FUNCTION: Ghi log hoạt động của Admin/Staff (Phiên bản chi tiết, hợp nhất)
-- DROP FUNCTION IF EXISTS public.log_admin_activity();
CREATE OR REPLACE FUNCTION public.log_admin_activity()
RETURNS TRIGGER LANGUAGE plpgsql SECURITY DEFINER SET search_path = public AS $$
DECLARE
  act_type text; descrip text; ent_type text; ent_id text; dets jsonb; role text;
  old_j jsonb; new_j jsonb; old_status_name text; new_status_name text; affected_user_email text;
  old_shipper_email text; new_shipper_email text; action_verb text; entity_name text; entity_id_val text;
  admin_user_info text;
BEGIN
  role := public.get_auth_role();
  IF role NOT IN ('admin', 'staff') THEN RETURN NULL; END IF;
  SELECT coalesce(email, auth.uid()::text) INTO admin_user_info FROM auth.users WHERE id = auth.uid();
  ent_type := TG_TABLE_NAME;
  action_verb := CASE TG_OP WHEN 'INSERT' THEN 'Tạo mới' WHEN 'UPDATE' THEN 'Cập nhật' WHEN 'DELETE' THEN 'Xóa' ELSE TG_OP END;
  IF TG_OP = 'UPDATE' THEN old_j := to_jsonb(OLD); new_j := to_jsonb(NEW); dets := jsonb_build_object('old', old_j - 'updated_at' - 'created_at', 'new', new_j - 'updated_at' - 'created_at'); entity_id_val := coalesce(OLD.id::text, NEW.id::text);
  ELSIF TG_OP = 'DELETE' THEN old_j := to_jsonb(OLD); dets := jsonb_build_object('deleted', old_j - 'updated_at' - 'created_at'); entity_id_val := OLD.id::text;
  ELSIF TG_OP = 'INSERT' THEN new_j := to_jsonb(NEW); dets := jsonb_build_object('created', new_j - 'updated_at' - 'created_at'); entity_id_val := NEW.id::text;
  END IF;
  act_type := upper(ent_type) || '_' || TG_OP;
  IF ent_type IN ('brands', 'categories', 'genders', 'perfume_types', 'concentrations', 'ingredients', 'scents', 'product_labels', 'order_statuses', 'payment_methods') THEN entity_name := coalesce(NEW.name, OLD.name); descrip := format('%s %s: "%s" (ID: %s)', action_verb, CASE ent_type WHEN 'brands' THEN 'thương hiệu' WHEN 'categories' THEN 'danh mục' WHEN 'genders' THEN 'giới tính' WHEN 'perfume_types' THEN 'loại nước hoa' WHEN 'concentrations' THEN 'nồng độ' WHEN 'ingredients' THEN 'thành phần' WHEN 'scents' THEN 'nhóm hương' WHEN 'product_labels' THEN 'nhãn sản phẩm' WHEN 'order_statuses' THEN 'trạng thái đơn hàng' WHEN 'payment_methods' THEN 'phương thức thanh toán' ELSE ent_type END, entity_name, entity_id_val);
  ELSIF ent_type = 'products' THEN entity_name := coalesce(NEW.name, OLD.name); descrip := format('%s sản phẩm: "%s" (ID: %s)', action_verb, entity_name, entity_id_val); IF TG_OP = 'UPDATE' AND OLD.deleted_at IS DISTINCT FROM NEW.deleted_at THEN descrip := descrip || format('. Trạng thái: %s.', CASE WHEN NEW.deleted_at IS NULL THEN 'Đã khôi phục' ELSE 'Đã xóa mềm' END); act_type := 'PRODUCT_' || CASE WHEN NEW.deleted_at IS NULL THEN 'RESTORE' ELSE 'SOFT_DELETE' END; END IF;
  ELSIF ent_type = 'product_variants' THEN descrip := format('%s biến thể sản phẩm (ID: %s, ProductID: %s)', action_verb, entity_id_val, coalesce(NEW.product_id::text, OLD.product_id::text)); IF TG_OP = 'UPDATE' AND OLD.deleted_at IS DISTINCT FROM NEW.deleted_at THEN descrip := descrip || format('. Trạng thái: %s.', CASE WHEN NEW.deleted_at IS NULL THEN 'Đã khôi phục' ELSE 'Đã xóa mềm' END); act_type := 'PRODUCT_VARIANT_' || CASE WHEN NEW.deleted_at IS NULL THEN 'RESTORE' ELSE 'SOFT_DELETE' END; END IF;
  ELSIF ent_type = 'discounts' THEN entity_name := coalesce(NEW.code, OLD.code); descrip := format('%s mã giảm giá: "%s" (ID: %s)', action_verb, entity_name, entity_id_val); IF TG_OP = 'UPDATE' AND OLD.is_active IS DISTINCT FROM NEW.is_active THEN descrip := descrip || format('. Trạng thái hoạt động: %s.', CASE WHEN NEW.is_active THEN 'Kích hoạt' ELSE 'Vô hiệu hóa' END); END IF;
  ELSIF ent_type = 'banners' THEN entity_name := coalesce(NEW.title, OLD.title); descrip := format('%s banner: "%s" (ID: %s)', action_verb, entity_name, entity_id_val); IF TG_OP = 'UPDATE' AND OLD.is_active IS DISTINCT FROM NEW.is_active THEN descrip := descrip || format('. Trạng thái hiển thị: %s.', CASE WHEN NEW.is_active THEN 'Bật' ELSE 'Tắt' END); END IF;
  ELSIF ent_type = 'product_images' THEN descrip := format('%s ảnh (ID: %s) cho sản phẩm ID %s', action_verb, entity_id_val, coalesce(NEW.product_id::text, OLD.product_id::text)); IF TG_OP = 'UPDATE' AND OLD.is_main IS DISTINCT FROM NEW.is_main THEN descrip := descrip || format('. Đặt làm ảnh chính: %s.', NEW.is_main); END IF;
  ELSIF ent_type = 'product_ingredients' THEN descrip := format('%s liên kết Thành phần ID %s (Tầng: %s) vào Sản phẩm ID %s', action_verb, coalesce(NEW.ingredient_id::text, OLD.ingredient_id::text), coalesce(NEW.scent_type, OLD.scent_type), coalesce(NEW.product_id::text, OLD.product_id::text)); act_type := 'PRODUCT_INGREDIENT_LINK_' || TG_OP;
  ELSIF ent_type = 'product_categories' THEN descrip := format('%s liên kết Danh mục ID %s vào Sản phẩm ID %s', action_verb, coalesce(NEW.category_id::text, OLD.category_id::text), coalesce(NEW.product_id::text, OLD.product_id::text)); act_type := 'PRODUCT_CATEGORY_LINK_' || TG_OP;
  ELSIF ent_type = 'product_label_assignments' THEN descrip := format('%s gán Nhãn ID %s cho Sản phẩm ID %s', action_verb, coalesce(NEW.label_id::text, OLD.label_id::text), coalesce(NEW.product_id::text, OLD.product_id::text)); IF TG_OP = 'UPDATE' AND OLD.valid_until IS DISTINCT FROM NEW.valid_until THEN descrip := descrip || format('. Cập nhật hạn sử dụng thành: %s.', NEW.valid_until); END IF; act_type := 'PRODUCT_LABEL_ASSIGNMENT_' || TG_OP;
  ELSIF ent_type = 'orders' AND TG_OP = 'UPDATE' THEN IF OLD.order_status_id IS DISTINCT FROM NEW.order_status_id THEN SELECT name INTO old_status_name FROM public.order_statuses WHERE id = OLD.order_status_id; SELECT name INTO new_status_name FROM public.order_statuses WHERE id = NEW.order_status_id; IF new_status_name = 'Đã hủy' AND NEW.cancelled_by = 'admin' THEN SELECT email INTO affected_user_email FROM auth.users WHERE id = NEW.cancelled_by_user_id; act_type := 'ORDER_CANCELLED_BY_ADMIN'; descrip := format('Đơn hàng #%s: Bị hủy bởi Admin/Staff (%s). Lý do: %s', NEW.id, coalesce(affected_user_email, NEW.cancelled_by_user_id::text), coalesce(NEW.cancellation_reason, 'Không rõ')); dets := dets || jsonb_build_object('cancellation_reason', NEW.cancellation_reason, 'cancelled_by_user_id', NEW.cancelled_by_user_id, 'old_status', old_status_name, 'new_status', new_status_name); ELSE act_type := 'ORDER_STATUS_CHANGE_BY_ADMIN'; descrip := format('Đơn hàng #%s: Trạng thái đổi từ "%s" sang "%s" bởi Admin/Staff (%s).', NEW.id, coalesce(old_status_name,'NULL'), coalesce(new_status_name,'NULL'), admin_user_info); dets := dets || jsonb_build_object('old_status', old_status_name, 'new_status', new_status_name); END IF; ELSIF OLD.assigned_shipper_id IS DISTINCT FROM NEW.assigned_shipper_id THEN SELECT email INTO old_shipper_email FROM auth.users WHERE id = OLD.assigned_shipper_id; SELECT email INTO new_shipper_email FROM auth.users WHERE id = NEW.assigned_shipper_id; act_type := 'ORDER_SHIPPER_ASSIGNMENT'; descrip := format('Đơn hàng #%s: Đổi người giao hàng từ "%s" sang "%s" bởi Admin/Staff (%s).', NEW.id, coalesce(old_shipper_email, OLD.assigned_shipper_id::text, 'Chưa gán'), coalesce(new_shipper_email, NEW.assigned_shipper_id::text, 'Bỏ gán'), admin_user_info); dets := dets || jsonb_build_object('old_shipper_id', OLD.assigned_shipper_id, 'new_shipper_id', NEW.assigned_shipper_id); ELSIF OLD.payment_status IS DISTINCT FROM NEW.payment_status THEN act_type := 'ORDER_PAYMENT_STATUS_UPDATE_BY_ADMIN'; descrip := format('Đơn hàng #%s: Admin/Staff (%s) cập nhật trạng thái thanh toán từ "%s" thành "%s".', NEW.id, admin_user_info, OLD.payment_status, NEW.payment_status); dets := dets || jsonb_build_object('old_payment_status', OLD.payment_status, 'new_payment_status', NEW.payment_status); ELSE act_type := 'ORDER_INFO_UPDATE_BY_ADMIN'; descrip := format('Đơn hàng #%s: Admin/Staff (%s) cập nhật thông tin khác.', NEW.id, admin_user_info); END IF;
  ELSIF ent_type = 'reviews' THEN IF TG_OP = 'UPDATE' THEN IF OLD.is_approved IS DISTINCT FROM NEW.is_approved THEN act_type := 'REVIEW_' || (CASE WHEN NEW.is_approved THEN 'APPROVE' ELSE 'UNAPPROVE' END); descrip := format('%s đánh giá #%s bởi Admin/Staff (%s)', (CASE WHEN NEW.is_approved THEN 'Duyệt' ELSE 'Bỏ duyệt' END), entity_id_val, admin_user_info); ELSE act_type := 'REVIEW_UPDATE_BY_ADMIN'; descrip := format('Cập nhật nội dung đánh giá #%s bởi Admin/Staff (%s)', entity_id_val, admin_user_info); END IF; ELSIF TG_OP = 'DELETE' THEN act_type := 'REVIEW_DELETE'; descrip := format('Xóa đánh giá #%s bởi Admin/Staff (%s)', entity_id_val, admin_user_info); END IF;
  ELSIF ent_type = 'review_replies' THEN descrip := format('%s phản hồi (ID: %s) cho đánh giá #%s bởi Admin/Staff (%s)', action_verb, entity_id_val, coalesce(NEW.review_id, OLD.review_id), admin_user_info);
  ELSIF ent_type = 'shop_settings' AND TG_OP = 'UPDATE' THEN act_type := 'SHOP_SETTINGS_UPDATE'; descrip := format('Cập nhật cài đặt cửa hàng bởi Admin/Staff (%s)', admin_user_info);
  ELSIF ent_type = 'payments' THEN descrip := format('%s giao dịch thanh toán (ID: %s) cho đơn hàng #%s bởi Admin/Staff (%s)', action_verb, entity_id_val, coalesce(NEW.order_id::text, OLD.order_id::text), admin_user_info);
  ELSIF ent_type = 'profiles' THEN SELECT email INTO affected_user_email FROM auth.users WHERE id = coalesce(OLD.id, NEW.id); descrip := format('%s hồ sơ người dùng "%s" (ID: %s) bởi Admin/Staff (%s)', action_verb, coalesce(affected_user_email, coalesce(OLD.id::text, NEW.id::text)), entity_id_val, admin_user_info);
  ELSIF ent_type = 'addresses' THEN SELECT email INTO affected_user_email FROM auth.users WHERE id = coalesce(OLD.user_id, NEW.user_id); descrip := format('%s địa chỉ (ID: %s) của người dùng "%s" bởi Admin/Staff (%s)', action_verb, entity_id_val, coalesce(affected_user_email, coalesce(OLD.user_id::text, NEW.user_id::text)), admin_user_info);
  ELSE entity_name := coalesce(CASE WHEN TG_OP != 'DELETE' THEN (to_jsonb(NEW)->>'name')::text ELSE NULL END, CASE WHEN TG_OP != 'INSERT' THEN (to_jsonb(OLD)->>'name')::text ELSE NULL END, entity_id_val); descrip := format('%s bản ghi trong bảng "%s" ("%s") bởi Admin/Staff (%s)', action_verb, ent_type, entity_name, admin_user_info);
  END IF;
  IF act_type IS NOT NULL AND descrip IS NOT NULL THEN INSERT INTO public.admin_activity_log (admin_user_id, activity_type, description, entity_type, entity_id, details) VALUES (auth.uid(), act_type, descrip, ent_type, entity_id_val, dets); END IF;
  RETURN NULL; -- Trigger AFTER không cần trả về bản ghi
END; $$;
comment on function public.log_admin_activity() is '[V3.2] Tự động ghi lại các hành động INSERT, UPDATE, DELETE quan trọng do Admin/Staff thực hiện.';

-- TRIGGERS: Gọi hàm log_admin_activity (Sử dụng DROP IF EXISTS)
DROP TRIGGER IF EXISTS trigger_log_admin_activity_brands ON public.brands; CREATE TRIGGER trigger_log_admin_activity_brands AFTER INSERT OR UPDATE OR DELETE ON public.brands FOR EACH ROW EXECUTE PROCEDURE public.log_admin_activity();
DROP TRIGGER IF EXISTS trigger_log_admin_activity_categories ON public.categories; CREATE TRIGGER trigger_log_admin_activity_categories AFTER INSERT OR UPDATE OR DELETE ON public.categories FOR EACH ROW EXECUTE PROCEDURE public.log_admin_activity();
DROP TRIGGER IF EXISTS trigger_log_admin_activity_genders ON public.genders; CREATE TRIGGER trigger_log_admin_activity_genders AFTER INSERT OR UPDATE OR DELETE ON public.genders FOR EACH ROW EXECUTE PROCEDURE public.log_admin_activity();
DROP TRIGGER IF EXISTS trigger_log_admin_activity_perfume_types ON public.perfume_types; CREATE TRIGGER trigger_log_admin_activity_perfume_types AFTER INSERT OR UPDATE OR DELETE ON public.perfume_types FOR EACH ROW EXECUTE PROCEDURE public.log_admin_activity();
DROP TRIGGER IF EXISTS trigger_log_admin_activity_concentrations ON public.concentrations; CREATE TRIGGER trigger_log_admin_activity_concentrations AFTER INSERT OR UPDATE OR DELETE ON public.concentrations FOR EACH ROW EXECUTE PROCEDURE public.log_admin_activity();
DROP TRIGGER IF EXISTS trigger_log_admin_activity_ingredients ON public.ingredients; CREATE TRIGGER trigger_log_admin_activity_ingredients AFTER INSERT OR UPDATE OR DELETE ON public.ingredients FOR EACH ROW EXECUTE PROCEDURE public.log_admin_activity();
DROP TRIGGER IF EXISTS trigger_log_admin_activity_scents ON public.scents; CREATE TRIGGER trigger_log_admin_activity_scents AFTER INSERT OR UPDATE OR DELETE ON public.scents FOR EACH ROW EXECUTE PROCEDURE public.log_admin_activity();
DROP TRIGGER IF EXISTS trigger_log_admin_activity_product_labels ON public.product_labels; CREATE TRIGGER trigger_log_admin_activity_product_labels AFTER INSERT OR UPDATE OR DELETE ON public.product_labels FOR EACH ROW EXECUTE PROCEDURE public.log_admin_activity();
DROP TRIGGER IF EXISTS trigger_log_admin_activity_order_statuses ON public.order_statuses; CREATE TRIGGER trigger_log_admin_activity_order_statuses AFTER INSERT OR UPDATE OR DELETE ON public.order_statuses FOR EACH ROW EXECUTE PROCEDURE public.log_admin_activity();
DROP TRIGGER IF EXISTS trigger_log_admin_activity_payment_methods ON public.payment_methods; CREATE TRIGGER trigger_log_admin_activity_payment_methods AFTER INSERT OR UPDATE OR DELETE ON public.payment_methods FOR EACH ROW EXECUTE PROCEDURE public.log_admin_activity();
DROP TRIGGER IF EXISTS trigger_log_admin_activity_shop_settings ON public.shop_settings; CREATE TRIGGER trigger_log_admin_activity_shop_settings AFTER UPDATE ON public.shop_settings FOR EACH ROW EXECUTE PROCEDURE public.log_admin_activity();
DROP TRIGGER IF EXISTS trigger_log_admin_activity_banners ON public.banners; CREATE TRIGGER trigger_log_admin_activity_banners AFTER INSERT OR UPDATE OR DELETE ON public.banners FOR EACH ROW EXECUTE PROCEDURE public.log_admin_activity();
DROP TRIGGER IF EXISTS trigger_log_admin_activity_products ON public.products; CREATE TRIGGER trigger_log_admin_activity_products AFTER INSERT OR UPDATE OR DELETE ON public.products FOR EACH ROW EXECUTE PROCEDURE public.log_admin_activity();
DROP TRIGGER IF EXISTS trigger_log_admin_activity_product_variants ON public.product_variants; CREATE TRIGGER trigger_log_admin_activity_product_variants AFTER INSERT OR UPDATE OR DELETE ON public.product_variants FOR EACH ROW EXECUTE PROCEDURE public.log_admin_activity();
DROP TRIGGER IF EXISTS trigger_log_admin_activity_product_images ON public.product_images; CREATE TRIGGER trigger_log_admin_activity_product_images AFTER INSERT OR UPDATE OR DELETE ON public.product_images FOR EACH ROW EXECUTE PROCEDURE public.log_admin_activity();
DROP TRIGGER IF EXISTS trigger_log_admin_activity_product_ingredients ON public.product_ingredients; CREATE TRIGGER trigger_log_admin_activity_product_ingredients AFTER INSERT OR DELETE ON public.product_ingredients FOR EACH ROW EXECUTE PROCEDURE public.log_admin_activity();
DROP TRIGGER IF EXISTS trigger_log_admin_activity_product_categories ON public.product_categories; CREATE TRIGGER trigger_log_admin_activity_product_categories AFTER INSERT OR DELETE ON public.product_categories FOR EACH ROW EXECUTE PROCEDURE public.log_admin_activity();
DROP TRIGGER IF EXISTS trigger_log_admin_activity_product_label_assignments ON public.product_label_assignments; CREATE TRIGGER trigger_log_admin_activity_product_label_assignments AFTER INSERT OR UPDATE OR DELETE ON public.product_label_assignments FOR EACH ROW EXECUTE PROCEDURE public.log_admin_activity();
DROP TRIGGER IF EXISTS trigger_log_admin_activity_orders ON public.orders; CREATE TRIGGER trigger_log_admin_activity_orders AFTER UPDATE ON public.orders FOR EACH ROW EXECUTE PROCEDURE public.log_admin_activity();
DROP TRIGGER IF EXISTS trigger_log_admin_activity_payments ON public.payments; CREATE TRIGGER trigger_log_admin_activity_payments AFTER INSERT OR UPDATE OR DELETE ON public.payments FOR EACH ROW EXECUTE PROCEDURE public.log_admin_activity();
DROP TRIGGER IF EXISTS trigger_log_admin_activity_discounts ON public.discounts; CREATE TRIGGER trigger_log_admin_activity_discounts AFTER INSERT OR UPDATE OR DELETE ON public.discounts FOR EACH ROW EXECUTE PROCEDURE public.log_admin_activity();
DROP TRIGGER IF EXISTS trigger_log_admin_activity_reviews ON public.reviews; CREATE TRIGGER trigger_log_admin_activity_reviews AFTER UPDATE OR DELETE ON public.reviews FOR EACH ROW EXECUTE PROCEDURE public.log_admin_activity();
DROP TRIGGER IF EXISTS trigger_log_admin_activity_review_replies ON public.review_replies; CREATE TRIGGER trigger_log_admin_activity_review_replies AFTER INSERT OR UPDATE OR DELETE ON public.review_replies FOR EACH ROW EXECUTE PROCEDURE public.log_admin_activity();
DROP TRIGGER IF EXISTS trigger_log_admin_activity_profiles ON public.profiles; CREATE TRIGGER trigger_log_admin_activity_profiles AFTER UPDATE ON public.profiles FOR EACH ROW EXECUTE PROCEDURE public.log_admin_activity();
DROP TRIGGER IF EXISTS trigger_log_admin_activity_addresses ON public.addresses; CREATE TRIGGER trigger_log_admin_activity_addresses AFTER INSERT OR UPDATE OR DELETE ON public.addresses FOR EACH ROW EXECUTE PROCEDURE public.log_admin_activity();
DROP TRIGGER IF EXISTS trigger_log_admin_activity_product_scents ON public.product_scents; CREATE TRIGGER trigger_log_admin_activity_product_scents AFTER INSERT OR UPDATE OR DELETE ON public.product_scents FOR EACH ROW EXECUTE PROCEDURE public.log_admin_activity();

-- FUNCTION: Đảm bảo chỉ có 1 ảnh chính
-- DROP FUNCTION IF EXISTS public.enforce_single_main_image();
CREATE OR REPLACE FUNCTION public.enforce_single_main_image()
RETURNS TRIGGER LANGUAGE plpgsql SECURITY DEFINER SET search_path = public AS $$
BEGIN
  IF NEW.is_main = true THEN
    UPDATE public.product_images SET is_main = false
    WHERE product_id = NEW.product_id AND id != NEW.id AND is_main = true;
  END IF;
  RETURN NEW;
END;
$$;
comment on function public.enforce_single_main_image() is '[V3.2] Đảm bảo chỉ có 1 ảnh is_main=true cho mỗi sản phẩm.';

-- TRIGGER: Gọi hàm enforce_single_main_image
DROP TRIGGER IF EXISTS trigger_enforce_single_main_image ON public.product_images;
CREATE TRIGGER trigger_enforce_single_main_image
BEFORE INSERT OR UPDATE OF is_main ON public.product_images
FOR EACH ROW EXECUTE PROCEDURE public.enforce_single_main_image();

-- [V3.2 FTS] FUNCTION: Cập nhật cột fts cho products
-- DROP FUNCTION IF EXISTS public.update_product_fts();
CREATE OR REPLACE FUNCTION public.update_product_fts()
RETURNS TRIGGER LANGUAGE plpgsql SECURITY DEFINER SET search_path = public AS $$
BEGIN
    -- Sử dụng 'simple' config để phù hợp với nhiều ngôn ngữ hơn, bao gồm tiếng Việt không dấu
    -- Gán trọng số: A (cao nhất) cho tên, B cho mô tả ngắn, C cho mô tả dài
    NEW.fts := setweight(to_tsvector('simple', coalesce(unaccent(NEW.name),'')), 'A') ||
               setweight(to_tsvector('simple', coalesce(unaccent(NEW.short_description),'')), 'B') ||
               setweight(to_tsvector('simple', coalesce(unaccent(NEW.long_description),'')), 'C');
    RETURN NEW;
END;
$$;
COMMENT ON FUNCTION public.update_product_fts() IS '[V3.2 FTS] Trigger function to update the products.fts column on insert/update using unaccent.';

-- [V3.2 FTS] TRIGGER: Gọi hàm update_product_fts
DROP TRIGGER IF EXISTS trigger_update_product_fts ON public.products;
CREATE TRIGGER trigger_update_product_fts
BEFORE INSERT OR UPDATE OF name, short_description, long_description ON public.products
FOR EACH ROW EXECUTE PROCEDURE public.update_product_fts();

-- ============================================================================
-- SECTION: RPC FUNCTIONS (Remote Procedure Call) V3.2
-- Định nghĩa các hàm có thể được gọi từ bên ngoài.
-- Luôn kiểm tra quyền bên trong hàm hoặc sử dụng SECURITY INVOKER nếu RLS đủ.
-- ============================================================================

-- RPC: Admin/Staff duyệt đánh giá
-- DROP FUNCTION IF EXISTS public.approve_review(bigint);
CREATE OR REPLACE FUNCTION public.approve_review(p_review_id bigint)
RETURNS void LANGUAGE plpgsql SECURITY DEFINER SET search_path = public AS $$
BEGIN
  IF NOT public.is_staff() THEN RAISE EXCEPTION 'AUTH_REQUIRED: Chỉ Staff/Admin mới có quyền duyệt đánh giá.'; END IF;
  UPDATE public.reviews SET is_approved = true, approved_by = auth.uid(), approved_at = now()
  WHERE id = p_review_id AND is_approved = false;
END; $$;
comment on function public.approve_review(bigint) is '[V3.2] RPC cho Admin/Staff duyệt một đánh giá sản phẩm.';
GRANT EXECUTE ON FUNCTION public.approve_review(bigint) TO authenticated; -- Cấp quyền cho người dùng đã đăng nhập (Staff/Admin là authenticated)

-- RPC: Admin/Staff phản hồi đánh giá
-- DROP FUNCTION IF EXISTS public.reply_to_review(bigint, text);
CREATE OR REPLACE FUNCTION public.reply_to_review(p_review_id bigint, p_reply_text text)
RETURNS bigint LANGUAGE plpgsql SECURITY DEFINER SET search_path = public AS $$
DECLARE new_reply_id bigint;
BEGIN
  IF NOT public.is_staff() THEN RAISE EXCEPTION 'AUTH_REQUIRED: Chỉ Staff/Admin mới có quyền trả lời đánh giá.'; END IF;
  IF p_reply_text IS NULL OR trim(p_reply_text) = '' THEN RAISE EXCEPTION 'VALIDATION_ERROR: Nội dung trả lời không được để trống.'; END IF;
  IF NOT EXISTS (SELECT 1 FROM public.reviews WHERE id = p_review_id) THEN RAISE EXCEPTION 'NOT_FOUND: Đánh giá không tồn tại.'; END IF;
  INSERT INTO public.review_replies (review_id, staff_id, reply_text)
  VALUES (p_review_id, auth.uid(), p_reply_text) RETURNING id INTO new_reply_id;
  RETURN new_reply_id;
END; $$;
comment on function public.reply_to_review(bigint, text) is '[V3.2] RPC cho Admin/Staff thêm phản hồi đánh giá. Trả về ID phản hồi mới.';
GRANT EXECUTE ON FUNCTION public.reply_to_review(bigint, text) TO authenticated;

-- RPC: Lấy danh sách sản phẩm bán chạy nhất
-- DROP FUNCTION IF EXISTS public.get_best_selling_products(integer);
CREATE OR REPLACE FUNCTION public.get_best_selling_products(p_limit integer DEFAULT 10)
RETURNS TABLE (product_id bigint, product_name text, product_slug text, brand_name text, image_url text, total_sold bigint)
LANGUAGE plpgsql STABLE SECURITY DEFINER SET search_path = public AS $$
DECLARE completed_status_ids smallint[];
BEGIN
  SELECT array_agg(id) INTO completed_status_ids FROM public.order_statuses WHERE name IN ('Đã giao', 'Đã hoàn thành');
  RETURN QUERY
    SELECT p.id, p.name, p.slug, b.name as brand_name, (SELECT pi.image_url FROM public.product_images pi WHERE pi.product_id = p.id AND pi.is_main = true ORDER BY pi.display_order, pi.id LIMIT 1) as image_url, SUM(oi.quantity)::bigint as total_sold
    FROM public.products p
    JOIN public.product_variants pv ON p.id = pv.product_id
    JOIN public.order_items oi ON pv.id = oi.variant_id
    JOIN public.orders o ON oi.order_id = o.id
    LEFT JOIN public.brands b ON p.brand_id = b.id
    WHERE p.deleted_at IS NULL AND pv.deleted_at IS NULL AND o.order_status_id = ANY(completed_status_ids)
    GROUP BY p.id, b.name ORDER BY total_sold DESC LIMIT p_limit;
END; $$;
comment on function public.get_best_selling_products(integer) is '[V3.2] RPC lấy danh sách sản phẩm bán chạy nhất.';
GRANT EXECUTE ON FUNCTION public.get_best_selling_products(integer) TO anon, authenticated; -- Mọi người đều có thể xem

-- RPC: Lấy báo cáo doanh thu theo tháng (Admin)
-- DROP FUNCTION IF EXISTS public.get_monthly_revenue(date, date);
CREATE OR REPLACE FUNCTION public.get_monthly_revenue(p_start_date date, p_end_date date)
RETURNS TABLE (report_month text, total_revenue numeric, order_count bigint)
LANGUAGE plpgsql STABLE SECURITY DEFINER SET search_path = public AS $$
DECLARE completed_status_ids smallint[];
BEGIN
  IF NOT public.is_admin() THEN RAISE EXCEPTION 'AUTH_REQUIRED: Chỉ Admin mới có quyền xem báo cáo doanh thu.'; END IF;
  SELECT array_agg(id) INTO completed_status_ids FROM public.order_statuses WHERE name IN ('Đã giao', 'Đã hoàn thành');
  RETURN QUERY
    SELECT to_char(date_trunc('month', o.order_date), 'YYYY-MM') as report_month, SUM(o.total_amount) as total_revenue, COUNT(o.id) as order_count
    FROM public.orders o WHERE o.order_status_id = ANY(completed_status_ids) AND o.order_date >= date_trunc('month', p_start_date) AND o.order_date < date_trunc('month', p_end_date) + interval '1 month'
    GROUP BY date_trunc('month', o.order_date) ORDER BY 1;
END; $$;
comment on function public.get_monthly_revenue(date, date) is '[V3.2] RPC tính doanh thu và số đơn theo tháng. Chỉ dành cho Admin.';
GRANT EXECUTE ON FUNCTION public.get_monthly_revenue(date, date) TO authenticated;

-- RPC: Lấy báo cáo sản phẩm bán chạy (Admin)
-- DROP FUNCTION IF EXISTS public.get_top_selling_products_report(integer, date, date);
CREATE OR REPLACE FUNCTION public.get_top_selling_products_report(p_limit integer DEFAULT 20, p_start_date date DEFAULT date_trunc('month', now()), p_end_date date DEFAULT now())
RETURNS TABLE (product_id bigint, product_name text, product_code text, brand_name text, total_quantity_sold bigint, total_revenue_generated numeric)
LANGUAGE plpgsql STABLE SECURITY DEFINER SET search_path = public AS $$
DECLARE completed_status_ids smallint[];
BEGIN
  IF NOT public.is_admin() THEN RAISE EXCEPTION 'AUTH_REQUIRED: Chỉ Admin mới có quyền xem báo cáo sản phẩm.'; END IF;
  SELECT array_agg(id) INTO completed_status_ids FROM public.order_statuses WHERE name IN ('Đã giao', 'Đã hoàn thành');
  RETURN QUERY
    SELECT p.id as product_id, p.name as product_name, p.product_code, b.name as brand_name, SUM(oi.quantity)::bigint as total_quantity_sold, SUM(oi.quantity * oi.unit_price_at_order) as total_revenue_generated
    FROM public.products p
    JOIN public.product_variants pv ON p.id = pv.product_id
    JOIN public.order_items oi ON pv.id = oi.variant_id
    JOIN public.orders o ON oi.order_id = o.id
    LEFT JOIN public.brands b ON p.brand_id = b.id
    WHERE p.deleted_at IS NULL AND pv.deleted_at IS NULL AND o.order_status_id = ANY(completed_status_ids) AND o.order_date >= p_start_date AND o.order_date < p_end_date + interval '1 day'
    GROUP BY p.id, b.name ORDER BY total_quantity_sold DESC LIMIT p_limit;
END; $$;
comment on function public.get_top_selling_products_report(integer, date, date) is '[V3.2] RPC lấy báo cáo chi tiết sản phẩm bán chạy. Chỉ dành cho Admin.';
GRANT EXECUTE ON FUNCTION public.get_top_selling_products_report(integer, date, date) TO authenticated;

-- RPC: Lấy các tùy chọn lọc cho PLP
-- DROP FUNCTION IF EXISTS public.get_plp_filter_options();
CREATE OR REPLACE FUNCTION public.get_plp_filter_options()
RETURNS jsonb -- Sử dụng jsonb để hiệu quả hơn
LANGUAGE plpgsql STABLE SECURITY INVOKER SET search_path = public AS $$
-- SECURITY INVOKER: Chạy với quyền của người gọi, RLS sẽ tự động áp dụng nếu cần lọc theo quyền.
-- STABLE: Hàm không thay đổi dữ liệu và trả về kết quả giống nhau với cùng input trong 1 transaction.
BEGIN
  RETURN jsonb_build_object(
    'brands', (SELECT coalesce(jsonb_agg(jsonb_build_object('id', id, 'name', name) ORDER BY name), '[]'::jsonb) FROM public.brands),
    'categories', (SELECT coalesce(jsonb_agg(jsonb_build_object('id', id, 'name', name, 'slug', slug, 'parent_category_id', parent_category_id, 'image_url', image_url) ORDER BY display_order, name), '[]'::jsonb) FROM public.categories),
    'genders', (SELECT coalesce(jsonb_agg(jsonb_build_object('id', id, 'name', name) ORDER BY id), '[]'::jsonb) FROM public.genders),
    'perfumeTypes', (SELECT coalesce(jsonb_agg(jsonb_build_object('id', id, 'name', name) ORDER BY id), '[]'::jsonb) FROM public.perfume_types),
    'concentrations', (SELECT coalesce(jsonb_agg(jsonb_build_object('id', id, 'name', name) ORDER BY id), '[]'::jsonb) FROM public.concentrations),
    'ingredients', (SELECT coalesce(jsonb_agg(jsonb_build_object('id', id, 'name', name) ORDER BY name), '[]'::jsonb) FROM public.ingredients),
    'volumes', (SELECT coalesce(jsonb_agg(DISTINCT volume_ml ORDER BY volume_ml), '[]'::jsonb) FROM public.product_variants WHERE deleted_at IS NULL),
    'priceRanges', jsonb_build_array( -- Định nghĩa sẵn các khoảng giá
        jsonb_build_object('min', 0, 'max', 1000000, 'label', 'Dưới 1 triệu'),
        jsonb_build_object('min', 1000000, 'max', 2000000, 'label', '1 - 2 triệu'),
        jsonb_build_object('min', 2000000, 'max', 5000000, 'label', '2 - 5 triệu'),
        jsonb_build_object('min', 5000000, 'max', 10000000, 'label', '5 - 10 triệu'),
        jsonb_build_object('min', 10000000, 'max', null, 'label', 'Trên 10 triệu') -- Dùng null cho max để biểu thị "trở lên"
      )
  );
END; $$;
comment on function public.get_plp_filter_options() is '[V3.2] RPC lấy danh sách các tùy chọn (brands, categories, genders, ingredients, volumes, price ranges...) cho bộ lọc PLP.';
GRANT EXECUTE ON FUNCTION public.get_plp_filter_options() TO anon, authenticated;

-- RPC: Lấy chi tiết đơn hàng bằng token (Guest)
-- DROP FUNCTION IF EXISTS public.get_order_details_by_token(uuid);
CREATE OR REPLACE FUNCTION public.get_order_details_by_token(p_token uuid)
RETURNS jsonb -- Sử dụng jsonb
LANGUAGE plpgsql STABLE SECURITY DEFINER SET search_path = public AS $$
DECLARE order_details jsonb;
BEGIN
  SELECT jsonb_strip_nulls(jsonb_build_object( 'order', to_jsonb(o_filtered.*), 'items', (SELECT coalesce(jsonb_agg(oi_filtered.*), '[]'::jsonb) FROM (SELECT oi.id, oi.product_name, oi.variant_volume_ml, oi.quantity, oi.unit_price_at_order, pv.sku, p.slug as product_slug, (SELECT pi.image_url FROM public.product_images pi WHERE pi.product_id = p.id AND pi.is_main = true ORDER BY pi.display_order, pi.id LIMIT 1) as image_url FROM public.order_items oi JOIN public.product_variants pv ON oi.variant_id = pv.id JOIN public.products p ON pv.product_id = p.id WHERE oi.order_id = o_filtered.id ) as oi_filtered ), 'status_name', (SELECT os.name FROM public.order_statuses os WHERE os.id = o_filtered.order_status_id), 'payment_method_name', (SELECT pm.name FROM public.payment_methods pm WHERE pm.id = o_filtered.payment_method_id), 'cancelled_by_details', CASE WHEN o_filtered.cancelled_by = 'user' THEN jsonb_build_object('type', 'user', 'reason', o_filtered.cancellation_reason) WHEN o_filtered.cancelled_by = 'admin' THEN jsonb_build_object('type', 'admin', 'reason', o_filtered.cancellation_reason) ELSE null END, 'delivery_failure_details', CASE WHEN o_filtered.delivery_failure_reason IS NOT NULL THEN jsonb_build_object('reason', o_filtered.delivery_failure_reason, 'timestamp', o_filtered.delivery_failure_timestamp) ELSE null END )) INTO order_details
  FROM ( SELECT o.id, o.access_token, o.guest_name, o.guest_email, o.guest_phone, o.recipient_name, o.recipient_phone, o.province_city, o.district, o.ward, o.street_address, o.order_date, o.delivery_notes, o.payment_method_id, o.payment_status, o.order_status_id, o.subtotal_amount, o.discount_amount, o.shipping_fee, o.total_amount, o.cancellation_reason, o.cancelled_by, o.completed_at, o.delivery_failure_reason, o.delivery_failure_timestamp FROM public.orders o WHERE o.access_token = p_token ) as o_filtered;
  IF order_details IS NULL THEN RAISE EXCEPTION 'ORDER_NOT_FOUND: Không tìm thấy đơn hàng với mã tra cứu này.'; END IF;
  RETURN order_details;
END; $$;
comment on function public.get_order_details_by_token(uuid) is '[V3.2] RPC cho khách vãng lai xem chi tiết đơn hàng bằng access_token.';
GRANT EXECUTE ON FUNCTION public.get_order_details_by_token(uuid) TO anon, authenticated; -- Allow anyone with token

-- RPC: User tự hủy đơn
-- DROP FUNCTION IF EXISTS public.cancel_order_by_user(bigint, text);
CREATE OR REPLACE FUNCTION public.cancel_order_by_user(p_order_id bigint, p_reason text)
RETURNS void LANGUAGE plpgsql SECURITY DEFINER SET search_path = public AS $$
DECLARE target_order public.orders%rowtype; current_status_name text; cancelled_status_id smallint; allowed_cancel_statuses text[] := ARRAY['Chờ xác nhận', 'Đã xác nhận']; cod_method_id smallint;
BEGIN
  IF auth.uid() IS NULL THEN RAISE EXCEPTION 'AUTH_REQUIRED: Bạn cần đăng nhập.'; END IF;
  IF p_reason IS NULL OR trim(p_reason) = '' THEN RAISE EXCEPTION 'VALIDATION_ERROR: Vui lòng cung cấp lý do hủy đơn.'; END IF;
  SELECT * INTO target_order FROM public.orders WHERE id = p_order_id AND user_id = auth.uid();
  IF target_order IS NULL THEN RAISE EXCEPTION 'NOT_FOUND: Không tìm thấy đơn hàng hoặc bạn không có quyền.'; END IF;
  SELECT name INTO current_status_name FROM public.order_statuses WHERE id = target_order.order_status_id;
  SELECT id INTO cancelled_status_id FROM public.order_statuses WHERE name = 'Đã hủy';
  SELECT id INTO cod_method_id FROM public.payment_methods WHERE name = 'COD';
  IF current_status_name = 'Đã hủy' THEN RAISE NOTICE 'Đơn hàng đã được hủy trước đó.'; RETURN; END IF;
  IF NOT (current_status_name = ANY(allowed_cancel_statuses)) THEN RAISE EXCEPTION 'ACTION_NOT_ALLOWED: Bạn chỉ có thể hủy đơn hàng khi ở trạng thái %.', array_to_string(allowed_cancel_statuses, ' hoặc '); END IF;
  IF target_order.payment_status = 'Paid' AND target_order.payment_method_id != cod_method_id THEN RAISE EXCEPTION 'ACTION_NOT_ALLOWED: Không thể hủy đơn hàng đã thanh toán online. Vui lòng liên hệ hỗ trợ.'; END IF;
  UPDATE public.orders SET order_status_id = cancelled_status_id, cancellation_reason = p_reason, cancelled_by = 'user', cancelled_by_user_id = auth.uid() WHERE id = p_order_id;
END; $$;
comment on function public.cancel_order_by_user(bigint, text) is '[V3.2] RPC cho người dùng đăng nhập tự hủy đơn hàng của họ.';
GRANT EXECUTE ON FUNCTION public.cancel_order_by_user(bigint, text) TO authenticated;

-- RPC: Admin/Staff hủy đơn
-- DROP FUNCTION IF EXISTS public.cancel_order_by_admin(bigint, text);
CREATE OR REPLACE FUNCTION public.cancel_order_by_admin(p_order_id bigint, p_reason text)
RETURNS void LANGUAGE plpgsql SECURITY DEFINER SET search_path = public AS $$
DECLARE target_order public.orders%rowtype; current_status_name text; cancelled_status_id smallint; cod_method_id smallint;
BEGIN
  IF NOT public.is_staff() THEN RAISE EXCEPTION 'AUTH_REQUIRED: Chỉ Admin/Staff mới có quyền hủy đơn hàng.'; END IF;
  IF p_reason IS NULL OR trim(p_reason) = '' THEN RAISE EXCEPTION 'VALIDATION_ERROR: Vui lòng cung cấp lý do hủy đơn.'; END IF;
  SELECT * INTO target_order FROM public.orders WHERE id = p_order_id;
  IF target_order IS NULL THEN RAISE EXCEPTION 'NOT_FOUND: Không tìm thấy đơn hàng.'; END IF;
  SELECT name INTO current_status_name FROM public.order_statuses WHERE id = target_order.order_status_id;
  SELECT id INTO cancelled_status_id FROM public.order_statuses WHERE name = 'Đã hủy';
  SELECT id INTO cod_method_id FROM public.payment_methods WHERE name = 'COD';
  IF current_status_name = 'Đã hủy' THEN RAISE NOTICE 'Đơn hàng này đã được hủy trước đó.'; RETURN; END IF;
  -- Consider business rules for paid/completed orders here
  UPDATE public.orders SET order_status_id = cancelled_status_id, cancellation_reason = p_reason, cancelled_by = 'admin', cancelled_by_user_id = auth.uid() WHERE id = p_order_id;
END; $$;
comment on function public.cancel_order_by_admin(bigint, text) is '[V3.2] RPC cho Admin/Staff hủy một đơn hàng.';
GRANT EXECUTE ON FUNCTION public.cancel_order_by_admin(bigint, text) TO authenticated;

-- RPC: Shipper cập nhật trạng thái đơn hàng
-- DROP FUNCTION IF EXISTS public.update_order_status_by_shipper(bigint, text);
CREATE OR REPLACE FUNCTION public.update_order_status_by_shipper(p_order_id bigint, p_new_status_name text)
RETURNS void LANGUAGE plpgsql SECURITY DEFINER SET search_path = public AS $$
DECLARE target_order public.orders%rowtype; current_status_id smallint; current_status_name text; new_status_id smallint; allowed_transitions jsonb := '{"Đã xác nhận": ["Đang xử lý", "Đang giao"], "Đang xử lý": ["Đang giao"], "Đang giao": ["Đã giao"]}'::jsonb; allowed_target_statuses text[];
BEGIN
  IF NOT public.is_shipper() THEN RAISE EXCEPTION 'AUTH_REQUIRED: Chỉ người giao hàng mới có quyền.'; END IF;
  SELECT * INTO target_order FROM public.orders WHERE id = p_order_id AND assigned_shipper_id = auth.uid();
  IF target_order IS NULL THEN RAISE EXCEPTION 'ACTION_NOT_ALLOWED: Bạn không được gán cho đơn hàng này hoặc đơn hàng không tồn tại.'; END IF;
  SELECT id, name INTO current_status_id, current_status_name FROM public.order_statuses WHERE id = target_order.order_status_id;
  SELECT id INTO new_status_id FROM public.order_statuses WHERE name = p_new_status_name;
  IF new_status_id IS NULL THEN RAISE EXCEPTION 'VALIDATION_ERROR: Trạng thái mới không hợp lệ "%".', p_new_status_name; END IF;
  IF current_status_id = new_status_id THEN RETURN; END IF;
  allowed_target_statuses := ARRAY(SELECT jsonb_array_elements_text(allowed_transitions->current_status_name));
  IF allowed_target_statuses IS NULL OR NOT (p_new_status_name = ANY(allowed_target_statuses)) THEN RAISE EXCEPTION 'ACTION_NOT_ALLOWED: Shipper không thể chuyển trạng thái từ "%" sang "%".', current_status_name, p_new_status_name; END IF;
  IF current_status_name IN ('Đã giao', 'Đã hoàn thành', 'Đã hủy') THEN RAISE EXCEPTION 'ACTION_NOT_ALLOWED: Không thể thay đổi trạng thái đơn hàng "%".', current_status_name; END IF;
  UPDATE public.orders SET order_status_id = new_status_id WHERE id = p_order_id;
END; $$;
comment on function public.update_order_status_by_shipper(bigint, text) is '[V3.2] RPC cho Shipper cập nhật trạng thái đơn hàng được gán.';
GRANT EXECUTE ON FUNCTION public.update_order_status_by_shipper(bigint, text) TO authenticated;

-- RPC: Shipper xác nhận thu tiền COD
-- DROP FUNCTION IF EXISTS public.confirm_cod_payment_by_shipper(bigint);
CREATE OR REPLACE FUNCTION public.confirm_cod_payment_by_shipper(p_order_id bigint)
RETURNS void LANGUAGE plpgsql SECURITY DEFINER SET search_path = public AS $$
DECLARE target_order public.orders%rowtype; cod_method_id smallint; delivered_status_id smallint;
BEGIN
  IF NOT public.is_shipper() THEN RAISE EXCEPTION 'AUTH_REQUIRED: Chỉ người giao hàng mới có quyền.'; END IF;
  SELECT * INTO target_order FROM public.orders WHERE id = p_order_id AND assigned_shipper_id = auth.uid();
  IF target_order IS NULL THEN RAISE EXCEPTION 'ACTION_NOT_ALLOWED: Bạn không được gán cho đơn hàng này hoặc đơn hàng không tồn tại.'; END IF;
  SELECT id INTO cod_method_id FROM public.payment_methods WHERE name = 'COD';
  IF target_order.payment_method_id != cod_method_id THEN RAISE EXCEPTION 'ACTION_NOT_ALLOWED: Đơn hàng này không phải là đơn COD.'; END IF;
  SELECT id INTO delivered_status_id FROM public.order_statuses WHERE name = 'Đã giao';
  IF target_order.order_status_id != delivered_status_id THEN RAISE EXCEPTION 'ACTION_NOT_ALLOWED: Chỉ xác nhận thu tiền cho đơn "Đã giao".'; END IF;
  IF target_order.payment_status = 'Paid' THEN RAISE NOTICE 'Đơn hàng #% đã được xác nhận thanh toán COD.', p_order_id; RETURN; END IF;
  UPDATE public.orders SET payment_status = 'Paid' WHERE id = p_order_id;
END; $$;
comment on function public.confirm_cod_payment_by_shipper(bigint) is '[V3.2] RPC cho Shipper xác nhận đã thu tiền COD cho đơn đã giao.';
GRANT EXECUTE ON FUNCTION public.confirm_cod_payment_by_shipper(bigint) TO authenticated;

-- RPC: Shipper ghi nhận giao hàng thất bại
-- DROP FUNCTION IF EXISTS public.record_delivery_failure_by_shipper(bigint, text);
CREATE OR REPLACE FUNCTION public.record_delivery_failure_by_shipper(p_order_id bigint, p_reason text)
RETURNS void LANGUAGE plpgsql SECURITY DEFINER SET search_path = public AS $$
DECLARE target_order public.orders%rowtype; delivering_status_id smallint;
BEGIN
  IF NOT public.is_shipper() THEN RAISE EXCEPTION 'AUTH_REQUIRED: Chỉ người giao hàng mới có quyền.'; END IF;
  IF p_reason IS NULL OR trim(p_reason) = '' THEN RAISE EXCEPTION 'VALIDATION_ERROR: Vui lòng cung cấp lý do thất bại.'; END IF;
  SELECT * INTO target_order FROM public.orders WHERE id = p_order_id AND assigned_shipper_id = auth.uid();
  IF target_order IS NULL THEN RAISE EXCEPTION 'ACTION_NOT_ALLOWED: Bạn không được gán cho đơn hàng này hoặc đơn hàng không tồn tại.'; END IF;
  SELECT id INTO delivering_status_id FROM public.order_statuses WHERE name = 'Đang giao';
  IF target_order.order_status_id != delivering_status_id THEN RAISE EXCEPTION 'ACTION_NOT_ALLOWED: Chỉ ghi nhận thất bại cho đơn "Đang giao".'; END IF;
  UPDATE public.orders SET delivery_failure_reason = p_reason, delivery_failure_timestamp = now() WHERE id = p_order_id;
END; $$;
comment on function public.record_delivery_failure_by_shipper(bigint, text) is '[V3.2] RPC cho Shipper ghi nhận lý do giao hàng thất bại.';
GRANT EXECUTE ON FUNCTION public.record_delivery_failure_by_shipper(bigint, text) TO authenticated;

-- RPC: User đánh dấu đơn hàng hoàn thành
-- DROP FUNCTION IF EXISTS public.mark_order_completed_by_user(bigint);
CREATE OR REPLACE FUNCTION public.mark_order_completed_by_user(p_order_id bigint)
RETURNS void LANGUAGE plpgsql SECURITY DEFINER SET search_path = public AS $$
DECLARE target_order public.orders%rowtype; current_status_name text; delivered_status_id smallint; completed_status_id smallint;
BEGIN
  IF auth.uid() IS NULL THEN RAISE EXCEPTION 'AUTH_REQUIRED: Bạn cần đăng nhập.'; END IF;
  SELECT * INTO target_order FROM public.orders WHERE id = p_order_id AND user_id = auth.uid();
  IF target_order IS NULL THEN RAISE EXCEPTION 'NOT_FOUND: Không tìm thấy đơn hàng hoặc bạn không có quyền.'; END IF;
  SELECT id, name INTO delivered_status_id, current_status_name FROM public.order_statuses WHERE id = target_order.order_status_id;
  SELECT id INTO completed_status_id FROM public.order_statuses WHERE name = 'Đã hoàn thành';
  IF current_status_name != 'Đã giao' THEN RAISE EXCEPTION 'ACTION_NOT_ALLOWED: Chỉ xác nhận hoàn thành đơn "Đã giao".'; END IF;
  IF target_order.payment_status != 'Paid' THEN RAISE EXCEPTION 'ACTION_NOT_ALLOWED: Thanh toán chưa được xác nhận.'; END IF;
  UPDATE public.orders SET order_status_id = completed_status_id, completed_at = now() WHERE id = p_order_id;
END; $$;
comment on function public.mark_order_completed_by_user(bigint) is '[V3.2] RPC cho người dùng đánh dấu đơn hàng đã hoàn thành.';
GRANT EXECUTE ON FUNCTION public.mark_order_completed_by_user(bigint) TO authenticated;

-- RPC: Admin/Staff xác nhận thanh toán Chuyển khoản
-- DROP FUNCTION IF EXISTS public.confirm_bank_transfer_payment(bigint, jsonb);
CREATE OR REPLACE FUNCTION public.confirm_bank_transfer_payment(p_order_id bigint, p_transaction_details jsonb DEFAULT NULL)
RETURNS void LANGUAGE plpgsql SECURITY DEFINER SET search_path = public AS $$
DECLARE target_order public.orders%rowtype; bank_method_id smallint; new_payment_id bigint;
BEGIN
    IF NOT public.is_staff() THEN RAISE EXCEPTION 'AUTH_REQUIRED: Chỉ Admin/Staff mới có quyền xác nhận.'; END IF;
    SELECT * INTO target_order FROM public.orders WHERE id = p_order_id;
    IF target_order IS NULL THEN RAISE EXCEPTION 'NOT_FOUND: Không tìm thấy đơn hàng.'; END IF;
    SELECT id INTO bank_method_id FROM public.payment_methods WHERE name = 'Chuyển khoản ngân hàng';
    IF target_order.payment_method_id != bank_method_id THEN RAISE EXCEPTION 'ACTION_NOT_ALLOWED: Đơn hàng không phải thanh toán bằng Chuyển khoản ngân hàng.'; END IF;
    IF target_order.payment_status = 'Paid' THEN RAISE NOTICE 'Đơn hàng #% đã được xác nhận thanh toán.', p_order_id; RETURN; END IF;
    UPDATE public.orders SET payment_status = 'Paid' WHERE id = p_order_id;
    INSERT INTO public.payments (order_id, payment_method_id, amount, status, payment_details, transaction_id)
    VALUES (p_order_id, bank_method_id, target_order.total_amount, 'Completed', p_transaction_details, 'BANK-' || p_order_id::text || '-' || to_char(now(), 'YYMMDDHH24MISS'))
    RETURNING id INTO new_payment_id;
    -- Log activity (Trigger on orders update will also log payment status change)
    INSERT INTO public.admin_activity_log (admin_user_id, activity_type, description, entity_type, entity_id, details)
    VALUES (auth.uid(), 'BANK_TRANSFER_CONFIRMED', 'Admin/Staff xác nhận thanh toán chuyển khoản cho đơn #' || p_order_id || '. Payment ID: ' || new_payment_id, 'order', p_order_id::text, p_transaction_details);
END; $$;
comment on function public.confirm_bank_transfer_payment(bigint, jsonb) is '[V3.2] RPC cho Admin/Staff xác nhận thủ công thanh toán Chuyển khoản.';
GRANT EXECUTE ON FUNCTION public.confirm_bank_transfer_payment(bigint, jsonb) TO authenticated;

-- RPC: Admin/Staff điều chỉnh tồn kho thủ công
-- DROP FUNCTION IF EXISTS public.adjust_stock(bigint, integer, text);
CREATE OR REPLACE FUNCTION public.adjust_stock(p_variant_id bigint, p_change_amount integer, p_reason text)
RETURNS integer LANGUAGE plpgsql SECURITY DEFINER SET search_path = public AS $$
DECLARE current_stock integer; new_stock integer;
BEGIN
    IF NOT public.is_staff() THEN RAISE EXCEPTION 'AUTH_REQUIRED: Chỉ Admin/Staff mới có quyền.'; END IF;
    IF p_change_amount = 0 THEN RAISE EXCEPTION 'VALIDATION_ERROR: Số lượng thay đổi phải khác 0.'; END IF;
    IF p_reason IS NULL OR trim(p_reason) = '' THEN RAISE EXCEPTION 'VALIDATION_ERROR: Phải cung cấp lý do.'; END IF;
    SELECT stock_quantity INTO current_stock FROM public.product_variants WHERE id = p_variant_id AND deleted_at IS NULL FOR UPDATE; -- Lock row
    IF NOT FOUND THEN RAISE EXCEPTION 'NOT_FOUND: Biến thể ID % không tồn tại hoặc đã xóa.', p_variant_id; END IF;
    new_stock := current_stock + p_change_amount;
    IF new_stock < 0 THEN RAISE EXCEPTION 'VALIDATION_ERROR: Tồn kho không thể âm (%) cho biến thể ID %.', new_stock, p_variant_id; END IF;
    UPDATE public.product_variants SET stock_quantity = new_stock WHERE id = p_variant_id;
    INSERT INTO public.inventory (variant_id, change_amount, reason, order_id, stock_after_change, updated_by)
    VALUES (p_variant_id, p_change_amount, p_reason, NULL, new_stock, auth.uid());
    INSERT INTO public.admin_activity_log (admin_user_id, activity_type, description, entity_type, entity_id, details)
    VALUES (auth.uid(), 'STOCK_ADJUSTMENT', 'Điều chỉnh kho cho variant #' || p_variant_id || '. Thay đổi: ' || p_change_amount || '. Lý do: ' || p_reason, 'product_variant', p_variant_id::text, jsonb_build_object('change_amount', p_change_amount, 'reason', p_reason, 'stock_before', current_stock, 'stock_after', new_stock));
    RETURN new_stock;
END; $$;
comment on function public.adjust_stock(bigint, integer, text) is '[V3.2] RPC cho Admin/Staff điều chỉnh tồn kho thủ công. Cập nhật inventory, log activity.';
GRANT EXECUTE ON FUNCTION public.adjust_stock(bigint, integer, text) TO authenticated;

-- RPC: Lấy sản phẩm đang giảm giá cho trang chủ (có check tồn kho)
-- DROP FUNCTION IF EXISTS public.get_homepage_on_sale_products_with_stock(integer);
CREATE OR REPLACE FUNCTION public.get_homepage_on_sale_products_with_stock(p_limit integer DEFAULT 8)
RETURNS TABLE ( product_id bigint, product_name text, product_slug text, brand_name text, main_image_url text, display_price numeric, original_price_high numeric, is_generally_in_stock boolean )
LANGUAGE sql STABLE SECURITY DEFINER SET search_path = public AS $$
-- Uses LATERAL join for potentially better performance in calculating variant aggregates per product
WITH ProductStockStatus AS (
    -- Determine if a product has any active variant in stock
    SELECT
        pv.product_id,
        BOOL_OR(pv.stock_quantity > 0) as has_stock
    FROM
        public.product_variants pv
    WHERE
        pv.deleted_at IS NULL
    GROUP BY
        pv.product_id
), ProductSaleInfo AS (
    -- Determine if a product has any active variant on sale
    SELECT
        pv.product_id,
        BOOL_OR(pv.sale_price IS NOT NULL AND pv.sale_price < pv.price) as is_on_sale,
        MIN(COALESCE(pv.sale_price, pv.price)) as min_display_price, -- Lowest price (sale or regular)
        MAX(pv.price) as max_original_price -- Highest original price among variants
    FROM
        public.product_variants pv
    WHERE
        pv.deleted_at IS NULL
    GROUP BY
        pv.product_id
)
SELECT
    p.id AS product_id,
    p.name AS product_name,
    p.slug AS product_slug,
    b.name as brand_name,
    (SELECT pi.image_url FROM public.product_images pi WHERE pi.product_id = p.id AND pi.is_main = true ORDER BY pi.display_order LIMIT 1) AS main_image_url,
    psi.min_display_price AS display_price,
    psi.max_original_price AS original_price_high,
    COALESCE(pss.has_stock, FALSE) AS is_generally_in_stock
FROM
    public.products p
JOIN
    ProductSaleInfo psi ON p.id = psi.product_id
LEFT JOIN
    ProductStockStatus pss ON p.id = pss.product_id
LEFT JOIN
    public.brands b ON p.brand_id = b.id
WHERE
    p.deleted_at IS NULL
    AND psi.is_on_sale = true -- Only include products that have at least one variant on sale
ORDER BY
    -- Prioritize in-stock items, then by creation date (newest first)
    is_generally_in_stock DESC,
    p.created_at DESC
LIMIT p_limit;
$$;
COMMENT ON FUNCTION public.get_homepage_on_sale_products_with_stock(integer) IS '[V3.2] RPC lấy danh sách sản phẩm đang giảm giá cho trang chủ, kèm cờ báo còn hàng.';
GRANT EXECUTE ON FUNCTION public.get_homepage_on_sale_products_with_stock(integer) TO anon, authenticated;


-- [V3.2 Filter RPC - FIXED] RPC: Lọc sản phẩm nâng cao (Sử dụng JSONB và EXECUTE an toàn hơn)
-- DROP FUNCTION IF EXISTS public.filter_products(jsonb, integer, integer, text, text);
CREATE OR REPLACE FUNCTION public.filter_products(
    p_filters jsonb DEFAULT '{}'::jsonb,
    p_page integer DEFAULT 1,
    p_page_size integer DEFAULT 20,
    p_sort_by text DEFAULT 'created_at',
    p_sort_order text DEFAULT 'desc'
)
RETURNS TABLE (
    product_id bigint,
    product_name text,
    product_slug text,
    short_description text,
    brand_id bigint,
    brand_name text,
    main_image_url text,
    min_price numeric,          -- Giá gốc thấp nhất của các variant
    max_price numeric,          -- Giá gốc cao nhất của các variant
    min_sale_price numeric,     -- Giá sale thấp nhất (nếu có)
    display_price numeric,      -- Giá hiển thị thấp nhất (sale hoặc gốc)
    is_on_sale boolean,         -- Sản phẩm có đang sale không (ít nhất 1 variant)
    is_in_stock boolean,        -- Sản phẩm có còn hàng không (ít nhất 1 variant)
    created_at timestamptz,
    total_count bigint          -- Tổng số sản phẩm khớp với bộ lọc (không phân trang)
)
LANGUAGE plpgsql STABLE SECURITY INVOKER -- Chạy với quyền người gọi (RLS sẽ áp dụng)
SET search_path = public AS $$
DECLARE
    query_select text;
    query_from text;
    query_where text := 'WHERE p.deleted_at IS NULL '; -- Base condition
    query_order text;
    query_final text;
    v_offset integer := (p_page - 1) * p_page_size;
    v_search_term text := trim(p_filters->>'search_term'); -- Lấy search term
    -- Mảng chứa các tham số thực sự truyền qua USING clause
    using_params text[] := ARRAY[]::text[];
    param_index integer := 1; -- Index cho placeholder trong USING
    allowed_sort_cols text[] := ARRAY['created_at', 'name', 'display_price', 'popularity']; -- Các cột sort hợp lệ
    sort_column text;
    sort_direction text;
BEGIN
    -- 1. Build SELECT clause (bao gồm tính total_count)
    query_select := '
        SELECT
            p.id as product_id, p.name as product_name, p.slug as product_slug, p.short_description,
            p.brand_id, b.name as brand_name,
            (SELECT pi.image_url FROM public.product_images pi WHERE pi.product_id = p.id AND pi.is_main = true ORDER BY pi.display_order, pi.id LIMIT 1) as main_image_url,
            var_info.min_price, var_info.max_price, var_info.min_sale_price, var_info.display_price,
            var_info.is_on_sale, var_info.is_in_stock,
            p.created_at,
            COUNT(*) OVER() as total_count '; -- Tính tổng số dòng khớp WHERE trước khi LIMIT/OFFSET

    -- 2. Build FROM clause (sử dụng LATERAL join để tính toán thông tin variant)
    query_from := '
        FROM public.products p
        LEFT JOIN public.brands b ON p.brand_id = b.id
        LEFT JOIN LATERAL (
            SELECT
                MIN(pv.price) as min_price,
                MAX(pv.price) as max_price,
                MIN(pv.sale_price) as min_sale_price,
                MIN(COALESCE(pv.sale_price, pv.price)) as display_price,
                BOOL_OR(pv.sale_price IS NOT NULL AND pv.sale_price < pv.price) as is_on_sale,
                BOOL_OR(pv.stock_quantity > 0) as is_in_stock
            FROM public.product_variants pv
            WHERE pv.product_id = p.id AND pv.deleted_at IS NULL
        ) var_info ON true ';

    -- 3. Build WHERE clause dynamically based on p_filters JSONB
    -- Brand IDs
    IF jsonb_typeof(p_filters->'brand_ids') = 'array' AND jsonb_array_length(p_filters->'brand_ids') > 0 THEN
        query_where := query_where || format(' AND p.brand_id = ANY (SELECT jsonb_array_elements_text($%s)::bigint)', param_index);
        using_params := using_params || (p_filters->'brand_ids');
        param_index := param_index + 1;
    END IF;

    -- Gender IDs
    IF jsonb_typeof(p_filters->'gender_ids') = 'array' AND jsonb_array_length(p_filters->'gender_ids') > 0 THEN
        query_where := query_where || format(' AND p.gender_id = ANY (SELECT jsonb_array_elements_text($%s)::smallint)', param_index);
        using_params := using_params || (p_filters->'gender_ids');
        param_index := param_index + 1;
    END IF;

    -- Category IDs
    IF jsonb_typeof(p_filters->'category_ids') = 'array' AND jsonb_array_length(p_filters->'category_ids') > 0 THEN
        query_where := query_where || format(' AND EXISTS (SELECT 1 FROM product_categories pc WHERE pc.product_id = p.id AND pc.category_id = ANY (SELECT jsonb_array_elements_text($%s)::bigint))', param_index);
        using_params := using_params || (p_filters->'category_ids');
        param_index := param_index + 1;
    END IF;

    -- Ingredient IDs
    IF jsonb_typeof(p_filters->'ingredient_ids') = 'array' AND jsonb_array_length(p_filters->'ingredient_ids') > 0 THEN
        query_where := query_where || format(' AND EXISTS (SELECT 1 FROM product_ingredients pi WHERE pi.product_id = p.id AND pi.ingredient_id = ANY (SELECT jsonb_array_elements_text($%s)::bigint))', param_index);
        using_params := using_params || (p_filters->'ingredient_ids');
        param_index := param_index + 1;
    END IF;

    -- Label IDs
    IF jsonb_typeof(p_filters->'label_ids') = 'array' AND jsonb_array_length(p_filters->'label_ids') > 0 THEN
        query_where := query_where || format(' AND EXISTS (SELECT 1 FROM product_label_assignments pla WHERE pla.product_id = p.id AND pla.label_id = ANY (SELECT jsonb_array_elements_text($%s)::bigint) AND (pla.valid_until IS NULL OR pla.valid_until >= now()))', param_index);
        using_params := using_params || (p_filters->'label_ids');
        param_index := param_index + 1;
    END IF;

    -- Price Range (using display_price which is MIN(sale_price, price))
    IF p_filters ? 'min_price' AND jsonb_typeof(p_filters->'min_price') = 'number' THEN
        query_where := query_where || format(' AND var_info.display_price >= $%s', param_index);
        using_params := using_params || (p_filters->>'min_price')::numeric;
        param_index := param_index + 1;
    END IF;
    IF p_filters ? 'max_price' AND jsonb_typeof(p_filters->'max_price') = 'number' THEN
        query_where := query_where || format(' AND var_info.display_price <= $%s', param_index);
        using_params := using_params || (p_filters->>'max_price')::numeric;
        param_index := param_index + 1;
    END IF;

    -- On Sale filter
    IF p_filters ? 'on_sale' AND (p_filters->>'on_sale')::boolean = true THEN
        query_where := query_where || ' AND var_info.is_on_sale = true ';
    END IF;

    -- In Stock filter
    IF p_filters ? 'in_stock' AND (p_filters->>'in_stock')::boolean = true THEN
        query_where := query_where || ' AND var_info.is_in_stock = true ';
    END IF;

    -- Volume Range
    IF (p_filters ? 'min_volume' AND jsonb_typeof(p_filters->'min_volume') = 'number') OR (p_filters ? 'max_volume' AND jsonb_typeof(p_filters->'max_volume') = 'number') THEN
        query_where := query_where || ' AND EXISTS (SELECT 1 FROM product_variants pv_vol WHERE pv_vol.product_id = p.id AND pv_vol.deleted_at IS NULL ';
        IF p_filters ? 'min_volume' THEN
            query_where := query_where || format(' AND pv_vol.volume_ml >= $%s', param_index);
            using_params := using_params || (p_filters->>'min_volume')::integer;
            param_index := param_index + 1;
        END IF;
        IF p_filters ? 'max_volume' THEN
            query_where := query_where || format(' AND pv_vol.volume_ml <= $%s', param_index);
            using_params := using_params || (p_filters->>'max_volume')::integer;
            param_index := param_index + 1;
        END IF;
        query_where := query_where || ') ';
    END IF;

    -- Full-Text Search (using simple config and unaccent)
    IF v_search_term IS NOT NULL AND v_search_term <> '' THEN
        -- Pass the search term itself as a parameter, use websearch_to_tsquery inside the dynamic query for safety
        query_where := query_where || format(' AND p.fts @@ websearch_to_tsquery(''simple'', unaccent($%s)) ', param_index);
        using_params := using_params || v_search_term;
        param_index := param_index + 1;
    END IF;

    -- Origin Country (Case-insensitive partial match)
    IF p_filters ? 'origin_country' AND jsonb_typeof(p_filters->'origin_country') = 'string' AND trim(p_filters->>'origin_country') <> '' THEN
        query_where := query_where || format(' AND p.origin_country ILIKE $%s', param_index);
        using_params := using_params || ('%' || trim(p_filters->>'origin_country') || '%');
        param_index := param_index + 1;
    END IF;

    -- Release Year Range
    IF p_filters ? 'release_year_min' AND jsonb_typeof(p_filters->'release_year_min') = 'number' THEN
        query_where := query_where || format(' AND p.release_year >= $%s', param_index);
        using_params := using_params || (p_filters->>'release_year_min')::smallint;
        param_index := param_index + 1;
    END IF;
    IF p_filters ? 'release_year_max' AND jsonb_typeof(p_filters->'release_year_max') = 'number' THEN
        query_where := query_where || format(' AND p.release_year <= $%s', param_index);
        using_params := using_params || (p_filters->>'release_year_max')::smallint;
        param_index := param_index + 1;
    END IF;

    -- 4. Build ORDER BY clause
    sort_column := lower(p_sort_by);
    sort_direction := upper(p_sort_order);
    IF NOT (sort_column = ANY(allowed_sort_cols)) THEN sort_column := 'created_at'; END IF;
    IF sort_direction NOT IN ('ASC', 'DESC') THEN sort_direction := 'DESC'; END IF;

    -- Map API sort names to actual table/calculation columns
    CASE sort_column
        WHEN 'display_price' THEN sort_column := 'var_info.display_price';
        WHEN 'popularity' THEN sort_column := 'p.created_at'; -- Example: Use creation date as proxy for popularity, adjust as needed
        -- WHEN 'rating' THEN sort_column := '(SELECT AVG(r.rating) FROM reviews r WHERE r.product_id = p.id AND r.is_approved = true)'; -- Requires adding rating calculation
        ELSE sort_column := 'p.' || quote_ident(sort_column); -- Quote identifier for safety
    END CASE;

    query_order := format(' ORDER BY %s %s NULLS LAST, p.id %s ', sort_column, sort_direction, sort_direction); -- Add secondary sort by ID

    -- 5. Build LIMIT and OFFSET
    query_final := query_select || query_from || query_where || query_order || format(' LIMIT $%s OFFSET $%s', param_index, param_index + 1);
    using_params := using_params || p_page_size || v_offset;

    -- Debugging: Uncomment to see the generated query and parameters
    -- RAISE NOTICE 'Query: %', query_final;
    -- RAISE NOTICE 'Params: %', using_params;

    -- 6. Execute the dynamic query
    RETURN QUERY EXECUTE query_final USING using_params;

END;
$$;
COMMENT ON FUNCTION public.filter_products(jsonb, integer, integer, text, text) IS '[V3.2 Filter RPC - FIXED] Lọc sản phẩm linh hoạt, FTS, sắp xếp, phân trang. Sử dụng JSONB input và EXECUTE ... USING để tăng cường an toàn và hiệu quả. Trả về thông tin PLP và total_count.';
GRANT EXECUTE ON FUNCTION public.filter_products(jsonb, integer, integer, text, text) TO anon, authenticated; -- Mọi người có thể lọc


-- ============================================================================
-- SECTION: RLS POLICIES (Access Control Rules) V3.2
-- Định nghĩa các quy tắc truy cập dữ liệu cho từng vai trò.
-- ============================================================================

-- === USER POLICIES ===
DROP POLICY IF EXISTS "Users manage own addresses" ON public.addresses; CREATE POLICY "Users manage own addresses" ON public.addresses FOR ALL USING (auth.uid() = user_id) WITH CHECK (auth.uid() = user_id);
DROP POLICY IF EXISTS "Users manage own profile" ON public.profiles; CREATE POLICY "Users manage own profile" ON public.profiles FOR ALL USING (auth.uid() = id) WITH CHECK (auth.uid() = id);
DROP POLICY IF EXISTS "Users manage own shopping carts" ON public.shopping_carts; CREATE POLICY "Users manage own shopping carts" ON public.shopping_carts FOR ALL USING (auth.uid() = user_id) WITH CHECK (auth.uid() = user_id);
DROP POLICY IF EXISTS "Users manage own cart items" ON public.cart_items; CREATE POLICY "Users manage own cart items" ON public.cart_items FOR ALL USING (EXISTS (SELECT 1 FROM public.shopping_carts WHERE id = cart_id AND user_id = auth.uid())) WITH CHECK (EXISTS (SELECT 1 FROM public.shopping_carts WHERE id = cart_id AND user_id = auth.uid()));
DROP POLICY IF EXISTS "Users manage own wishlists" ON public.wishlists; CREATE POLICY "Users manage own wishlists" ON public.wishlists FOR ALL USING (auth.uid() = user_id) WITH CHECK (auth.uid() = user_id);
DROP POLICY IF EXISTS "Users can view their own orders" ON public.orders; CREATE POLICY "Users can view their own orders" ON public.orders FOR SELECT USING (auth.uid() = user_id);
DROP POLICY IF EXISTS "Users can view items for own orders" ON public.order_items; CREATE POLICY "Users can view items for own orders" ON public.order_items FOR SELECT USING (EXISTS (SELECT 1 FROM public.orders WHERE id = order_items.order_id AND user_id = auth.uid()));
DROP POLICY IF EXISTS "Users can view payments for own orders" ON public.payments; CREATE POLICY "Users can view payments for own orders" ON public.payments FOR SELECT USING (EXISTS (SELECT 1 FROM public.orders WHERE id = order_id AND user_id = auth.uid()));
DROP POLICY IF EXISTS "Users can view own reviews" ON public.reviews; CREATE POLICY "Users can view own reviews" ON public.reviews FOR SELECT USING (auth.uid() = user_id);
DROP POLICY IF EXISTS "Users can insert reviews if purchased" ON public.reviews; CREATE POLICY "Users can insert reviews if purchased" ON public.reviews FOR INSERT WITH CHECK (auth.uid() = user_id AND public.has_user_purchased_product(product_id));
DROP POLICY IF EXISTS "Users can update own unapproved reviews" ON public.reviews; CREATE POLICY "Users can update own unapproved reviews" ON public.reviews FOR UPDATE USING (auth.uid() = user_id AND is_approved = false) WITH CHECK (auth.uid() = user_id);
DROP POLICY IF EXISTS "Users can delete own reviews" ON public.reviews; CREATE POLICY "Users can delete own reviews" ON public.reviews FOR DELETE USING (auth.uid() = user_id);

-- === PUBLIC ACCESS POLICIES ===
DROP POLICY IF EXISTS "Public read access for brands" ON public.brands; CREATE POLICY "Public read access for brands" ON public.brands FOR SELECT USING (true);
DROP POLICY IF EXISTS "Public read access for genders" ON public.genders; CREATE POLICY "Public read access for genders" ON public.genders FOR SELECT USING (true);
DROP POLICY IF EXISTS "Public read access for perfume types" ON public.perfume_types; CREATE POLICY "Public read access for perfume types" ON public.perfume_types FOR SELECT USING (true);
DROP POLICY IF EXISTS "Public read access for concentrations" ON public.concentrations; CREATE POLICY "Public read access for concentrations" ON public.concentrations FOR SELECT USING (true);
DROP POLICY IF EXISTS "Public read access for categories" ON public.categories; CREATE POLICY "Public read access for categories" ON public.categories FOR SELECT USING (true);
DROP POLICY IF EXISTS "Public read access for active products" ON public.products; CREATE POLICY "Public read access for active products" ON public.products FOR SELECT USING (deleted_at IS NULL);
DROP POLICY IF EXISTS "Public read access for scents" ON public.scents; CREATE POLICY "Public read access for scents" ON public.scents FOR SELECT USING (true);
DROP POLICY IF EXISTS "Public read access for ingredients" ON public.ingredients; CREATE POLICY "Public read access for ingredients" ON public.ingredients FOR SELECT USING (true);
DROP POLICY IF EXISTS "Public read access for active product variants" ON public.product_variants; CREATE POLICY "Public read access for active product variants" ON public.product_variants FOR SELECT USING (deleted_at IS NULL);
DROP POLICY IF EXISTS "Public read access for product ingredients" ON public.product_ingredients; CREATE POLICY "Public read access for product ingredients" ON public.product_ingredients FOR SELECT USING (true);
DROP POLICY IF EXISTS "Public read access for product images" ON public.product_images; CREATE POLICY "Public read access for product images" ON public.product_images FOR SELECT USING (true);
DROP POLICY IF EXISTS "Public read access for product categories links" ON public.product_categories; CREATE POLICY "Public read access for product categories links" ON public.product_categories FOR SELECT USING (true);
DROP POLICY IF EXISTS "Public read access for product labels" ON public.product_labels; CREATE POLICY "Public read access for product labels" ON public.product_labels FOR SELECT USING (true);
DROP POLICY IF EXISTS "Public read access for product label assignments" ON public.product_label_assignments; CREATE POLICY "Public read access for product label assignments" ON public.product_label_assignments FOR SELECT USING (valid_until IS NULL OR valid_until >= now());
DROP POLICY IF EXISTS "Public read access for active discounts" ON public.discounts; CREATE POLICY "Public read access for active discounts" ON public.discounts FOR SELECT USING (is_active = true AND (start_date IS NULL OR start_date <= now()) AND (end_date IS NULL OR end_date >= now()));
DROP POLICY IF EXISTS "Public read access for order statuses" ON public.order_statuses; CREATE POLICY "Public read access for order statuses" ON public.order_statuses FOR SELECT USING (true);
DROP POLICY IF EXISTS "Public read access for active payment methods" ON public.payment_methods; CREATE POLICY "Public read access for active payment methods" ON public.payment_methods FOR SELECT USING (is_active = true);
DROP POLICY IF EXISTS "Public read access for approved reviews" ON public.reviews; CREATE POLICY "Public read access for approved reviews" ON public.reviews FOR SELECT USING (is_approved = true);
DROP POLICY IF EXISTS "Public read access for review replies" ON public.review_replies; CREATE POLICY "Public read access for review replies" ON public.review_replies FOR SELECT USING (true);
DROP POLICY IF EXISTS "Public read access for active banners" ON public.banners; CREATE POLICY "Public read access for active banners" ON public.banners FOR SELECT USING (is_active = true AND (start_date IS NULL OR start_date <= now()) AND (end_date IS NULL OR end_date >= now()));
DROP POLICY IF EXISTS "Public read access for shop settings" ON public.shop_settings; CREATE POLICY "Public read access for shop settings" ON public.shop_settings FOR SELECT USING (true);
-- Policies for product_scents (Public Read)
DROP POLICY IF EXISTS "Public read access for product scents" ON public.product_scents;
CREATE POLICY "Public read access for product scents" ON public.product_scents FOR SELECT USING (true);
COMMENT ON POLICY "Public read access for product scents" ON public.product_scents IS '[V3.2] Mọi người đều có thể xem liên kết Sản phẩm - Nhóm hương.';

-- === SHIPPER POLICIES ===
-- **KHUYẾN NGHỊ:** Vẫn nên tạo VIEW/RPC riêng để giới hạn cột cho Shipper thay vì SELECT trực tiếp.
DROP POLICY IF EXISTS "Shippers can view assigned orders" ON public.orders; CREATE POLICY "Shippers can view assigned orders" ON public.orders FOR SELECT USING (public.is_shipper() AND assigned_shipper_id = auth.uid() AND order_status_id IN (SELECT id FROM public.order_statuses WHERE name IN ('Đã xác nhận', 'Đang xử lý', 'Đang giao', 'Đã giao')));
comment on policy "Shippers can view assigned orders" on public.orders is '[V3.2] Shipper chỉ SELECT được đơn hàng được gán. **KHUYẾN NGHỊ DÙNG VIEW/RPC GIỚI HẠN CỘT!**';
DROP POLICY IF EXISTS "Shippers can view items for assigned orders" ON public.order_items; CREATE POLICY "Shippers can view items for assigned orders" ON public.order_items FOR SELECT USING (public.is_shipper() AND EXISTS (SELECT 1 FROM public.orders o WHERE o.id = order_items.order_id AND o.assigned_shipper_id = auth.uid() AND o.order_status_id IN (SELECT id FROM public.order_statuses WHERE name IN ('Đã xác nhận', 'Đang xử lý', 'Đang giao', 'Đã giao'))));
comment on policy "Shippers can view items for assigned orders" on public.order_items is '[V3.2] Shipper chỉ SELECT được item thuộc đơn được gán. **KHUYẾN NGHỊ DÙNG VIEW/RPC GIỚI HẠN CỘT!**';

-- === STAFF & ADMIN POLICIES ===
-- Staff Policies (bao gồm cả Admin vì is_staff() = true cho admin)
DROP POLICY IF EXISTS "Staff can view all orders" ON public.orders; CREATE POLICY "Staff can view all orders" ON public.orders FOR SELECT USING (public.is_staff());
DROP POLICY IF EXISTS "Staff can update orders" ON public.orders; CREATE POLICY "Staff can update orders" ON public.orders FOR UPDATE USING (public.is_staff()) WITH CHECK (public.is_staff()); -- Trigger sẽ kiểm tra logic chuyển trạng thái
DROP POLICY IF EXISTS "Staff can view all order items" ON public.order_items; CREATE POLICY "Staff can view all order items" ON public.order_items FOR SELECT USING (public.is_staff());
DROP POLICY IF EXISTS "Staff can view all payments" ON public.payments; CREATE POLICY "Staff can view all payments" ON public.payments FOR SELECT USING (public.is_staff());
DROP POLICY IF EXISTS "Staff can manage payments" ON public.payments; CREATE POLICY "Staff can manage payments" ON public.payments FOR ALL USING (public.is_staff()) WITH CHECK (public.is_staff()); -- Cho phép Staff cập nhật (vd: qua RPC confirm_bank_transfer)
DROP POLICY IF EXISTS "Staff can view all reviews" ON public.reviews; CREATE POLICY "Staff can view all reviews" ON public.reviews FOR SELECT USING (public.is_staff());
DROP POLICY IF EXISTS "Staff can manage reviews (approve/update/delete)" ON public.reviews; CREATE POLICY "Staff can manage reviews (approve/update/delete)" ON public.reviews FOR ALL USING (public.is_staff()) WITH CHECK (public.is_staff()); -- Duyệt/phản hồi qua RPC
DROP POLICY IF EXISTS "Staff can manage review replies" ON public.review_replies; CREATE POLICY "Staff can manage review replies" ON public.review_replies FOR ALL USING (public.is_staff()) WITH CHECK (public.is_staff());
DROP POLICY IF EXISTS "Staff can manage product data" ON public.products; CREATE POLICY "Staff can manage product data" ON public.products FOR ALL USING (public.is_staff()) WITH CHECK (public.is_staff());
DROP POLICY IF EXISTS "Staff can manage product variants" ON public.product_variants; CREATE POLICY "Staff can manage product variants" ON public.product_variants FOR ALL USING (public.is_staff()) WITH CHECK (public.is_staff()); -- Điều chỉnh kho qua RPC
DROP POLICY IF EXISTS "Staff can manage product images" ON public.product_images; CREATE POLICY "Staff can manage product images" ON public.product_images FOR ALL USING (public.is_staff()) WITH CHECK (public.is_staff());
DROP POLICY IF EXISTS "Staff can manage product ingredients links" ON public.product_ingredients; CREATE POLICY "Staff can manage product ingredients links" ON public.product_ingredients FOR ALL USING (public.is_staff()) WITH CHECK (public.is_staff());
DROP POLICY IF EXISTS "Staff can manage product categories links" ON public.product_categories; CREATE POLICY "Staff can manage product categories links" ON public.product_categories FOR ALL USING (public.is_staff()) WITH CHECK (public.is_staff());
DROP POLICY IF EXISTS "Staff can manage product labels assignments" ON public.product_label_assignments; CREATE POLICY "Staff can manage product labels assignments" ON public.product_label_assignments FOR ALL USING (public.is_staff()) WITH CHECK (public.is_staff());
-- Policies for product_scents (Staff/Admin Manage)
DROP POLICY IF EXISTS "Staff/Admin can manage product scents" ON public.product_scents;
CREATE POLICY "Staff/Admin can manage product scents" ON public.product_scents FOR ALL USING (public.is_staff()) WITH CHECK (public.is_staff());
COMMENT ON POLICY "Staff/Admin can manage product scents" ON public.product_scents IS '[V3.2] Chỉ Staff hoặc Admin mới có quyền quản lý (thêm/sửa/xóa) liên kết Sản phẩm - Nhóm hương.';
DROP POLICY IF EXISTS "Staff can manage banners" ON public.banners; CREATE POLICY "Staff can manage banners" ON public.banners FOR ALL USING (public.is_staff()) WITH CHECK (public.is_staff());
DROP POLICY IF EXISTS "Staff can manage categories" ON public.categories; CREATE POLICY "Staff can manage categories" ON public.categories FOR ALL USING (public.is_staff()) WITH CHECK (public.is_staff());
DROP POLICY IF EXISTS "Staff can manage brands" ON public.brands; CREATE POLICY "Staff can manage brands" ON public.brands FOR ALL USING (public.is_staff()) WITH CHECK (public.is_staff());
DROP POLICY IF EXISTS "Staff can manage ingredients" ON public.ingredients; CREATE POLICY "Staff can manage ingredients" ON public.ingredients FOR ALL USING (public.is_staff()) WITH CHECK (public.is_staff());
DROP POLICY IF EXISTS "Staff can manage scents" ON public.scents; CREATE POLICY "Staff can manage scents" ON public.scents FOR ALL USING (public.is_staff()) WITH CHECK (public.is_staff());
DROP POLICY IF EXISTS "Staff can manage discounts" ON public.discounts; CREATE POLICY "Staff can manage discounts" ON public.discounts FOR ALL USING (public.is_staff()) WITH CHECK (public.is_staff());
DROP POLICY IF EXISTS "Staff can view inventory log" ON public.inventory; CREATE POLICY "Staff can view inventory log" ON public.inventory FOR SELECT USING (public.is_staff()); -- Staff chỉ xem log kho

-- Admin Policies (Granting full access where Staff doesn't have it)
DROP POLICY IF EXISTS "Admins can manage all addresses" ON public.addresses; CREATE POLICY "Admins can manage all addresses" ON public.addresses FOR ALL USING (public.is_admin()) WITH CHECK (public.is_admin());
DROP POLICY IF EXISTS "Admins can manage all profiles" ON public.profiles; CREATE POLICY "Admins can manage all profiles" ON public.profiles FOR ALL USING (public.is_admin()) WITH CHECK (public.is_admin());
DROP POLICY IF EXISTS "Admins can manage genders" ON public.genders; CREATE POLICY "Admins can manage genders" ON public.genders FOR ALL USING (public.is_admin()) WITH CHECK (public.is_admin());
DROP POLICY IF EXISTS "Admins can manage perfume types" ON public.perfume_types; CREATE POLICY "Admins can manage perfume types" ON public.perfume_types FOR ALL USING (public.is_admin()) WITH CHECK (public.is_admin());
DROP POLICY IF EXISTS "Admins can manage concentrations" ON public.concentrations; CREATE POLICY "Admins can manage concentrations" ON public.concentrations FOR ALL USING (public.is_admin()) WITH CHECK (public.is_admin());
DROP POLICY IF EXISTS "Admins can manage product labels" ON public.product_labels; CREATE POLICY "Admins can manage product labels" ON public.product_labels FOR ALL USING (public.is_admin()) WITH CHECK (public.is_admin());
DROP POLICY IF EXISTS "Admins can manage all shopping carts" ON public.shopping_carts; CREATE POLICY "Admins can manage all shopping carts" ON public.shopping_carts FOR ALL USING (public.is_admin()) WITH CHECK (public.is_admin());
DROP POLICY IF EXISTS "Admins can manage all cart items" ON public.cart_items; CREATE POLICY "Admins can manage all cart items" ON public.cart_items FOR ALL USING (public.is_admin()) WITH CHECK (public.is_admin());
DROP POLICY IF EXISTS "Admins can manage order statuses" ON public.order_statuses; CREATE POLICY "Admins can manage order statuses" ON public.order_statuses FOR ALL USING (public.is_admin()) WITH CHECK (public.is_admin());
DROP POLICY IF EXISTS "Admins can manage payment methods" ON public.payment_methods; CREATE POLICY "Admins can manage payment methods" ON public.payment_methods FOR ALL USING (public.is_admin()) WITH CHECK (public.is_admin());
DROP POLICY IF EXISTS "Admins can manage all orders" ON public.orders; CREATE POLICY "Admins can manage all orders" ON public.orders FOR ALL USING (public.is_admin()) WITH CHECK (public.is_admin()); -- Override Staff SELECT/UPDATE
DROP POLICY IF EXISTS "Admins can manage all order items" ON public.order_items; CREATE POLICY "Admins can manage all order items" ON public.order_items FOR ALL USING (public.is_admin()) WITH CHECK (public.is_admin());
DROP POLICY IF EXISTS "Admins can manage inventory log" ON public.inventory; CREATE POLICY "Admins can manage inventory log" ON public.inventory FOR ALL USING (public.is_admin()) WITH CHECK (public.is_admin()); -- Override Staff SELECT
DROP POLICY IF EXISTS "Admins can manage all wishlists" ON public.wishlists; CREATE POLICY "Admins can manage all wishlists" ON public.wishlists FOR ALL USING (public.is_admin()) WITH CHECK (public.is_admin());
DROP POLICY IF EXISTS "Admins can view admin activity logs" ON public.admin_activity_log; CREATE POLICY "Admins can view admin activity logs" ON public.admin_activity_log FOR SELECT USING (public.is_admin());
DROP POLICY IF EXISTS "Admins/System can insert admin activity logs" ON public.admin_activity_log; CREATE POLICY "Admins/System can insert admin activity logs" ON public.admin_activity_log FOR INSERT WITH CHECK (public.is_admin() or auth.role() = 'service_role'); -- Allow triggers/RPCs to log
DROP POLICY IF EXISTS "Admins can manage shop settings" ON public.shop_settings; CREATE POLICY "Admins can manage shop settings" ON public.shop_settings FOR ALL USING (public.is_admin()) WITH CHECK (public.is_admin());

-- === AUTH.USERS RLS POLICIES ===
DROP POLICY IF EXISTS "Admin can select all users" ON auth.users; CREATE POLICY "Admin can select all users" ON auth.users FOR SELECT USING (public.is_admin());
DROP POLICY IF EXISTS "Admin can update user metadata" ON auth.users; CREATE POLICY "Admin can update user metadata" ON auth.users FOR UPDATE USING (public.is_admin()) WITH CHECK (public.is_admin()); -- Needed to assign roles
DROP POLICY IF EXISTS "Staff can select all users" ON auth.users; CREATE POLICY "Staff can select all users" ON auth.users FOR SELECT USING (public.is_staff()); -- Allow staff to view users (read-only)
DROP POLICY IF EXISTS "Users can select their own data" ON auth.users; CREATE POLICY "Users can select their own data" ON auth.users FOR SELECT USING (auth.uid() = id);
-- Explicitly deny direct updates/deletes by non-admins if needed, although lack of policy achieves this.
-- DROP POLICY IF EXISTS "Deny staff updates on auth users" ON auth.users FOR UPDATE USING (NOT public.is_admin() AND public.is_staff());
-- DROP POLICY IF EXISTS "Deny user updates on auth users" ON auth.users FOR UPDATE USING (auth.uid() = id); -- Prevent user direct updates

-- ============================================================================
-- SECTION: STORAGE BUCKETS & POLICIES V3.2
-- ============================================================================

INSERT INTO storage.buckets (id, name, public, file_size_limit, allowed_mime_types) VALUES
  ('avatars', 'avatars', true, 5242880, ARRAY['image/jpeg', 'image/png', 'image/gif', 'image/webp']),
  ('logos', 'logos', true, 2097152, ARRAY['image/jpeg', 'image/png', 'image/gif', 'image/webp', 'image/svg+xml']),
  ('products', 'products', true, 5242880, ARRAY['image/jpeg', 'image/png', 'image/gif', 'image/webp']),
  ('banners', 'banners', true, 5242880, ARRAY['image/jpeg', 'image/png', 'image/gif', 'image/webp']),
  ('categories', 'categories', true, 5242880, ARRAY['image/jpeg', 'image/png', 'image/gif', 'image/webp'])
ON CONFLICT (id) DO NOTHING;

DROP POLICY IF EXISTS "Public read access" ON storage.objects;
DROP POLICY IF EXISTS "Authenticated user can insert avatar" ON storage.objects;
DROP POLICY IF EXISTS "Owner can update own avatar" ON storage.objects;
DROP POLICY IF EXISTS "Owner can delete own avatar" ON storage.objects;
DROP POLICY IF EXISTS "Admin/Staff can manage business assets" ON storage.objects;

CREATE POLICY "Public read access" ON storage.objects FOR SELECT USING (bucket_id IN ('avatars', 'logos', 'products', 'banners', 'categories'));
CREATE POLICY "Authenticated user can insert avatar" ON storage.objects FOR INSERT TO authenticated WITH CHECK (bucket_id = 'avatars');
CREATE POLICY "Owner can update own avatar" ON storage.objects FOR UPDATE TO authenticated USING ( bucket_id = 'avatars' AND auth.uid() = owner ) WITH CHECK ( bucket_id = 'avatars' AND auth.uid() = owner );
CREATE POLICY "Owner can delete own avatar" ON storage.objects FOR DELETE TO authenticated USING ( bucket_id = 'avatars' AND auth.uid() = owner );
CREATE POLICY "Admin/Staff can manage business assets" ON storage.objects FOR ALL USING (bucket_id IN ('logos', 'products', 'banners', 'categories') AND public.is_staff()) WITH CHECK (bucket_id IN ('logos', 'products', 'banners', 'categories') AND public.is_staff());

-- ============================================================================
-- SECTION: INDEXES (Includes V3.2 Optimizations)
-- ============================================================================

-- Basic Indexes
CREATE INDEX IF NOT EXISTS idx_products_brand_id ON public.products (brand_id);
CREATE INDEX IF NOT EXISTS idx_products_gender_id ON public.products (gender_id);
CREATE INDEX IF NOT EXISTS idx_products_perfume_type_id ON public.products (perfume_type_id);
CREATE INDEX IF NOT EXISTS idx_products_concentration_id ON public.products (concentration_id);
CREATE INDEX IF NOT EXISTS idx_products_slug ON public.products (slug);
CREATE INDEX IF NOT EXISTS idx_products_deleted_at ON public.products (deleted_at);
CREATE INDEX IF NOT EXISTS idx_product_variants_product_id ON public.product_variants (product_id);
CREATE INDEX IF NOT EXISTS idx_product_variants_sku ON public.product_variants (sku);
CREATE INDEX IF NOT EXISTS idx_product_variants_deleted_at ON public.product_variants (deleted_at);
CREATE INDEX IF NOT EXISTS idx_product_variants_price ON public.product_variants (price);
CREATE INDEX IF NOT EXISTS idx_product_variants_sale_price ON public.product_variants (sale_price);
CREATE INDEX IF NOT EXISTS idx_product_variants_stock_quantity ON public.product_variants (stock_quantity);
CREATE INDEX IF NOT EXISTS idx_product_variants_volume_ml ON public.product_variants (volume_ml);
CREATE INDEX IF NOT EXISTS idx_product_ingredients_product_id ON public.product_ingredients (product_id);
CREATE INDEX IF NOT EXISTS idx_product_ingredients_ingredient_id ON public.product_ingredients (ingredient_id);
CREATE INDEX IF NOT EXISTS idx_product_ingredients_scent_type ON public.product_ingredients (scent_type);
CREATE INDEX IF NOT EXISTS idx_product_ingredients_prod_ingr_type ON public.product_ingredients (product_id, ingredient_id, scent_type);
CREATE INDEX IF NOT EXISTS idx_product_categories_product_id ON public.product_categories (product_id);
CREATE INDEX IF NOT EXISTS idx_product_categories_category_id ON public.product_categories (category_id);
CREATE INDEX IF NOT EXISTS idx_product_images_product_id ON public.product_images (product_id);
CREATE INDEX IF NOT EXISTS idx_product_images_is_main ON public.product_images (is_main);
CREATE INDEX IF NOT EXISTS idx_product_label_assignments_product_id ON public.product_label_assignments (product_id);
CREATE INDEX IF NOT EXISTS idx_product_label_assignments_label_id ON public.product_label_assignments (label_id);
CREATE INDEX IF NOT EXISTS idx_product_label_assignments_valid_until ON public.product_label_assignments (valid_until);
CREATE INDEX IF NOT EXISTS idx_product_scents_product_id ON public.product_scents (product_id);
COMMENT ON INDEX public.idx_product_scents_product_id IS '[V3.2] Index tối ưu tìm kiếm nhóm hương theo sản phẩm.';
CREATE INDEX IF NOT EXISTS idx_product_scents_scent_id ON public.product_scents (scent_id);
COMMENT ON INDEX public.idx_product_scents_scent_id IS '[V3.2] Index tối ưu tìm kiếm sản phẩm theo nhóm hương.';
CREATE INDEX IF NOT EXISTS idx_cart_items_cart_id ON public.cart_items (cart_id);
CREATE INDEX IF NOT EXISTS idx_cart_items_variant_id ON public.cart_items (variant_id);
CREATE INDEX IF NOT EXISTS idx_orders_user_id ON public.orders (user_id);
CREATE INDEX IF NOT EXISTS idx_orders_assigned_shipper_id ON public.orders (assigned_shipper_id);
CREATE INDEX IF NOT EXISTS idx_orders_order_status_id ON public.orders (order_status_id);
CREATE INDEX IF NOT EXISTS idx_orders_payment_status ON public.orders (payment_status);
CREATE INDEX IF NOT EXISTS idx_orders_order_date ON public.orders (order_date DESC);
CREATE INDEX IF NOT EXISTS idx_orders_access_token ON public.orders (access_token);
CREATE INDEX IF NOT EXISTS idx_orders_cancelled_by ON public.orders (cancelled_by);
CREATE INDEX IF NOT EXISTS idx_orders_cancelled_by_user_id ON public.orders (cancelled_by_user_id);
CREATE INDEX IF NOT EXISTS idx_orders_completed_at ON public.orders (completed_at);
CREATE INDEX IF NOT EXISTS idx_orders_payment_method_id ON public.orders (payment_method_id);
CREATE INDEX IF NOT EXISTS idx_orders_delivery_failure_timestamp ON public.orders (delivery_failure_timestamp);
CREATE INDEX IF NOT EXISTS idx_order_items_order_id ON public.order_items (order_id);
CREATE INDEX IF NOT EXISTS idx_order_items_variant_id ON public.order_items (variant_id);
CREATE INDEX IF NOT EXISTS idx_payments_order_id ON public.payments (order_id);
CREATE INDEX IF NOT EXISTS idx_payments_transaction_id ON public.payments (transaction_id);
CREATE INDEX IF NOT EXISTS idx_payments_status ON public.payments (status);
CREATE INDEX IF NOT EXISTS idx_inventory_variant_id ON public.inventory (variant_id);
CREATE INDEX IF NOT EXISTS idx_inventory_timestamp ON public.inventory (timestamp DESC);
CREATE INDEX IF NOT EXISTS idx_reviews_product_id ON public.reviews (product_id);
CREATE INDEX IF NOT EXISTS idx_reviews_user_id ON public.reviews (user_id);
CREATE INDEX IF NOT EXISTS idx_reviews_is_approved ON public.reviews (is_approved);
CREATE INDEX IF NOT EXISTS idx_review_replies_review_id ON public.review_replies (review_id);
CREATE INDEX IF NOT EXISTS idx_wishlists_user_id ON public.wishlists (user_id);
CREATE INDEX IF NOT EXISTS idx_wishlists_product_id ON public.wishlists (product_id);
CREATE INDEX IF NOT EXISTS idx_admin_activity_log_admin_user_id ON public.admin_activity_log (admin_user_id);
CREATE INDEX IF NOT EXISTS idx_admin_activity_log_timestamp ON public.admin_activity_log (timestamp DESC);
CREATE INDEX IF NOT EXISTS idx_admin_activity_log_entity_id ON public.admin_activity_log (entity_type, entity_id);
CREATE INDEX IF NOT EXISTS idx_profiles_default_address_id ON public.profiles (default_address_id);
CREATE INDEX IF NOT EXISTS idx_addresses_user_id ON public.addresses (user_id);

-- [V3.2 FTS] GIN Index for Full-Text Search
DROP INDEX IF EXISTS idx_products_fts;
CREATE INDEX idx_products_fts ON public.products USING gin(fts);
COMMENT ON INDEX public.idx_products_fts IS '[V3.2 FTS] GIN index for fast full-text search on products.';

-- [V3.2 Filter Opt] Composite Indexes for Filtering product_variants
DROP INDEX IF EXISTS idx_pv_prod_active_stock;
CREATE INDEX idx_pv_prod_active_stock ON public.product_variants (product_id, deleted_at, stock_quantity) WHERE deleted_at IS NULL;
COMMENT ON INDEX public.idx_pv_prod_active_stock IS '[V3.2 Filter Opt] Helps quickly find in-stock variants for a specific product.';

DROP INDEX IF EXISTS idx_pv_prod_active_price_composite; -- Renamed for clarity
CREATE INDEX idx_pv_prod_active_price_composite ON public.product_variants (product_id, deleted_at, price, sale_price) WHERE deleted_at IS NULL;
COMMENT ON INDEX public.idx_pv_prod_active_price_composite IS '[V3.2 Filter Opt] Helps check price ranges (original and sale) for active variants.';

DROP INDEX IF EXISTS idx_pv_prod_active_on_sale;
CREATE INDEX idx_pv_prod_active_on_sale ON public.product_variants (product_id, deleted_at) WHERE deleted_at IS NULL AND sale_price IS NOT NULL AND sale_price < price;
COMMENT ON INDEX public.idx_pv_prod_active_on_sale IS '[V3.2 Filter Opt] Helps quickly check if a product has any active variant on sale.';

-- ============================================================================
-- SECTION: SEED DATA (Basic Setup Data) V3.2
-- Chèn dữ liệu cơ bản cần thiết.
-- ============================================================================

-- Seed Order Statuses
INSERT INTO public.order_statuses (name, description) VALUES
('Chờ xác nhận', 'Đơn hàng mới, chờ cửa hàng xác nhận.'),
('Đã xác nhận', 'Cửa hàng đã xác nhận đơn hàng, chờ xử lý.'),
('Đang xử lý', 'Đơn hàng đang được chuẩn bị tại kho.'),
('Đang giao', 'Đơn hàng đã được bàn giao cho người giao hàng nội bộ.'),
('Đã giao', 'Người giao hàng đã giao thành công tới khách.'),
('Đã hoàn thành', 'Khách hàng đã xác nhận nhận hàng hoặc tự động hoàn thành.'),
('Đã hủy', 'Đơn hàng đã bị hủy bởi khách hàng hoặc cửa hàng.')
ON CONFLICT (name) DO NOTHING;

-- Seed Payment Methods
INSERT INTO public.payment_methods (name, description, is_active) VALUES
('COD', 'Thanh toán khi nhận hàng', true),
('Momo QR', 'Thanh toán qua ví Momo bằng mã QR', true),
('Chuyển khoản ngân hàng', 'Chuyển khoản qua tài khoản ngân hàng', false) -- Mặc định tắt, bật nếu cần
ON CONFLICT (name) DO NOTHING;

-- Seed Shop Settings (Ví dụ - Thay bằng thông tin thật)
INSERT INTO public.shop_settings (id, shop_name, contact_email, contact_phone, default_shipping_fee, order_confirmation_sender_email, address) VALUES
(1, 'MyBeauty', 'vuducminh366@gmail.com', '0363625119', 0, 'vuducminh366@gmail.com', 'P.Dương Lâm, Văn Quán, Hà Đông, TP.Hà Nội')
ON CONFLICT (id) DO UPDATE SET
  shop_name = EXCLUDED.shop_name, contact_email = EXCLUDED.contact_email, contact_phone = EXCLUDED.contact_phone,
  default_shipping_fee = EXCLUDED.default_shipping_fee, order_confirmation_sender_email = EXCLUDED.order_confirmation_sender_email,
  address = EXCLUDED.address, updated_at = now();

-- Optional: Initial FTS population (Run *once* if you have existing data before applying the FTS trigger)
-- UPDATE public.products
-- SET fts = setweight(to_tsvector('simple', coalesce(unaccent(name),'')), 'A') ||
--           setweight(to_tsvector('simple', coalesce(unaccent(short_description),'')), 'B') ||
--           setweight(to_tsvector('simple', coalesce(unaccent(long_description),'')), 'C')
-- WHERE fts IS NULL;

-- ============================================================================
-- FINAL COMMENT: Setup Complete (V3.2 - Fixed Filtering & FTS).
--
-- This V3.2 script provides a robust and optimized foundation, featuring:
--   - Core functionalities from V3.
--   - Full-Text Search (FTS) for products.
--   - **Corrected and improved `filter_products` RPC using JSONB for safer dynamic filtering.**
--   - Optimized indexes for filtering performance.
--   - Explicit GRANT EXECUTE permissions for RPCs.
--   - Consolidated and cleaned-up function/trigger definitions.
--
-- REMEMBER THE CRITICAL NEXT STEPS:
-- 1.  Auth Role Configuration ('admin', 'staff', 'shipper' in User Metadata).
-- 2.  Shipper Assignment Logic (Admin UI/Backend).
-- 3.  Shipper Data Security (Recommended: VIEW/RPC for limited column access).
-- 4.  Backend Logic (Payment Webhooks, Emails).
-- 5.  Frontend Logic (Call RPCs, build UIs - **use the fixed `filter_products` RPC for PLP**).
-- 6.  Auto-Completion Cron Job (Optional: Edge Function).
-- 7.  **Seeding:** Consider running a separate script to populate sample data (brands, products, etc.) after this schema setup.
--
-- This script sets a strong, optimized foundation for your MyBeauty application.
-- ============================================================================
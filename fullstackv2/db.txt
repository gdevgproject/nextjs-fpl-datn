-- SUPABASE COMPLETE SETUP SCRIPT (Production Ready)
-- Tác giả: Vu Duc Minh - Ngày: 09/04/2025
--
-- MỤC TIÊU: Cung cấp một cấu trúc database hoàn chỉnh, an toàn, logic và
--           tối ưu hóa nghiệp vụ cho cửa hàng nước hoa trên Supabase.
--
-- CÁC TÍNH NĂNG CHÍNH (Kế thừa và Cải tiến):
--   - Quản lý sản phẩm chi tiết (thương hiệu, danh mục, thuộc tính, biến thể, hình ảnh...).
--   - Kim tự tháp hương (Note Pyramid) chính xác: Liên kết thành phần cụ thể với tầng hương (top/middle/base).
--   - Quản lý người dùng và địa chỉ.
--   - Giỏ hàng và quy trình đặt hàng.
--   - Xử lý đơn hàng với trạng thái chi tiết (tiếng Việt), có trigger logic chuyển trạng thái.
--   - Vai trò người giao hàng (Shipper) nội bộ: Gán đơn, phân quyền chặt chẽ, ghi nhận giao hàng thất bại.
--   - Hỗ trợ thanh toán COD (xác nhận bởi shipper) và Online (Momo QR, Chuyển khoản - cấu trúc sẵn sàng).
--   - Theo dõi lịch sử tồn kho chi tiết, có RPC điều chỉnh kho thủ công an toàn.
--   - Quản lý mã giảm giá.
--   - Đánh giá sản phẩm (có quy trình duyệt).
--   - Danh sách yêu thích.
--   - Tra cứu đơn hàng an toàn cho khách vãng lai qua email/token.
--   - Ghi log hoạt động của Admin/Staff chi tiết.
--   - Cài đặt chung cho cửa hàng.
--   - Tối ưu hóa hiệu năng với Indexes đầy đủ.
--   - Bảo mật với Row Level Security (RLS) chi tiết cho từng vai trò.
--   - Quản lý file với Storage Buckets & Policies.
--   - Trigger đảm bảo chỉ có 1 ảnh chính cho mỗi sản phẩm.
--
-- LƯU Ý QUAN TRỌNG CHO BACKEND DEVELOPER (V3):
--   - Cần cấu hình Roles ('admin', 'staff', 'shipper') trong Auth User Metadata.
--   - Logic Webhook (Momo, cổng thanh toán khác) để cập nhật thanh toán là BẮT BUỘC ở backend.
--   - Logic gửi Email (xác nhận đơn,...) là BẮT BUỘC ở backend.
--   - Logic gán đơn hàng cho Shipper (`assigned_shipper_id`) cần thực hiện qua Admin UI/Backend.
--   - Logic tự động hoàn thành đơn hàng sau X ngày cần Cron Job (Edge Function).
--   - **BẢO MẬT SHIPPER:** **KHUYẾN NGHỊ MẠNH MẼ** tạo VIEW hoặc RPC riêng trả về *chỉ các cột cần thiết* cho Shipper thay vì cho phép SELECT trực tiếp từ bảng `orders` qua RLS, để tránh lộ dữ liệu nhạy cảm (giá trị đơn hàng...).
--   - Sử dụng RPC `adjust_stock` cho mọi thao tác nhập/xuất/điều chỉnh kho thủ công.
-- ============================================================================

-- Required Extensions
create extension if not exists "uuid-ossp"; -- Cho phép tạo UUID tự động (vd: access_token).
create extension if not exists "unaccent"; -- Hỗ trợ tạo slug tiếng Việt tốt hơn (loại bỏ dấu).

-- ============================================================================
-- SECTION: TABLES (Database Structure)
-- Định nghĩa cấu trúc các bảng dữ liệu.
-- ============================================================================

-- Địa chỉ người dùng
create table public.addresses (
    id bigint generated by default as identity primary key,
    user_id uuid references auth.users on delete cascade not null, -- Liên kết chặt chẽ với user
    recipient_name text not null,
    recipient_phone text not null,
    province_city text not null,
    district text not null,
    ward text not null,
    street_address text not null,
    postal_code text, -- Mã bưu chính (tùy chọn ở VN)
    is_default boolean default false not null, -- Đánh dấu địa chỉ mặc định
    created_at timestamptz default now() not null,
    updated_at timestamptz default now() not null
);
comment on table public.addresses is '[V3] Lưu trữ các địa chỉ giao hàng/thanh toán của người dùng đã đăng nhập.';

-- Thông tin mở rộng của người dùng (liên kết với auth.users)
create table public.profiles (
    id uuid not null primary key references auth.users on delete cascade, -- Khóa chính trùng với auth.users.id
    display_name text, -- Tên hiển thị
    phone_number text, -- Số điện thoại (có thể khác SĐT nhận hàng)
    gender text, -- Giới tính
    birth_date date, -- Ngày sinh
    avatar_url text, -- Link ảnh đại diện trên Storage
    default_address_id bigint references public.addresses on delete set null, -- ID địa chỉ mặc định
    created_at timestamptz default now() not null,
    updated_at timestamptz default now() not null
);
comment on table public.profiles is '[V3] Bảng mở rộng thông tin cho auth.users, được tạo tự động khi có user mới.';

-- Thương hiệu nước hoa
create table public.brands (
    id bigint generated by default as identity primary key,
    name text unique not null, -- Tên thương hiệu (vd: Chanel), không trùng
    description text, -- Mô tả thương hiệu
    logo_url text, -- Link logo trên Storage
    created_at timestamptz default now() not null,
    updated_at timestamptz default now() not null
);
comment on table public.brands is '[V3] Quản lý danh sách các thương hiệu nước hoa.';

-- Giới tính (Áp dụng cho nước hoa)
create table public.genders (
    id smallint generated by default as identity primary key,
    name text unique not null, -- Ví dụ: Nam, Nữ, Unisex
    created_at timestamptz default now() not null,
    updated_at timestamptz default now() not null
);
comment on table public.genders is '[V3] Phân loại giới tính cho sản phẩm nước hoa.';

-- Loại nước hoa (phân khúc)
create table public.perfume_types (
    id smallint generated by default as identity primary key,
    name text unique not null, -- Ví dụ: Designer, Niche
    created_at timestamptz default now() not null,
    updated_at timestamptz default now() not null
);
comment on table public.perfume_types is '[V3] Phân loại nước hoa theo phân khúc (Designer, Niche...).';

-- Nồng độ tinh dầu
create table public.concentrations (
    id smallint generated by default as identity primary key,
    name text unique not null, -- Ví dụ: Eau de Parfum (EDP), Eau de Toilette (EDT)
    description text,
    created_at timestamptz default now() not null,
    updated_at timestamptz default now() not null
);
comment on table public.concentrations is '[V3] Phân loại nồng độ tinh dầu nước hoa.';

-- Danh mục sản phẩm (có thể phân cấp)
create table public.categories (
    id bigint generated by default as identity primary key,
    name text not null unique, -- Tên danh mục (vd: Nước hoa Nam, Nước hoa Nữ)
    slug text unique, -- Tên hiển thị trên URL (tự động tạo)
    description text, -- Mô tả danh mục
    image_url text, -- Link ảnh đại diện danh mục trên Storage
    is_featured boolean default false not null, -- Có hiển thị nổi bật không?
    display_order int default 0 not null, -- Thứ tự hiển thị (số nhỏ ưu tiên)
    parent_category_id bigint references public.categories on delete set null, -- Liên kết với danh mục cha (tạo cấu trúc cây)
    created_at timestamptz default now() not null,
    updated_at timestamptz default now() not null
);
comment on table public.categories is '[V3] Quản lý danh mục sản phẩm, hỗ trợ phân cấp cha-con.';

-- Sản phẩm nước hoa chính (Thông tin chung)
create table public.products (
    id bigint generated by default as identity primary key,
    name text not null, -- Tên dòng sản phẩm (vd: Dior Sauvage)
    slug text unique, -- Tên hiển thị trên URL (tự động tạo)
    product_code text, -- Mã sản phẩm chung (nếu có)
    short_description text, -- Mô tả ngắn
    long_description text, -- Mô tả chi tiết
    brand_id bigint references public.brands on delete set null, -- Liên kết thương hiệu
    gender_id smallint references public.genders on delete set null, -- Liên kết giới tính
    perfume_type_id smallint references public.perfume_types on delete set null, -- Liên kết loại nước hoa
    concentration_id smallint references public.concentrations on delete set null, -- Liên kết nồng độ
    origin_country text, -- Xuất xứ
    release_year smallint, -- Năm ra mắt
    style text, -- Phong cách (vd: Sang trọng, Quyến rũ)
    sillage text, -- Độ tỏa hương (vd: Gần, Vừa, Xa)
    longevity text, -- Độ lưu hương (vd: Kém, Tốt, Rất tốt)
    created_at timestamptz default now() not null,
    updated_at timestamptz default now() not null,
    deleted_at timestamptz -- Thời điểm xóa mềm (để ẩn sản phẩm thay vì xóa hẳn)
);
comment on table public.products is '[V3] Lưu thông tin cốt lõi của một dòng nước hoa. Giá và dung tích nằm ở product_variants. Kim tự tháp hương chi tiết nằm ở product_ingredients.';

-- Các nhóm mùi hương (Woody, Citrus, Floral...) - Dùng để phân loại/lọc chung
create table public.scents (
    id bigint generated by default as identity primary key,
    name text unique not null, -- Ví dụ: Hương Gỗ (Woody), Hương Hoa cỏ (Floral)
    description text,
    created_at timestamptz default now() not null,
    updated_at timestamptz default now() not null
);
comment on table public.scents is '[V3] Quản lý các nhóm mùi hương chính (vd: Woody, Floral). Dùng để phân loại sản phẩm ở mức độ tổng quát. Chi tiết tầng hương xem ở product_ingredients.';

-- Thành phần nước hoa (Note cụ thể)
create table public.ingredients (
    id bigint generated by default as identity primary key,
    name text unique not null, -- Ví dụ: Bergamot, Xạ hương trắng, Iso E Super, Hoa hồng
    created_at timestamptz default now() not null,
    updated_at timestamptz default now() not null
);
comment on table public.ingredients is '[V3] Quản lý danh sách các thành phần (note) cụ thể có thể có trong nước hoa.';

-- Phiên bản sản phẩm (Theo dung tích, giá, tồn kho)
create table public.product_variants (
    id bigint generated by default as identity primary key,
    product_id bigint not null references public.products on delete cascade, -- Liên kết với sản phẩm gốc
    volume_ml integer not null, -- Dung tích (vd: 50, 100)
    price numeric not null check (price >= 0), -- Giá gốc
    sale_price numeric check (sale_price >= 0), -- Giá khuyến mãi (nếu có)
    sku text unique, -- Mã SKU (Stock Keeping Unit) để quản lý kho, có thể hiển thị cho KH
    stock_quantity integer not null default 0 check (stock_quantity >= 0), -- **Số lượng tồn kho thực tế**
    created_at timestamptz default now() not null,
    updated_at timestamptz default now() not null,
    deleted_at timestamptz, -- Xóa mềm cho từng phiên bản
    constraint price_check check (sale_price is null or sale_price <= price) -- Đảm bảo giá sale không cao hơn giá gốc
);
comment on table public.product_variants is '[V3] Các phiên bản khác nhau của một sản phẩm (theo dung tích, giá). Đây là nơi quản lý tồn kho (`stock_quantity`).';

-- Liên kết Sản phẩm - Thành phần - Tầng hương (Kim tự tháp hương chi tiết)
create table public.product_ingredients (
    id bigint generated by default as identity primary key,
    product_id bigint not null references public.products on delete cascade,
    ingredient_id bigint not null references public.ingredients on delete cascade,
    scent_type text not null check (scent_type in ('top', 'middle', 'base')), -- Phân loại tầng hương của thành phần này trong sản phẩm này
    -- Một thành phần có thể xuất hiện ở nhiều tầng hương (hiếm), nên unique cần cả 3 cột
    constraint product_ingredients_product_id_ingredient_id_scent_type_key unique (product_id, ingredient_id, scent_type)
    -- created_at, updated_at không thực sự cần thiết ở bảng N-N này
);
comment on table public.product_ingredients is '[V3] Bảng N-N cốt lõi cho Kim tự tháp hương. Liên kết sản phẩm với thành phần cụ thể và xác định tầng hương (top, middle, base) của thành phần đó trong sản phẩm.';
comment on column public.product_ingredients.scent_type is 'Tầng hương (top, middle, base) mà thành phần (ingredient_id) này đóng góp trong sản phẩm (product_id) này.';

-- Hình ảnh sản phẩm
create table public.product_images (
    id bigint generated by default as identity primary key,
    product_id bigint not null references public.products on delete cascade, -- Liên kết với sản phẩm
    image_url text not null, -- Link ảnh trên Storage
    alt_text text, -- Mô tả ảnh (cho SEO và người dùng khiếm thị)
    is_main boolean default false not null, -- Đánh dấu ảnh đại diện chính (Trigger sẽ đảm bảo chỉ có 1 ảnh main)
    display_order int default 0 not null, -- Thứ tự hiển thị ảnh
    created_at timestamptz default now() not null,
    updated_at timestamptz default now() not null
);
comment on table public.product_images is '[V3] Quản lý nhiều hình ảnh cho một sản phẩm. Có trigger đảm bảo chỉ 1 ảnh chính.';

-- Liên kết Sản phẩm - Danh mục (Bảng trung gian N-N)
create table public.product_categories (
    id bigint generated by default as identity primary key,
    product_id bigint not null references public.products on delete cascade,
    category_id bigint not null references public.categories on delete cascade,
    unique (product_id, category_id) -- Một sản phẩm có thể thuộc nhiều danh mục
);
comment on table public.product_categories is '[V3] Liên kết sản phẩm với các danh mục mà nó thuộc về.';

-- Nhãn sản phẩm (Tags)
create table public.product_labels (
    id bigint generated by default as identity primary key,
    name text unique not null, -- Ví dụ: Hàng mới, Giảm giá, Bán chạy
    color_code varchar(7), -- Mã màu hiển thị (vd: #FF0000)
    created_at timestamptz default now() not null,
    updated_at timestamptz default now() not null
);
comment on table public.product_labels is '[V3] Định nghĩa các loại nhãn có thể gắn lên sản phẩm.';

-- Gán nhãn cho sản phẩm (Có thời hạn)
create table public.product_label_assignments (
    id bigint generated by default as identity primary key,
    product_id bigint not null references public.products on delete cascade, -- Sản phẩm được gán
    label_id bigint not null references public.product_labels on delete cascade, -- Nhãn được gán
    valid_until timestamptz, -- Ngày hết hạn của nhãn (vd: nhãn "Sale" chỉ có hiệu lực đến ngày X)
    unique (product_id, label_id) -- Mỗi sản phẩm chỉ được gán 1 loại nhãn 1 lần
);
comment on table public.product_label_assignments is '[V3] Gán nhãn cụ thể cho sản phẩm, có thể có thời hạn.';

-- Mã giảm giá
create table public.discounts (
    id bigint generated by default as identity primary key,
    code text unique not null, -- Mã code người dùng nhập (vd: TET2025)
    description text, -- Mô tả chương trình giảm giá
    start_date timestamptz, -- Ngày bắt đầu hiệu lực (NULL nếu không giới hạn)
    end_date timestamptz, -- Ngày kết thúc hiệu lực (NULL nếu không giới hạn)
    max_uses integer check (max_uses is null or max_uses >= 0), -- Tổng số lượt sử dụng tối đa
    remaining_uses integer check (remaining_uses is null or remaining_uses >= 0), -- Số lượt sử dụng còn lại
    min_order_value numeric check (min_order_value is null or min_order_value >= 0), -- Giá trị đơn hàng tối thiểu để áp dụng
    max_discount_amount numeric check (max_discount_amount is null or max_discount_amount >= 0), -- Số tiền giảm tối đa (quan trọng cho mã %)
    discount_percentage numeric check (discount_percentage is null or (discount_percentage > 0 and discount_percentage <= 100)), -- Tỷ lệ % giảm (NULL nếu giảm tiền cố định)
    is_active boolean default true not null, -- Mã có đang hoạt động không?
    created_at timestamptz default now() not null,
    updated_at timestamptz default now() not null
);
comment on table public.discounts is '[V3] Quản lý các mã giảm giá và điều kiện áp dụng.';

-- Giỏ hàng (Mỗi user đăng nhập có 1 giỏ)
create table public.shopping_carts (
    id bigint generated by default as identity primary key,
    user_id uuid references auth.users on delete cascade unique not null, -- Liên kết duy nhất với user
    created_at timestamptz default now() not null,
    updated_at timestamptz default now() not null
);
comment on table public.shopping_carts is '[V3] Đại diện cho giỏ hàng của mỗi người dùng đã đăng nhập.';

-- Các sản phẩm trong giỏ hàng
create table public.cart_items (
    id bigint generated by default as identity primary key,
    cart_id bigint not null references public.shopping_carts on delete cascade, -- Thuộc giỏ hàng nào
    variant_id bigint not null references public.product_variants on delete cascade, -- Sản phẩm (biến thể cụ thể) trong giỏ
    quantity integer not null check (quantity > 0), -- Số lượng
    created_at timestamptz default now() not null,
    updated_at timestamptz default now() not null,
    unique(cart_id, variant_id) -- Không cho phép thêm trùng biến thể vào cùng giỏ hàng
);
comment on table public.cart_items is '[V3] Chi tiết các sản phẩm (biến thể) và số lượng trong một giỏ hàng.';

-- Trạng thái đơn hàng (Tiếng Việt)
create table public.order_statuses (
    id smallint generated by default as identity primary key,
    name text unique not null, -- Tên trạng thái (vd: Chờ xác nhận)
    description text -- Mô tả chi tiết trạng thái (nếu cần)
);
comment on table public.order_statuses is '[V3] Danh sách các trạng thái xử lý đơn hàng (tiếng Việt).';

-- Phương thức thanh toán
create table public.payment_methods (
    id smallint generated by default as identity primary key,
    name text unique not null, -- Tên phương thức (vd: COD, Momo QR)
    description text, -- Mô tả
    is_active boolean default true not null -- Có đang được sử dụng không?
);
comment on table public.payment_methods is '[V3] Danh sách các phương thức thanh toán được chấp nhận.';

-- Đơn hàng
create table public.orders (
    id bigint generated by default as identity primary key, -- ID nội bộ của đơn hàng, dùng cho Shipper tham chiếu
    access_token uuid not null default uuid_generate_v4() unique, -- Mã bí mật để khách VÃNG LAI tra cứu đơn hàng qua link email/web
    user_id uuid references auth.users on delete set null, -- ID người dùng nếu đặt hàng khi đăng nhập (NULL nếu là khách)
    assigned_shipper_id uuid references auth.users on delete set null, -- ID của người giao hàng (user có role 'shipper') được GÁN cho đơn này. **BACKEND/ADMIN UI cần set giá trị này.**
    -- Thông tin khách vãng lai (nếu user_id là NULL)
    guest_name text,
    guest_email text,
    guest_phone text,
    -- Thông tin giao hàng (sao chép tại thời điểm đặt hàng để không bị ảnh hưởng nếu địa chỉ gốc thay đổi)
    recipient_name text not null,
    recipient_phone text not null,
    province_city text not null,
    district text not null,
    ward text not null,
    street_address text not null,
    -- Chi tiết đơn hàng
    order_date timestamptz default now() not null, -- Ngày đặt hàng
    delivery_notes text, -- Ghi chú giao hàng từ khách
    payment_method_id smallint references public.payment_methods(id), -- Phương thức thanh toán đã chọn
    payment_status text check (payment_status in ('Pending', 'Paid', 'Failed')) default 'Pending' not null, -- Trạng thái thanh toán TỔNG THỂ của đơn hàng. **BACKEND (webhook) cập nhật cho đơn online, RPC (confirm_cod/confirm_bank) cập nhật cho COD/Bank.**
    order_status_id smallint references public.order_statuses(id), -- Trạng thái xử lý đơn hàng (vd: Chờ xác nhận, Đang giao...). **Admin/Shipper/User cập nhật qua RPC.**
    discount_id bigint references public.discounts on delete set null, -- Mã giảm giá đã áp dụng (nếu có)
    subtotal_amount numeric not null default 0 check (subtotal_amount >= 0), -- Tổng tiền hàng (trước thuế, giảm giá, ship)
    discount_amount numeric default 0 check (discount_amount >= 0), -- Số tiền được giảm giá
    shipping_fee numeric default 0 check (shipping_fee >= 0), -- Phí vận chuyển
    total_amount numeric not null default 0 check (total_amount >= 0), -- Tổng tiền cuối cùng khách phải trả
    -- Thông tin hủy đơn
    cancellation_reason text, -- Lý do hủy đơn (nếu bị hủy)
    cancelled_by text check (cancelled_by in ('user', 'admin')), -- Ai là người khởi tạo hủy (user hoặc admin/staff) - Để phân loại nhanh
    cancelled_by_user_id uuid references auth.users on delete set null, -- ID CỤ THỂ của user/admin/staff đã hủy đơn
    -- Thông tin giao hàng thất bại (Shipper ghi nhận)
    delivery_failure_reason text, -- Lý do giao hàng thất bại (do shipper ghi nhận lần gần nhất)
    delivery_failure_timestamp timestamptz, -- Thời điểm ghi nhận giao hàng thất bại lần gần nhất
    -- Thông tin hoàn thành
    completed_at timestamptz, -- Thời điểm khách hàng xác nhận đã nhận hàng/đơn hàng hoàn thành
    -- Timestamps
    created_at timestamptz default now() not null,
    updated_at timestamptz default now() not null
);
comment on table public.orders is '[V3] Bảng trung tâm lưu trữ mọi thông tin về đơn hàng của khách. Bao gồm gán shipper và ghi nhận giao hàng thất bại.';
comment on column public.orders.delivery_failure_reason is 'Lý do giao hàng thất bại (do shipper ghi nhận lần gần nhất)';
comment on column public.orders.delivery_failure_timestamp is 'Thời điểm ghi nhận giao hàng thất bại lần gần nhất';


-- Chi tiết các sản phẩm trong đơn hàng
create table public.order_items (
    id bigint generated by default as identity primary key,
    order_id bigint not null references public.orders on delete cascade, -- Thuộc đơn hàng nào
    variant_id bigint not null references public.product_variants on delete restrict, -- Liên kết đến biến thể sản phẩm cụ thể. **ON DELETE RESTRICT: Ngăn xóa biến thể nếu đã có trong đơn hàng -> Đảm bảo toàn vẹn lịch sử.**
    -- Sao chép thông tin sản phẩm tại thời điểm đặt hàng
    product_name text not null, -- Tên sản phẩm lúc đặt
    variant_volume_ml integer not null, -- Dung tích lúc đặt
    quantity integer not null check (quantity > 0), -- Số lượng
    unit_price_at_order numeric not null check (unit_price_at_order >= 0), -- Giá bán của 1 sản phẩm lúc đặt
    -- Timestamps
    created_at timestamptz default now() not null,
    updated_at timestamptz default now() not null
);
comment on table public.order_items is '[V3] Lưu chi tiết từng sản phẩm (biến thể), số lượng, giá tại thời điểm đặt trong một đơn hàng.';

-- Thông tin thanh toán chi tiết (Giao dịch cụ thể)
create table public.payments (
    id bigint generated by default as identity primary key,
    order_id bigint not null references public.orders on delete cascade, -- Liên kết với đơn hàng
    payment_date timestamptz default now() not null, -- Thời điểm giao dịch
    payment_method_id smallint references public.payment_methods(id), -- Phương thức dùng cho giao dịch này
    transaction_id text, -- Mã giao dịch từ cổng thanh toán (Momo, VNPAY...) hoặc mã tham chiếu Chuyển khoản. **QUAN TRỌNG để đối soát.**
    amount numeric not null check (amount >= 0), -- Số tiền của giao dịch này
    status text check (status in ('Pending', 'Completed', 'Failed')) default 'Pending' not null, -- Trạng thái của GIAO DỊCH này (vd: một lần thử thanh toán Momo). **BACKEND (webhook/RPC) cập nhật.**
    payment_details jsonb, -- Lưu trữ dữ liệu JSON trả về từ cổng thanh toán (nếu có)
    created_at timestamptz default now() not null,
    updated_at timestamptz default now() not null
);
comment on table public.payments is '[V3] Chi tiết từng giao dịch thanh toán (đặc biệt cho online). Một đơn hàng có thể có nhiều giao dịch (thử lại). `status` ở đây là của giao dịch, `orders.payment_status` là tổng thể.';

-- Lịch sử thay đổi kho hàng (Log)
create table public.inventory (
    id bigint generated by default as identity primary key,
    variant_id bigint not null references public.product_variants on delete cascade, -- Biến thể nào bị thay đổi
    change_amount integer not null, -- Số lượng thay đổi (+ là nhập, - là xuất). Phải khác 0.
    reason text not null, -- Lý do thay đổi (vd: 'Đơn hàng đã giao', 'Điều chỉnh kho', 'Nhập hàng'). **Bắt buộc.**
    order_id bigint references public.orders on delete set null, -- Liên kết đến đơn hàng nếu lý do là bán hàng
    stock_after_change integer not null, -- Số lượng tồn kho SAU KHI thay đổi (để dễ truy vết). **Bắt buộc.**
    updated_by uuid references auth.users on delete set null, -- ID người dùng nếu là ĐIỀU CHỈNH THỦ CÔNG bởi admin/staff (qua RPC `adjust_stock`). **NULL nếu là hành động hệ thống (vd: bán hàng).**
    timestamp timestamptz default now() not null, -- Thời điểm ghi log
    created_at timestamptz default now() not null,
    updated_at timestamptz default now() not null,
    constraint inventory_change_amount_check check (change_amount != 0), -- Không ghi log nếu không thay đổi
    constraint inventory_stock_after_change_check check (stock_after_change >= 0) -- Tồn kho không được âm (RPC adjust_stock cũng kiểm tra)
);
comment on table public.inventory is '[V3] Nhật ký ghi lại mọi thay đổi về số lượng tồn kho của các biến thể sản phẩm. Giúp truy vết xuất nhập tồn. Nên được cập nhật qua trigger hoặc RPC `adjust_stock`.';
comment on column public.inventory.reason is 'Lý do thay đổi tồn kho (BẮT BUỘC)';
comment on column public.inventory.stock_after_change is 'Số lượng tồn kho SAU KHI thay đổi (BẮT BUỘC, không âm)';
comment on column public.inventory.updated_by is 'Admin/Staff thực hiện điều chỉnh thủ công (NULL nếu là hệ thống)';


-- Đánh giá sản phẩm
create table public.reviews (
    id bigint generated by default as identity primary key,
    product_id bigint not null references public.products on delete cascade, -- Đánh giá cho sản phẩm nào
    user_id uuid not null references auth.users on delete cascade, -- Ai là người đánh giá
    order_item_id bigint references public.order_items on delete set null, -- (Tùy chọn) Liên kết đến item đã mua để xác thực
    rating smallint not null check (rating >= 1 and rating <= 5), -- Điểm đánh giá (1-5 sao)
    comment text, -- Nội dung bình luận
    is_approved boolean default false not null, -- Trạng thái duyệt (Admin/Staff duyệt)
    approved_by uuid references auth.users on delete set null, -- ID Admin/Staff đã duyệt
    approved_at timestamptz, -- Thời điểm duyệt
    created_at timestamptz default now() not null,
    updated_at timestamptz default now() not null,
    unique(user_id, product_id) -- Mỗi user chỉ đánh giá 1 lần cho 1 sản phẩm
);
comment on table public.reviews is '[V3] Lưu trữ đánh giá của khách hàng về sản phẩm, cần được duyệt trước khi hiển thị công khai.';

-- Phản hồi đánh giá (từ Admin/Staff)
create table public.review_replies (
    id bigint generated by default as identity primary key,
    review_id bigint not null references public.reviews on delete cascade, -- Trả lời cho đánh giá nào
    staff_id uuid not null references auth.users on delete cascade, -- ID Admin/Staff trả lời (RLS sẽ kiểm tra quyền staff/admin)
    reply_text text not null, -- Nội dung phản hồi
    created_at timestamptz default now() not null,
    updated_at timestamptz default now() not null
);
comment on table public.review_replies is '[V3] Lưu trữ các phản hồi của Admin/Staff đối với đánh giá của khách hàng.';

-- Danh sách yêu thích của người dùng
create table public.wishlists (
    id bigint generated by default as identity primary key,
    user_id uuid not null references auth.users on delete cascade, -- User sở hữu wishlist
    product_id bigint not null references public.products on delete cascade, -- Sản phẩm được yêu thích (lưu sản phẩm gốc, không phải biến thể). ON DELETE CASCADE: Nếu sản phẩm bị xóa cứng, wishlist item cũng mất.
    added_at timestamptz default now() not null, -- Thời điểm thêm vào
    unique (user_id, product_id) -- Mỗi user chỉ yêu thích 1 sản phẩm 1 lần
);
comment on table public.wishlists is '[V3] Lưu danh sách các sản phẩm mà người dùng đánh dấu yêu thích. Xử lý sản phẩm soft-delete ở Frontend.';

-- Log hoạt động của Admin/Staff
create table public.admin_activity_log (
    id bigint generated by default as identity primary key,
    admin_user_id uuid references auth.users on delete set null, -- ID Admin/Staff thực hiện hành động
    activity_type text not null, -- Loại hành động (vd: PRODUCT_UPDATE, ORDER_CANCELLED_BY_ADMIN, STOCK_ADJUSTMENT)
    description text, -- Mô tả chi tiết hành động
    entity_type text, -- Loại đối tượng bị tác động (vd: 'product', 'order', 'product_variant')
    entity_id text, -- ID của đối tượng bị tác động
    details jsonb, -- Lưu dữ liệu chi tiết (vd: dữ liệu cũ/mới, lý do)
    timestamp timestamptz default now() not null -- Thời điểm thực hiện
);
comment on table public.admin_activity_log is '[V3] Nhật ký ghi lại các hành động quan trọng do Admin/Staff thực hiện trên hệ thống (qua trigger hoặc RPC).';

-- Banner quảng cáo
create table public.banners (
    id bigint generated by default as identity primary key,
    title text not null, -- Tiêu đề banner
    subtitle text, -- Tiêu đề phụ (nếu có)
    image_url text not null, -- Link ảnh banner trên Storage
    link_url text, -- Link đích khi click vào banner
    is_active boolean default true not null, -- Banner có đang hiển thị không?
    display_order int default 0 not null, -- Thứ tự hiển thị
    start_date timestamptz, -- Ngày bắt đầu hiển thị (NULL nếu không giới hạn)
    end_date timestamptz, -- Ngày kết thúc hiển thị (NULL nếu không giới hạn)
    created_at timestamptz default now() not null,
    updated_at timestamptz default now() not null
);
comment on table public.banners is '[V3] Quản lý các banner quảng cáo hiển thị trên website.';

-- Cài đặt chung của cửa hàng (Chỉ có 1 dòng duy nhất)
create table public.shop_settings (
    id smallint primary key default 1, -- Luôn là 1 để đảm bảo chỉ có 1 dòng
    shop_name text not null, -- Tên cửa hàng
    shop_logo_url text, -- Link logo chính trên Storage
    contact_email text, -- Email liên hệ
    contact_phone text, -- SĐT liên hệ
    address text, -- Địa chỉ cửa hàng (nếu có)
    -- Các link mạng xã hội
    facebook_url text,
    messenger_url text,
    zalo_url text,
    instagram_url text,
    tiktok_url text,
    youtube_url text,
    -- Nội dung các chính sách (có thể lưu text hoặc HTML)
    refund_policy_text text,
    shipping_policy_text text,
    privacy_policy_text text,
    terms_conditions_text text,
    -- Cấu hình mặc định
    default_shipping_fee numeric default 0 check (default_shipping_fee >= 0) not null, -- Phí ship mặc định
    order_confirmation_sender_email text, -- Email dùng để gửi xác nhận đơn hàng. **BACKEND sử dụng giá trị này.**
    -- Timestamps
    created_at timestamptz default now() not null,
    updated_at timestamptz default now() not null,
    constraint single_row check (id = 1) -- Ràng buộc chỉ cho phép dòng có id = 1
);
comment on table public.shop_settings is '[V3] Lưu trữ các cài đặt và thông tin chung của toàn bộ cửa hàng (tên, logo, liên hệ, chính sách, phí ship mặc định...). Chỉ có 1 dòng dữ liệu.';

-- ============================================================================
-- SECTION: ROW LEVEL SECURITY (RLS) - Kích hoạt và định nghĩa chính sách V3
-- Kích hoạt RLS cho tất cả các bảng để bảo mật dữ liệu.
-- ============================================================================

alter table public.addresses enable row level security;
alter table public.profiles enable row level security;
alter table public.brands enable row level security;
alter table public.genders enable row level security;
alter table public.perfume_types enable row level security;
alter table public.concentrations enable row level security;
alter table public.categories enable row level security;
alter table public.products enable row level security;
alter table public.scents enable row level security; -- Bảng nhóm hương
alter table public.ingredients enable row level security; -- Bảng thành phần
alter table public.product_variants enable row level security;
alter table public.product_ingredients enable row level security; -- Bảng liên kết thành phần - tầng hương
alter table public.product_images enable row level security;
alter table public.product_categories enable row level security;
alter table public.product_labels enable row level security;
alter table public.product_label_assignments enable row level security;
alter table public.discounts enable row level security;
alter table public.shopping_carts enable row level security;
alter table public.cart_items enable row level security;
alter table public.order_statuses enable row level security;
alter table public.payment_methods enable row level security;
alter table public.orders enable row level security;
alter table public.order_items enable row level security;
alter table public.payments enable row level security;
alter table public.inventory enable row level security;
alter table public.reviews enable row level security;
alter table public.review_replies enable row level security;
alter table public.wishlists enable row level security;
alter table public.admin_activity_log enable row level security;
alter table public.banners enable row level security;
alter table public.shop_settings enable row level security;

-- ============================================================================
-- SECTION: FUNCTIONS & TRIGGERS (Tự động hóa & Hàm hỗ trợ) V3
-- Các hàm và trigger giúp tự động hóa các tác vụ và kiểm tra logic.
-- ============================================================================

-- FUNCTION: Tự động tạo profile khi user mới đăng ký
DROP FUNCTION IF EXISTS public.handle_new_user();
CREATE OR REPLACE FUNCTION public.handle_new_user()
RETURNS TRIGGER SECURITY DEFINER SET search_path = public AS $$
BEGIN
  -- Chèn bản ghi mới vào profiles, lấy thông tin từ metadata user gửi lên khi đăng ký
  INSERT INTO public.profiles (id, display_name, phone_number)
  VALUES (NEW.id, NEW.raw_user_meta_data->>'display_name', NEW.raw_user_meta_data->>'phone_number');
  RETURN NEW;
END;
$$ LANGUAGE plpgsql;
comment on function public.handle_new_user() is '[V3] Tự động tạo bản ghi trong public.profiles khi có người dùng mới trong auth.users.';

-- TRIGGER: Gọi hàm handle_new_user sau khi user được tạo
DROP TRIGGER IF EXISTS on_auth_user_created_profile ON auth.users;
CREATE TRIGGER on_auth_user_created_profile
AFTER INSERT ON auth.users FOR EACH ROW EXECUTE PROCEDURE public.handle_new_user();

-- FUNCTION: Tự động tạo giỏ hàng cho user mới
DROP FUNCTION IF EXISTS public.create_shopping_cart_for_new_user();
CREATE OR REPLACE FUNCTION public.create_shopping_cart_for_new_user()
RETURNS TRIGGER SECURITY DEFINER SET search_path = public AS $$
BEGIN
  -- Chèn giỏ hàng trống liên kết với user mới
  INSERT INTO public.shopping_carts (user_id) VALUES (NEW.id);
  RETURN NEW;
END;
$$ LANGUAGE plpgsql;
comment on function public.create_shopping_cart_for_new_user() is '[V3] Tự động tạo giỏ hàng trống (shopping_carts) cho người dùng mới.';

-- TRIGGER: Gọi hàm create_shopping_cart_for_new_user sau khi user được tạo
DROP TRIGGER IF EXISTS on_auth_user_created_cart ON auth.users;
CREATE TRIGGER on_auth_user_created_cart
AFTER INSERT ON auth.users FOR EACH ROW EXECUTE PROCEDURE public.create_shopping_cart_for_new_user();

-- FUNCTION: Tự động cập nhật trường 'updated_at'
DROP FUNCTION IF EXISTS public.handle_updated_at();
create or replace function public.handle_updated_at()
returns trigger security definer set search_path = public as $$
begin
  -- Gán thời gian hiện tại cho cột updated_at mỗi khi có update
  new.updated_at = now();
  return new;
end;
$$ language plpgsql;
comment on function public.handle_updated_at() is '[V3] Tự động cập nhật trường updated_at thành thời gian hiện tại khi bản ghi được cập nhật.';

-- TRIGGERS: Áp dụng hàm handle_updated_at cho các bảng cần thiết
-- (Gắn trigger này vào TẤT CẢ các bảng có cột updated_at)
-- (Lưu ý: Bảng product_ingredients và product_categories không có updated_at)
DROP TRIGGER IF EXISTS set_updated_at ON public.addresses; create trigger set_updated_at before update on public.addresses for each row execute procedure public.handle_updated_at();
DROP TRIGGER IF EXISTS set_updated_at ON public.profiles; create trigger set_updated_at before update on public.profiles for each row execute procedure public.handle_updated_at();
DROP TRIGGER IF EXISTS set_updated_at ON public.brands; create trigger set_updated_at before update on public.brands for each row execute procedure public.handle_updated_at();
DROP TRIGGER IF EXISTS set_updated_at ON public.genders; create trigger set_updated_at before update on public.genders for each row execute procedure public.handle_updated_at();
DROP TRIGGER IF EXISTS set_updated_at ON public.perfume_types; create trigger set_updated_at before update on public.perfume_types for each row execute procedure public.handle_updated_at();
DROP TRIGGER IF EXISTS set_updated_at ON public.concentrations; create trigger set_updated_at before update on public.concentrations for each row execute procedure public.handle_updated_at();
DROP TRIGGER IF EXISTS set_updated_at ON public.categories; create trigger set_updated_at before update on public.categories for each row execute procedure public.handle_updated_at();
DROP TRIGGER IF EXISTS set_updated_at ON public.products; create trigger set_updated_at before update on public.products for each row execute procedure public.handle_updated_at();
DROP TRIGGER IF EXISTS set_updated_at ON public.scents; create trigger set_updated_at before update on public.scents for each row execute procedure public.handle_updated_at();
DROP TRIGGER IF EXISTS set_updated_at ON public.ingredients; create trigger set_updated_at before update on public.ingredients for each row execute procedure public.handle_updated_at();
DROP TRIGGER IF EXISTS set_updated_at ON public.product_variants; create trigger set_updated_at before update on public.product_variants for each row execute procedure public.handle_updated_at();
DROP TRIGGER IF EXISTS set_updated_at ON public.product_images; create trigger set_updated_at before update on public.product_images for each row execute procedure public.handle_updated_at();
DROP TRIGGER IF EXISTS set_updated_at ON public.product_labels; create trigger set_updated_at before update on public.product_labels for each row execute procedure public.handle_updated_at();
-- product_label_assignments không có updated_at
DROP TRIGGER IF EXISTS set_updated_at ON public.discounts; create trigger set_updated_at before update on public.discounts for each row execute procedure public.handle_updated_at();
DROP TRIGGER IF EXISTS set_updated_at ON public.shopping_carts; create trigger set_updated_at before update on public.shopping_carts for each row execute procedure public.handle_updated_at();
DROP TRIGGER IF EXISTS set_updated_at ON public.cart_items; create trigger set_updated_at before update on public.cart_items for each row execute procedure public.handle_updated_at();
-- order_statuses không có updated_at
-- payment_methods không có updated_at
DROP TRIGGER IF EXISTS set_updated_at ON public.orders; create trigger set_updated_at before update on public.orders for each row execute procedure public.handle_updated_at();
DROP TRIGGER IF EXISTS set_updated_at ON public.order_items; create trigger set_updated_at before update on public.order_items for each row execute procedure public.handle_updated_at();
DROP TRIGGER IF EXISTS set_updated_at ON public.payments; create trigger set_updated_at before update on public.payments for each row execute procedure public.handle_updated_at();
DROP TRIGGER IF EXISTS set_updated_at ON public.inventory; create trigger set_updated_at before update on public.inventory for each row execute procedure public.handle_updated_at();
DROP TRIGGER IF EXISTS set_updated_at ON public.reviews; create trigger set_updated_at before update on public.reviews for each row execute procedure public.handle_updated_at();
DROP TRIGGER IF EXISTS set_updated_at ON public.review_replies; create trigger set_updated_at before update on public.review_replies for each row execute procedure public.handle_updated_at();
-- wishlists không có updated_at
-- admin_activity_log không có updated_at
DROP TRIGGER IF EXISTS set_updated_at ON public.banners; create trigger set_updated_at before update on public.banners for each row execute procedure public.handle_updated_at();
DROP TRIGGER IF EXISTS set_updated_at ON public.shop_settings; create trigger set_updated_at before update on public.shop_settings for each row execute procedure public.handle_updated_at();


-- FUNCTION: Lấy vai trò (role) của người dùng hiện tại từ Auth Metadata
DROP FUNCTION IF EXISTS public.get_auth_role();
CREATE OR REPLACE FUNCTION public.get_auth_role()
RETURNS TEXT LANGUAGE sql STABLE SECURITY DEFINER SET search_path = public AS $$
  -- Trả về 'anon' nếu chưa đăng nhập
  -- Trả về giá trị của 'role' trong raw_app_meta_data nếu có (vd: 'admin', 'staff', 'shipper')
  -- Trả về 'authenticated' nếu đã đăng nhập nhưng không có role cụ thể trong metadata
  SELECT CASE
    WHEN auth.uid() IS NULL THEN 'anon'
    ELSE coalesce((SELECT raw_app_meta_data->>'role' FROM auth.users WHERE id = auth.uid()), 'authenticated')
  END;
$$;
comment on function public.get_auth_role() is '[V3] Lấy vai trò người dùng (admin, staff, shipper, authenticated, anon) từ auth.users.raw_app_meta_data. Cần quyền SECURITY DEFINER. **Backend/Admin cần set role này trong metadata user.**';

-- FUNCTION: Kiểm tra người dùng hiện tại có phải là Admin không
DROP FUNCTION IF EXISTS public.is_admin();
CREATE OR REPLACE FUNCTION public.is_admin()
RETURNS BOOLEAN LANGUAGE sql STABLE SECURITY DEFINER SET search_path = public
AS $$ SELECT public.get_auth_role() = 'admin'; $$;
comment on function public.is_admin() is '[V3] Hàm tiện ích kiểm tra người dùng hiện tại có vai trò "admin" không.';

-- FUNCTION: Kiểm tra người dùng hiện tại có phải là Staff hoặc Admin không
DROP FUNCTION IF EXISTS public.is_staff();
CREATE OR REPLACE FUNCTION public.is_staff()
RETURNS BOOLEAN LANGUAGE sql STABLE SECURITY DEFINER SET search_path = public
AS $$ SELECT public.get_auth_role() IN ('staff', 'admin'); $$;
comment on function public.is_staff() is '[V3] Hàm tiện ích kiểm tra người dùng hiện tại có vai trò "staff" hoặc "admin" không.';

-- FUNCTION: Kiểm tra người dùng hiện tại có phải là Shipper không
DROP FUNCTION IF EXISTS public.is_shipper();
CREATE OR REPLACE FUNCTION public.is_shipper()
RETURNS BOOLEAN LANGUAGE sql STABLE SECURITY DEFINER SET search_path = public
AS $$ SELECT public.get_auth_role() = 'shipper'; $$;
comment on function public.is_shipper() is '[V3] Hàm tiện ích kiểm tra người dùng hiện tại có vai trò "shipper" không.';


-- FUNCTION: Kiểm tra user đã mua sản phẩm này chưa (dựa trên đơn đã giao/hoàn thành)
DROP FUNCTION IF EXISTS public.has_user_purchased_product(bigint);
CREATE OR REPLACE FUNCTION public.has_user_purchased_product(p_product_id bigint)
RETURNS boolean LANGUAGE plpgsql STABLE SECURITY DEFINER SET search_path = public AS $$
DECLARE completed_status_ids smallint[];
BEGIN
  -- Lấy ID các trạng thái được coi là đã mua thành công
  SELECT array_agg(id) INTO completed_status_ids FROM public.order_statuses WHERE name IN ('Đã giao', 'Đã hoàn thành');
  -- Kiểm tra xem có tồn tại item thuộc đơn hàng của user, đã hoàn thành, và khớp product_id không
  RETURN EXISTS (
    SELECT 1
    FROM public.orders o
    JOIN public.order_items oi ON o.id = oi.order_id
    JOIN public.product_variants pv ON oi.variant_id = pv.id
    WHERE o.user_id = auth.uid() -- Chỉ kiểm tra user đang đăng nhập
      AND pv.product_id = p_product_id -- Khớp sản phẩm gốc
      AND o.order_status_id = ANY(completed_status_ids) -- Đơn hàng phải ở trạng thái đã giao/hoàn thành
  );
END; $$;
comment on function public.has_user_purchased_product(bigint) is '[V3] Kiểm tra xem người dùng đăng nhập đã mua một sản phẩm cụ thể chưa (dựa trên trạng thái đơn hàng "Đã giao" hoặc "Đã hoàn thành"). Dùng cho chính sách RLS của bảng reviews.';

-- FUNCTION: Cập nhật tồn kho KHI VÀ CHỈ KHI đơn hàng chuyển sang 'Đã giao'
DROP FUNCTION IF EXISTS public.update_inventory_on_order_shipped();
CREATE OR REPLACE FUNCTION public.update_inventory_on_order_shipped()
RETURNS TRIGGER LANGUAGE plpgsql SECURITY DEFINER SET search_path = public AS $$
DECLARE
  shipped_status_id smallint;
  item record;
  current_stock integer;
BEGIN
  -- Lấy ID của trạng thái 'Đã giao'
  SELECT id INTO shipped_status_id FROM public.order_statuses WHERE name = 'Đã giao';

  -- Chỉ thực hiện khi trạng thái MỚI là 'Đã giao' VÀ trạng thái CŨ KHÁC 'Đã giao'
  IF NEW.order_status_id = shipped_status_id AND OLD.order_status_id IS DISTINCT FROM shipped_status_id THEN
    -- Lặp qua từng sản phẩm trong đơn hàng
    FOR item IN SELECT variant_id, quantity FROM public.order_items WHERE order_id = NEW.id LOOP
      -- Giảm số lượng tồn kho của biến thể tương ứng
      UPDATE public.product_variants pv
      SET stock_quantity = stock_quantity - item.quantity
      WHERE id = item.variant_id
      RETURNING stock_quantity INTO current_stock; -- Lấy số tồn kho sau khi trừ

      -- Kiểm tra tồn kho âm sau khi trừ (đề phòng lỗi logic khác)
      IF current_stock < 0 THEN
          -- Có thể raise exception hoặc chỉ ghi log cảnh báo tùy nghiệp vụ
          RAISE WARNING 'Tồn kho âm (%) cho variant_id % sau khi giao đơn hàng %.', current_stock, item.variant_id, NEW.id;
          -- Hoặc: RAISE EXCEPTION 'Lỗi nghiêm trọng: Tồn kho âm (%) cho variant_id % sau khi giao đơn hàng %.', current_stock, item.variant_id, NEW.id;
      END IF;

      -- Ghi log vào bảng inventory
      INSERT INTO public.inventory (variant_id, change_amount, reason, order_id, stock_after_change, updated_by)
      VALUES (item.variant_id, -item.quantity, 'Đơn hàng đã giao', NEW.id, current_stock, NULL); -- updated_by là NULL vì đây là hành động hệ thống
    END LOOP;
  END IF;

  RETURN NEW;
END;
$$;
comment on function public.update_inventory_on_order_shipped is '[V3] Tự động giảm số lượng tồn kho (`product_variants.stock_quantity`) và ghi log (`inventory`) KHI đơn hàng chuyển sang trạng thái "Đã giao". Hủy đơn trước giai đoạn này không ảnh hưởng tồn kho.';

-- TRIGGER: Gọi hàm update_inventory_on_order_shipped sau khi cập nhật trạng thái đơn hàng
DROP TRIGGER IF EXISTS trigger_update_inventory_on_order_shipped ON public.orders;
CREATE TRIGGER trigger_update_inventory_on_order_shipped
AFTER UPDATE OF order_status_id ON public.orders -- Chỉ chạy khi cột order_status_id thay đổi
FOR EACH ROW EXECUTE PROCEDURE public.update_inventory_on_order_shipped();

-- FUNCTION: Kiểm tra tồn kho trước khi thêm/cập nhật số lượng trong giỏ hàng
DROP FUNCTION IF EXISTS public.validate_stock_before_cart_change();
CREATE OR REPLACE FUNCTION public.validate_stock_before_cart_change()
RETURNS TRIGGER LANGUAGE plpgsql SECURITY DEFINER SET search_path = public AS $$
DECLARE available_stock integer; variant_info text; requested_increase integer;
BEGIN
  -- Lấy số lượng tồn kho hiện tại và thông tin biến thể (chưa bị xóa mềm)
  SELECT pv.stock_quantity, p.name || ' (' || pv.volume_ml || 'ml)'
  INTO available_stock, variant_info
  FROM public.product_variants pv
  JOIN public.products p ON pv.product_id = p.id
  WHERE pv.id = NEW.variant_id AND pv.deleted_at IS NULL;

  -- Nếu không tìm thấy biến thể (đã bị xóa?)
  IF available_stock IS NULL THEN
     RAISE EXCEPTION 'Sản phẩm không tồn tại hoặc đã bị xóa.';
  END IF;

  -- Kiểm tra khi THÊM MỚI vào giỏ
  IF TG_OP = 'INSERT' THEN
      IF available_stock < NEW.quantity THEN
         RAISE EXCEPTION 'Không đủ hàng cho "%". Chỉ còn % sản phẩm.', variant_info, available_stock;
      END IF;
  -- Kiểm tra khi CẬP NHẬT số lượng trong giỏ (chỉ kiểm tra nếu tăng số lượng)
  ELSIF TG_OP = 'UPDATE' THEN
      IF NEW.quantity > OLD.quantity THEN
          requested_increase := NEW.quantity - OLD.quantity; -- Số lượng cần thêm
          -- Lấy lại tồn kho mới nhất vì có thể đã thay đổi từ lúc user xem
          SELECT pv.stock_quantity INTO available_stock
          FROM public.product_variants pv
          WHERE pv.id = NEW.variant_id AND pv.deleted_at IS NULL;

          IF available_stock < NEW.quantity THEN -- So sánh số lượng MỚI với tồn kho hiện tại
             RAISE EXCEPTION 'Không đủ hàng cho "%". Chỉ còn % sản phẩm trong kho.', variant_info, available_stock;
          END IF;
      END IF;
  END IF;

  RETURN NEW; -- Cho phép hành động nếu đủ hàng
END; $$;
comment on function public.validate_stock_before_cart_change is '[V3] Kiểm tra số lượng tồn kho (`product_variants.stock_quantity`) trước khi cho phép INSERT hoặc UPDATE (tăng số lượng) vào bảng `cart_items`. Ngăn người dùng thêm quá số lượng còn lại.';

-- TRIGGER: Gọi hàm validate_stock_before_cart_change trước khi INSERT/UPDATE cart_items
DROP TRIGGER IF EXISTS trigger_validate_stock_before_cart_change ON public.cart_items;
CREATE TRIGGER trigger_validate_stock_before_cart_change
BEFORE INSERT OR UPDATE OF quantity ON public.cart_items -- Chỉ chạy khi INSERT hoặc cột quantity thay đổi
FOR EACH ROW EXECUTE PROCEDURE public.validate_stock_before_cart_change();

-- FUNCTION: Tạo slug (URL-friendly string) từ text, hỗ trợ tiếng Việt cơ bản
DROP FUNCTION IF EXISTS public.generate_slug(text);
CREATE OR REPLACE FUNCTION public.generate_slug(name_input text)
RETURNS text LANGUAGE sql IMMUTABLE STRICT SECURITY DEFINER SET search_path = public
AS $$
  -- Chuyển về chữ thường, loại bỏ dấu, thay ký tự đặc biệt bằng '-', bỏ nhiều dấu '-' liền nhau, cắt dấu '-' ở đầu/cuối
  SELECT trim(BOTH '-' FROM regexp_replace(
           regexp_replace(
             lower(unaccent(trim(name_input))),
           '[^a-z0-9]+', '-', 'g'),
         '-{2,}', '-', 'g'))
  ;
$$;
comment on function public.generate_slug(text) is '[V3] Tạo chuỗi ký tự thân thiện với URL (slug) từ một chuỗi đầu vào, sử dụng `unaccent` để xử lý tiếng Việt.';

-- FUNCTION: Tự động tạo slug cho sản phẩm nếu trống hoặc tên thay đổi
DROP FUNCTION IF EXISTS public.set_product_slug();
CREATE OR REPLACE FUNCTION public.set_product_slug()
RETURNS TRIGGER LANGUAGE plpgsql SECURITY DEFINER SET search_path = public AS $$
DECLARE base_slug text; final_slug text; counter integer := 0; BEGIN
  -- Chỉ tạo slug nếu INSERT hoặc tên thay đổi VÀ (slug đang trống HOẶC tên đã thay đổi)
  IF (TG_OP = 'INSERT' OR NEW.name IS DISTINCT FROM OLD.name) AND (NEW.slug IS NULL OR NEW.slug = '' OR NEW.name IS DISTINCT FROM OLD.name) THEN
    base_slug := public.generate_slug(NEW.name);
    -- Xử lý trường hợp slug rỗng sau khi generate (vd: tên toàn ký tự đặc biệt)
    IF base_slug = '' THEN
        base_slug := 'san-pham'; -- Hoặc dùng id nếu được
    END IF;
    final_slug := base_slug;
    -- Xử lý trường hợp slug bị trùng, thêm số vào cuối (-1, -2,...)
    WHILE EXISTS (SELECT 1 FROM public.products WHERE slug = final_slug AND id IS DISTINCT FROM NEW.id) LOOP
      counter := counter + 1;
      final_slug := base_slug || '-' || counter::text;
    END LOOP;
    NEW.slug := final_slug; -- Gán slug cuối cùng
  END IF;
  RETURN NEW;
END; $$;
comment on function public.set_product_slug() is '[V3] Tự động tạo hoặc cập nhật `products.slug` khi sản phẩm được tạo hoặc tên thay đổi. Xử lý slug trùng lặp và slug rỗng.';

-- TRIGGER: Gọi hàm set_product_slug trước khi INSERT/UPDATE sản phẩm
DROP TRIGGER IF EXISTS trigger_set_product_slug ON public.products;
CREATE TRIGGER trigger_set_product_slug BEFORE INSERT OR UPDATE OF name, slug ON public.products -- Chạy cả khi slug bị sửa thành rỗng
FOR EACH ROW EXECUTE PROCEDURE public.set_product_slug();

-- FUNCTION: Tự động tạo slug cho danh mục nếu trống hoặc tên thay đổi
DROP FUNCTION IF EXISTS public.set_category_slug();
CREATE OR REPLACE FUNCTION public.set_category_slug()
RETURNS TRIGGER LANGUAGE plpgsql SECURITY DEFINER SET search_path = public AS $$
DECLARE base_slug text; final_slug text; counter integer := 0; BEGIN
  -- Logic tương tự set_product_slug
  IF (TG_OP = 'INSERT' OR NEW.name IS DISTINCT FROM OLD.name) AND (NEW.slug IS NULL OR NEW.slug = '' OR NEW.name IS DISTINCT FROM OLD.name) THEN
    base_slug := public.generate_slug(NEW.name);
    IF base_slug = '' THEN
        base_slug := 'danh-muc';
    END IF;
    final_slug := base_slug;
    WHILE EXISTS (SELECT 1 FROM public.categories WHERE slug = final_slug AND id IS DISTINCT FROM NEW.id) LOOP
      counter := counter + 1;
      final_slug := base_slug || '-' || counter::text;
    END LOOP;
    NEW.slug := final_slug;
  END IF;
  RETURN NEW;
END; $$;
comment on function public.set_category_slug() is '[V3] Tự động tạo hoặc cập nhật `categories.slug` khi danh mục được tạo hoặc tên thay đổi. Xử lý slug trùng lặp và slug rỗng.';

-- TRIGGER: Gọi hàm set_category_slug trước khi INSERT/UPDATE danh mục
DROP TRIGGER IF EXISTS trigger_set_category_slug ON public.categories;
CREATE TRIGGER trigger_set_category_slug BEFORE INSERT OR UPDATE OF name, slug ON public.categories
FOR EACH ROW EXECUTE PROCEDURE public.set_category_slug();

-- FUNCTION: Kiểm tra mã giảm giá hợp lệ trước khi tạo/cập nhật đơn hàng
DROP FUNCTION IF EXISTS public.validate_discount_code();
CREATE OR REPLACE FUNCTION public.validate_discount_code()
RETURNS TRIGGER LANGUAGE plpgsql SECURITY DEFINER SET search_path = public AS $$
DECLARE d public.discounts%rowtype;
BEGIN
  -- Chỉ kiểm tra nếu đơn hàng có áp dụng discount_id MỚI hoặc discount_id không thay đổi nhưng subtotal thay đổi
  IF NEW.discount_id IS NOT NULL AND (NEW.discount_id IS DISTINCT FROM OLD.discount_id OR NEW.subtotal_amount IS DISTINCT FROM OLD.subtotal_amount) THEN
    -- Lấy thông tin mã giảm giá
    SELECT * INTO d FROM public.discounts WHERE id = NEW.discount_id;
    -- Kiểm tra các điều kiện hợp lệ
    IF d IS NULL THEN RAISE EXCEPTION 'Mã giảm giá không hợp lệ.'; END IF;
    IF d.is_active = false THEN RAISE EXCEPTION 'Mã "%" không hoạt động.', d.code; END IF;
    IF d.start_date IS NOT NULL AND d.start_date > now() THEN RAISE EXCEPTION 'Mã "%" chưa đến ngày sử dụng.', d.code; END IF;
    IF d.end_date IS NOT NULL AND d.end_date < now() THEN RAISE EXCEPTION 'Mã "%" đã hết hạn.', d.code; END IF;
    IF d.remaining_uses IS NOT NULL AND d.remaining_uses <= 0 THEN RAISE EXCEPTION 'Mã "%" đã hết lượt sử dụng.', d.code; END IF;
    IF d.min_order_value IS NOT NULL AND d.min_order_value > NEW.subtotal_amount THEN RAISE EXCEPTION 'Đơn hàng chưa đủ giá trị tối thiểu % để dùng mã "%".', d.min_order_value, d.code; END IF;

    -- Giảm số lượt sử dụng còn lại CHỈ KHI TẠO MỚI đơn hàng và mã có giới hạn lượt dùng
    IF TG_OP = 'INSERT' AND d.remaining_uses IS NOT NULL THEN
       UPDATE public.discounts SET remaining_uses = remaining_uses - 1 WHERE id = NEW.discount_id;
    END IF;

     -- Hoàn trả lượt sử dụng nếu mã giảm giá bị GỠ BỎ khỏi đơn hàng khi UPDATE
  ELSIF TG_OP = 'UPDATE' AND OLD.discount_id IS NOT NULL AND NEW.discount_id IS NULL THEN
      SELECT * INTO d FROM public.discounts WHERE id = OLD.discount_id;
      IF d IS NOT NULL AND d.remaining_uses IS NOT NULL THEN
          UPDATE public.discounts SET remaining_uses = remaining_uses + 1 WHERE id = OLD.discount_id;
      END IF;
  END IF;

  RETURN NEW; -- Cho phép tạo/cập nhật đơn nếu mã hợp lệ
END; $$;
comment on function public.validate_discount_code() is '[V3] Kiểm tra tính hợp lệ của mã giảm giá (active, hạn sử dụng, lượt dùng, giá trị tối thiểu) trước khi cho phép tạo/cập nhật đơn hàng. Tự động giảm/hoàn trả lượt dùng nếu có giới hạn.';

-- TRIGGER: Gọi hàm validate_discount_code trước khi INSERT/UPDATE đơn hàng (CHẠY SAU trigger tính tổng tiền)
DROP TRIGGER IF EXISTS trigger_validate_discount_code ON public.orders;
CREATE TRIGGER trigger_validate_discount_code
BEFORE INSERT OR UPDATE ON public.orders
FOR EACH ROW EXECUTE PROCEDURE public.validate_discount_code();
-- **LƯU Ý:** Trigger này phải chạy SAU trigger `trigger_calculate_order_total` vì nó cần `NEW.subtotal_amount` đã được tính. Postgres thường chạy trigger theo thứ tự alphabet tên trigger, nên đặt tên phù hợp hoặc dùng `CREATE CONSTRAINT TRIGGER` nếu cần đảm bảo thứ tự chặt chẽ.

-- FUNCTION: Tính toán các giá trị tiền của đơn hàng
DROP FUNCTION IF EXISTS public.calculate_order_total();
CREATE OR REPLACE FUNCTION public.calculate_order_total()
RETURNS TRIGGER LANGUAGE plpgsql SECURITY DEFINER SET search_path = public AS $$
DECLARE items_total numeric; disc_amt numeric := 0; ship_fee numeric; d public.discounts%rowtype; s public.shop_settings%rowtype;
BEGIN
  -- **QUAN TRỌNG:** Hàm này GIẢ ĐỊNH `NEW.subtotal_amount` (tổng tiền hàng) đã được tính toán và cung cấp bởi BACKEND/Client trước khi gọi INSERT/UPDATE đơn hàng.
  items_total := NEW.subtotal_amount;
  IF items_total IS NULL THEN
      RAISE EXCEPTION 'Lỗi logic: subtotal_amount phải được cung cấp trước khi tính tổng đơn hàng.';
  END IF;

  -- Lấy cài đặt cửa hàng (phí ship mặc định)
  SELECT * INTO s FROM public.shop_settings WHERE id = 1;
  ship_fee := coalesce(NEW.shipping_fee, s.default_shipping_fee, 0); -- Ưu tiên phí ship truyền vào, nếu không có thì lấy mặc định

  -- Tính tiền giảm giá nếu có discount_id và mã đó đang active
  IF NEW.discount_id IS NOT NULL THEN
    -- Chỉ cần kiểm tra cơ bản ở đây, kiểm tra đầy đủ ở trigger validate_discount_code
    SELECT * INTO d FROM public.discounts WHERE id = NEW.discount_id AND is_active = true;
    IF d IS NOT NULL THEN
      IF d.discount_percentage IS NOT NULL THEN -- Nếu là giảm theo %
        disc_amt := items_total * (d.discount_percentage / 100.0);
        -- Áp dụng giới hạn giảm tối đa (nếu có)
        IF d.max_discount_amount IS NOT NULL AND disc_amt > d.max_discount_amount THEN disc_amt := d.max_discount_amount; END IF;
      ELSIF d.max_discount_amount IS NOT NULL THEN -- Nếu là giảm tiền cố định (dùng max_discount_amount làm giá trị giảm)
         disc_amt := d.max_discount_amount;
         -- Đảm bảo không giảm nhiều hơn tổng tiền hàng
         IF disc_amt > items_total THEN disc_amt := items_total; END IF;
      END IF;
    END IF;
  END IF;

  -- Gán các giá trị đã tính toán
  NEW.discount_amount := disc_amt;
  NEW.shipping_fee := ship_fee;
  NEW.total_amount := items_total - disc_amt + ship_fee;
  -- Đảm bảo tổng tiền không âm
  IF NEW.total_amount < 0 THEN NEW.total_amount := 0; END IF;

  RETURN NEW;
END; $$;
comment on function public.calculate_order_total() is '[V3] Tự động tính toán discount_amount, shipping_fee (nếu chưa có), và total_amount cho đơn hàng. **Yêu cầu Backend/Client phải cung cấp subtotal_amount chính xác.** Chạy TRƯỚC trigger validate_discount_code.';

-- TRIGGER: Gọi hàm calculate_order_total trước khi INSERT/UPDATE đơn hàng (CHẠY TRƯỚC trigger validate)
DROP TRIGGER IF EXISTS trigger_calculate_order_total ON public.orders;
CREATE TRIGGER trigger_calculate_order_total
BEFORE INSERT OR UPDATE ON public.orders
FOR EACH ROW EXECUTE PROCEDURE public.calculate_order_total();


-- FUNCTION: Ngăn chặn các thay đổi trạng thái đơn hàng không hợp lệ
DROP FUNCTION IF EXISTS public.prevent_invalid_status_transitions();
CREATE OR REPLACE FUNCTION public.prevent_invalid_status_transitions()
RETURNS TRIGGER LANGUAGE plpgsql SECURITY DEFINER SET search_path = public AS $$
DECLARE
  old_status_name text;
  new_status_name text;
  processing_statuses text[] := ARRAY['Đang xử lý', 'Đang giao', 'Đã giao', 'Đã hoàn thành']; -- Các trạng thái sau khi đã xác nhận
BEGIN
  -- Bỏ qua khi tạo mới đơn hàng (INSERT)
  IF TG_OP = 'INSERT' THEN RETURN NEW; END IF;

  -- Lấy tên trạng thái cũ và mới
  SELECT name INTO old_status_name FROM public.order_statuses WHERE id = OLD.order_status_id;
  SELECT name INTO new_status_name FROM public.order_statuses WHERE id = NEW.order_status_id;

  -- Bỏ qua nếu trạng thái không thay đổi
  IF OLD.order_status_id = NEW.order_status_id THEN RETURN NEW; END IF;

  -- Quy tắc 1: Không thể thay đổi trạng thái đơn ĐÃ HỦY
  IF old_status_name = 'Đã hủy' THEN
      RAISE EXCEPTION 'Không thể thay đổi trạng thái của đơn hàng đã hủy.';
  END IF;

  -- Quy tắc 2: Không thể thay đổi trạng thái đơn ĐÃ HOÀN THÀNH (trừ khi Admin hủy - logic này cần xem xét kỹ)
  IF old_status_name = 'Đã hoàn thành' AND new_status_name != 'Đã hủy' THEN
      RAISE EXCEPTION 'Không thể thay đổi trạng thái của đơn hàng đã hoàn thành (trừ khi Admin hủy).';
  END IF;

  -- Quy tắc 3: Không cho phép chuyển sang các trạng thái xử lý/giao/hoàn thành nếu thanh toán THẤT BẠI (trừ khi đang update thành Paid)
  IF new_status_name = ANY(processing_statuses) AND OLD.payment_status = 'Failed' AND NEW.payment_status IS DISTINCT FROM 'Paid' THEN
      RAISE EXCEPTION 'Không thể xử lý/giao/hoàn thành đơn hàng có thanh toán thất bại (Trạng thái hiện tại: %).', OLD.payment_status;
  END IF;

  -- Quy tắc 4: Không cho phép quay lùi trạng thái từ Đang giao/Đã giao (trừ khi chuyển sang Hoàn thành hoặc Hủy)
  IF old_status_name IN ('Đang giao', 'Đã giao') AND new_status_name NOT IN ('Đã hoàn thành', 'Đã hủy', 'Đang giao') THEN -- Cho phép ở lại Đang giao (vd: cập nhật note)
     RAISE EXCEPTION 'Không thể chuyển trạng thái từ "%" về "%" (chỉ có thể chuyển tới Hoàn thành hoặc Hủy).', old_status_name, new_status_name;
  END IF;

  -- Quy tắc 5: Không cho phép nhảy cóc từ Chờ xác nhận sang Đã giao/Hoàn thành
  IF old_status_name = 'Chờ xác nhận' AND new_status_name IN ('Đã giao', 'Đã hoàn thành') THEN
      RAISE EXCEPTION 'Phải chuyển sang "Đã xác nhận" hoặc "Đang xử lý" trước khi giao hàng/hoàn thành.';
  END IF;

  -- Quy tắc 6: Không cho phép chuyển sang 'Đã hoàn thành' nếu chưa thanh toán
  IF new_status_name = 'Đã hoàn thành' AND OLD.payment_status != 'Paid' AND NEW.payment_status != 'Paid' THEN
      RAISE EXCEPTION 'Không thể hoàn thành đơn hàng chưa được thanh toán.';
  END IF;

  -- Thêm các quy tắc khác nếu cần...

  RETURN NEW; -- Cho phép thay đổi nếu hợp lệ
END;
$$;
comment on function public.prevent_invalid_status_transitions is '[V3] Ngăn chặn các thay đổi trạng thái đơn hàng không hợp logic (vd: quay lùi từ đã giao, xử lý đơn thanh toán thất bại, hoàn thành đơn chưa trả tiền...). Cần xem xét kỹ các quy tắc dựa trên luồng nghiệp vụ thực tế.';

-- TRIGGER: Gọi hàm prevent_invalid_status_transitions trước khi UPDATE trạng thái đơn hàng
DROP TRIGGER IF EXISTS trigger_prevent_invalid_status_transitions ON public.orders;
CREATE TRIGGER trigger_prevent_invalid_status_transitions
BEFORE UPDATE OF order_status_id ON public.orders -- Chỉ chạy khi cột order_status_id thay đổi
FOR EACH ROW EXECUTE PROCEDURE public.prevent_invalid_status_transitions();


-- FUNCTION: Ghi log hoạt động của Admin/Staff
DROP FUNCTION IF EXISTS public.log_admin_activity();
CREATE OR REPLACE FUNCTION public.log_admin_activity()
RETURNS TRIGGER LANGUAGE plpgsql SECURITY DEFINER SET search_path = public AS $$
DECLARE
  act_type text; descrip text; ent_type text; ent_id text; dets jsonb; role text;
  old_j jsonb; new_j jsonb; old_status_name text; new_status_name text; affected_user_email text;
  old_shipper_email text; new_shipper_email text;
BEGIN
  -- Lấy vai trò người dùng hiện tại
  role := public.get_auth_role();
  -- Chỉ ghi log nếu hành động được thực hiện bởi Admin hoặc Staff
  IF role NOT IN ('admin', 'staff') THEN RETURN NULL; END IF;

  ent_type := TG_TABLE_NAME; -- Tên bảng bị tác động

  -- Chuẩn bị dữ liệu chi tiết (details) dạng JSON
  IF TG_OP = 'UPDATE' THEN
    old_j := to_jsonb(OLD); new_j := to_jsonb(NEW);
    -- Loại bỏ cột updated_at khỏi log để tránh nhiễu
    dets := jsonb_build_object('old', old_j - 'updated_at', 'new', new_j - 'updated_at');
    ent_id := OLD.id::text;
  ELSIF TG_OP = 'DELETE' THEN
    old_j := to_jsonb(OLD); dets := jsonb_build_object('deleted', old_j); ent_id := OLD.id::text;
  ELSIF TG_OP = 'INSERT' THEN
    new_j := to_jsonb(NEW); dets := jsonb_build_object('created', new_j); ent_id := NEW.id::text;
  END IF;

  -- Xác định loại hành động và mô tả dựa trên bảng và thao tác
  IF ent_type = 'products' THEN act_type := 'PRODUCT_' || TG_OP; descrip := TG_OP || ' sản phẩm: ' || coalesce(NEW.name, OLD.name);
  ELSIF ent_type = 'categories' THEN act_type := 'CATEGORY_' || TG_OP; descrip := TG_OP || ' danh mục: ' || coalesce(NEW.name, OLD.name);
  ELSIF ent_type = 'brands' THEN act_type := 'BRAND_' || TG_OP; descrip := TG_OP || ' thương hiệu: ' || coalesce(NEW.name, OLD.name);
  ELSIF ent_type = 'discounts' THEN act_type := 'DISCOUNT_' || TG_OP; descrip := TG_OP || ' mã giảm giá: ' || coalesce(NEW.code, OLD.code);
  ELSIF ent_type = 'product_variants' THEN act_type := 'PRODUCT_VARIANT_' || TG_OP; descrip := TG_OP || ' biến thể sản phẩm (ID: ' || coalesce(NEW.id::text, OLD.id::text) || ')';
  -- Log chi tiết hơn cho Orders
  ELSIF ent_type = 'orders' AND TG_OP = 'UPDATE' THEN
     -- Log thay đổi trạng thái đơn hàng bởi Admin/Staff
     IF OLD.order_status_id IS DISTINCT FROM NEW.order_status_id THEN
        SELECT name INTO old_status_name FROM public.order_statuses WHERE id = OLD.order_status_id;
        SELECT name INTO new_status_name FROM public.order_statuses WHERE id = NEW.order_status_id;
        -- Trường hợp Admin/Staff hủy đơn (được ghi nhận qua cancelled_by_user_id)
        IF new_status_name = 'Đã hủy' AND NEW.cancelled_by = 'admin' THEN
            SELECT email INTO affected_user_email FROM auth.users WHERE id = NEW.cancelled_by_user_id;
            act_type := 'ORDER_CANCELLED_BY_ADMIN';
            descrip := 'Admin/Staff (' || coalesce(affected_user_email, NEW.cancelled_by_user_id::text) || ') hủy đơn hàng #' || NEW.id || '. Lý do: ' || coalesce(NEW.cancellation_reason, 'Không rõ');
            dets := dets || jsonb_build_object('cancellation_reason', NEW.cancellation_reason, 'cancelled_by_user_id', NEW.cancelled_by_user_id, 'old_status', old_status_name, 'new_status', new_status_name);
        ELSE -- Trường hợp thay đổi trạng thái khác
            act_type := 'ORDER_STATUS_CHANGE_BY_ADMIN';
            descrip := 'Đơn hàng #' || NEW.id || ' trạng thái đổi từ "' || coalesce(old_status_name,'NULL') || '" sang "' || coalesce(new_status_name,'NULL') || '" bởi Admin/Staff.';
            dets := dets || jsonb_build_object('old_status', old_status_name, 'new_status', new_status_name);
        END IF;
     -- Log thay đổi người giao hàng
     ELSIF OLD.assigned_shipper_id IS DISTINCT FROM NEW.assigned_shipper_id THEN
        SELECT email INTO old_shipper_email FROM auth.users WHERE id = OLD.assigned_shipper_id;
        SELECT email INTO new_shipper_email FROM auth.users WHERE id = NEW.assigned_shipper_id;
        act_type := 'ORDER_SHIPPER_ASSIGNMENT';
        descrip := 'Đơn hàng #' || NEW.id || ' đổi người giao hàng từ "' || coalesce(old_shipper_email, OLD.assigned_shipper_id::text, 'Chưa gán') || '" sang "' || coalesce(new_shipper_email, NEW.assigned_shipper_id::text, 'Bỏ gán') || '" bởi Admin/Staff.';
        dets := dets || jsonb_build_object('old_shipper_id', OLD.assigned_shipper_id, 'new_shipper_id', NEW.assigned_shipper_id);
     -- Log thay đổi trạng thái thanh toán thủ công
     ELSIF OLD.payment_status IS DISTINCT FROM NEW.payment_status THEN
        act_type := 'ORDER_PAYMENT_STATUS_UPDATE_BY_ADMIN';
        descrip := 'Admin/Staff cập nhật trạng thái thanh toán đơn hàng #' || NEW.id || ' từ "' || OLD.payment_status || '" thành "' || NEW.payment_status || '".';
        dets := dets || jsonb_build_object('old_payment_status', OLD.payment_status, 'new_payment_status', NEW.payment_status);
     END IF;
  -- Log duyệt/xóa đánh giá
  ELSIF ent_type = 'reviews' THEN
    IF TG_OP = 'UPDATE' AND OLD.is_approved IS DISTINCT FROM NEW.is_approved THEN act_type := 'REVIEW_' || (CASE WHEN NEW.is_approved THEN 'APPROVE' ELSE 'UNAPPROVE' END); descrip := act_type || ' đánh giá #' || NEW.id;
    ELSIF TG_OP = 'DELETE' THEN act_type := 'REVIEW_DELETE'; descrip := 'Xóa đánh giá #' || OLD.id; END IF;
  -- Log phản hồi đánh giá
  ELSIF ent_type = 'review_replies' THEN act_type := 'REVIEW_REPLY_' || TG_OP; descrip := TG_OP || ' phản hồi cho đánh giá #' || coalesce(NEW.review_id, OLD.review_id);
  -- Log cập nhật cài đặt shop
  ELSIF ent_type = 'shop_settings' AND TG_OP = 'UPDATE' THEN act_type := 'SHOP_SETTINGS_UPDATE'; descrip := 'Cập nhật cài đặt cửa hàng';
  -- Thêm các loại log khác nếu cần... (vd: inventory được log qua RPC adjust_stock)
  END IF;

  -- Chèn vào bảng log nếu có hành động được xác định
  IF act_type IS NOT NULL THEN
     INSERT INTO public.admin_activity_log (admin_user_id, activity_type, description, entity_type, entity_id, details)
     VALUES (auth.uid(), act_type, descrip, ent_type, ent_id, dets);
  END IF;

  RETURN NULL; -- Trigger AFTER không cần trả về bản ghi
END; $$;
comment on function public.log_admin_activity is '[V3] Tự động ghi lại các hành động INSERT, UPDATE, DELETE quan trọng do người dùng có vai trò "admin" hoặc "staff" thực hiện vào bảng `admin_activity_log`.';

-- TRIGGERS: Gọi hàm log_admin_activity sau khi có thay đổi trên các bảng quan trọng
DROP TRIGGER IF EXISTS trigger_log_admin_activity_products ON public.products; CREATE TRIGGER trigger_log_admin_activity_products AFTER INSERT OR UPDATE OR DELETE ON public.products FOR EACH ROW EXECUTE PROCEDURE public.log_admin_activity();
DROP TRIGGER IF EXISTS trigger_log_admin_activity_categories ON public.categories; CREATE TRIGGER trigger_log_admin_activity_categories AFTER INSERT OR UPDATE OR DELETE ON public.categories FOR EACH ROW EXECUTE PROCEDURE public.log_admin_activity();
DROP TRIGGER IF EXISTS trigger_log_admin_activity_brands ON public.brands; CREATE TRIGGER trigger_log_admin_activity_brands AFTER INSERT OR UPDATE OR DELETE ON public.brands FOR EACH ROW EXECUTE PROCEDURE public.log_admin_activity();
DROP TRIGGER IF EXISTS trigger_log_admin_activity_product_variants ON public.product_variants; CREATE TRIGGER trigger_log_admin_activity_product_variants AFTER INSERT OR UPDATE OR DELETE ON public.product_variants FOR EACH ROW EXECUTE PROCEDURE public.log_admin_activity();
DROP TRIGGER IF EXISTS trigger_log_admin_activity_discounts ON public.discounts; CREATE TRIGGER trigger_log_admin_activity_discounts AFTER INSERT OR UPDATE OR DELETE ON public.discounts FOR EACH ROW EXECUTE PROCEDURE public.log_admin_activity();
DROP TRIGGER IF EXISTS trigger_log_admin_activity_orders ON public.orders; CREATE TRIGGER trigger_log_admin_activity_orders AFTER UPDATE ON public.orders FOR EACH ROW EXECUTE PROCEDURE public.log_admin_activity(); -- Log thay đổi trạng thái, gán shipper,... bởi admin/staff
DROP TRIGGER IF EXISTS trigger_log_admin_activity_reviews ON public.reviews; CREATE TRIGGER trigger_log_admin_activity_reviews AFTER UPDATE OR DELETE ON public.reviews FOR EACH ROW EXECUTE PROCEDURE public.log_admin_activity(); -- Log duyệt/xóa đánh giá
DROP TRIGGER IF EXISTS trigger_log_admin_activity_review_replies ON public.review_replies; CREATE TRIGGER trigger_log_admin_activity_review_replies AFTER INSERT OR UPDATE OR DELETE ON public.review_replies FOR EACH ROW EXECUTE PROCEDURE public.log_admin_activity();
DROP TRIGGER IF EXISTS trigger_log_admin_activity_shop_settings ON public.shop_settings; CREATE TRIGGER trigger_log_admin_activity_shop_settings AFTER UPDATE ON public.shop_settings FOR EACH ROW EXECUTE PROCEDURE public.log_admin_activity();
-- Thêm trigger cho các bảng khác nếu cần log (vd: payment_methods, ingredients...)

-- FUNCTION: Đảm bảo chỉ có 1 ảnh chính cho mỗi sản phẩm
DROP FUNCTION IF EXISTS public.enforce_single_main_image();
CREATE OR REPLACE FUNCTION public.enforce_single_main_image()
RETURNS TRIGGER LANGUAGE plpgsql SECURITY DEFINER SET search_path = public AS $$
BEGIN
  -- Nếu ảnh đang được set là ảnh chính (is_main = true)
  IF NEW.is_main = true THEN
    -- Bỏ đánh dấu is_main của tất cả các ảnh khác cùng sản phẩm
    UPDATE public.product_images
    SET is_main = false
    WHERE product_id = NEW.product_id AND id != NEW.id AND is_main = true;
  END IF;
  RETURN NEW;
END;
$$;
comment on function public.enforce_single_main_image() is '[V3] Đảm bảo rằng khi một ảnh được đánh dấu là chính (is_main = true), tất cả các ảnh khác của cùng sản phẩm sẽ bị bỏ đánh dấu này.';

-- TRIGGER: Gọi hàm enforce_single_main_image trước khi INSERT/UPDATE product_images
DROP TRIGGER IF EXISTS trigger_enforce_single_main_image ON public.product_images;
CREATE TRIGGER trigger_enforce_single_main_image
BEFORE INSERT OR UPDATE OF is_main ON public.product_images -- Chỉ chạy khi INSERT hoặc cột is_main thay đổi
FOR EACH ROW EXECUTE PROCEDURE public.enforce_single_main_image();


-- ============================================================================
-- SECTION: RPC FUNCTIONS (Remote Procedure Call - Các hàm gọi được từ Client/Backend) V3
-- Định nghĩa các hàm có thể được gọi từ bên ngoài để thực hiện các tác vụ cụ thể.
-- Luôn kiểm tra quyền người dùng bên trong hàm RPC.
-- ============================================================================

-- RPC: Admin/Staff duyệt đánh giá
DROP FUNCTION IF EXISTS public.approve_review(bigint);
CREATE OR REPLACE FUNCTION public.approve_review(p_review_id bigint)
RETURNS void LANGUAGE plpgsql SECURITY DEFINER SET search_path = public AS $$
BEGIN
  -- 1. Kiểm tra quyền: Chỉ admin/staff mới được duyệt
  IF NOT public.is_staff() THEN RAISE EXCEPTION 'AUTH_REQUIRED: Chỉ Staff/Admin mới có quyền duyệt đánh giá.'; END IF;
  -- 2. Cập nhật trạng thái duyệt
  UPDATE public.reviews
  SET is_approved = true, approved_by = auth.uid(), approved_at = now()
  WHERE id = p_review_id AND is_approved = false; -- Chỉ update nếu chưa duyệt
  -- 3. Trigger log_admin_activity sẽ tự động ghi log hành động này nếu có update
END; $$;
comment on function public.approve_review(bigint) is '[V3] RPC cho Admin/Staff duyệt một đánh giá sản phẩm (reviews.is_approved = true).';

-- RPC: Admin/Staff phản hồi đánh giá
DROP FUNCTION IF EXISTS public.reply_to_review(bigint, text);
CREATE OR REPLACE FUNCTION public.reply_to_review(p_review_id bigint, p_reply_text text)
RETURNS bigint LANGUAGE plpgsql SECURITY DEFINER SET search_path = public AS $$
DECLARE new_reply_id bigint;
BEGIN
  -- 1. Kiểm tra quyền: Chỉ admin/staff mới được phản hồi
  IF NOT public.is_staff() THEN RAISE EXCEPTION 'AUTH_REQUIRED: Chỉ Staff/Admin mới có quyền trả lời đánh giá.'; END IF;
  -- 2. Kiểm tra đầu vào: Nội dung phản hồi không được trống
  IF p_reply_text IS NULL OR trim(p_reply_text) = '' THEN RAISE EXCEPTION 'VALIDATION_ERROR: Nội dung trả lời không được để trống.'; END IF;
  -- 3. Kiểm tra đánh giá tồn tại
  IF NOT EXISTS (SELECT 1 FROM public.reviews WHERE id = p_review_id) THEN RAISE EXCEPTION 'NOT_FOUND: Đánh giá không tồn tại.'; END IF;
  -- 4. Thêm phản hồi vào bảng review_replies
  INSERT INTO public.review_replies (review_id, staff_id, reply_text)
  VALUES (p_review_id, auth.uid(), p_reply_text) RETURNING id INTO new_reply_id;
  -- 5. Trigger log_admin_activity sẽ tự động ghi log hành động này
  RETURN new_reply_id; -- Trả về ID của phản hồi mới tạo
END; $$;
comment on function public.reply_to_review(bigint, text) is '[V3] RPC cho Admin/Staff thêm một phản hồi (review_replies) cho một đánh giá (reviews). Trả về ID của phản hồi mới.';

-- RPC: Lấy danh sách sản phẩm bán chạy nhất (cho trang chủ,...)
DROP FUNCTION IF EXISTS public.get_best_selling_products(integer);
CREATE OR REPLACE FUNCTION public.get_best_selling_products(p_limit integer DEFAULT 10) -- Thêm giá trị mặc định cho limit
RETURNS TABLE (product_id bigint, product_name text, product_slug text, brand_name text, image_url text, total_sold bigint)
LANGUAGE plpgsql STABLE SECURITY DEFINER SET search_path = public AS $$
DECLARE completed_status_ids smallint[];
BEGIN
  -- Lấy ID các trạng thái đơn hàng được coi là đã bán thành công
  SELECT array_agg(id) INTO completed_status_ids FROM public.order_statuses WHERE name IN ('Đã giao', 'Đã hoàn thành');
  -- Tính tổng số lượng bán của mỗi sản phẩm từ các đơn hàng đã hoàn thành
  RETURN QUERY
    SELECT
      p.id,
      p.name,
      p.slug,
      b.name as brand_name,
      (SELECT pi.image_url FROM public.product_images pi WHERE pi.product_id = p.id AND pi.is_main = true ORDER BY pi.display_order, pi.id LIMIT 1) as image_url,
      SUM(oi.quantity)::bigint as total_sold
    FROM public.products p
    JOIN public.product_variants pv ON p.id = pv.product_id
    JOIN public.order_items oi ON pv.id = oi.variant_id
    JOIN public.orders o ON oi.order_id = o.id
    LEFT JOIN public.brands b ON p.brand_id = b.id
    WHERE p.deleted_at IS NULL AND pv.deleted_at IS NULL -- Chỉ tính sản phẩm/biến thể chưa xóa
      AND o.order_status_id = ANY(completed_status_ids) -- Chỉ tính đơn đã giao/hoàn thành
    GROUP BY p.id, b.name -- Nhóm theo sản phẩm gốc
    ORDER BY total_sold DESC -- Sắp xếp theo số lượng bán giảm dần
    LIMIT p_limit; -- Giới hạn số lượng trả về
END; $$;
comment on function public.get_best_selling_products(integer) is '[V3] RPC lấy danh sách sản phẩm bán chạy nhất (dựa trên tổng số lượng trong các đơn hàng "Đã giao" hoặc "Đã hoàn thành"). Có thể gọi bởi mọi người dùng.';

-- RPC: Lấy báo cáo doanh thu theo tháng (cho Admin)
DROP FUNCTION IF EXISTS public.get_monthly_revenue(date, date);
CREATE OR REPLACE FUNCTION public.get_monthly_revenue(p_start_date date, p_end_date date)
RETURNS TABLE (report_month text, total_revenue numeric, order_count bigint)
LANGUAGE plpgsql STABLE SECURITY DEFINER SET search_path = public AS $$
DECLARE completed_status_ids smallint[];
BEGIN
  -- 1. Kiểm tra quyền: Chỉ Admin
  IF NOT public.is_admin() THEN RAISE EXCEPTION 'AUTH_REQUIRED: Chỉ Admin mới có quyền xem báo cáo doanh thu.'; END IF;
  -- 2. Lấy ID trạng thái hoàn thành
  SELECT array_agg(id) INTO completed_status_ids FROM public.order_statuses WHERE name IN ('Đã giao', 'Đã hoàn thành');
  -- 3. Tính tổng doanh thu và số đơn theo tháng
  RETURN QUERY
    SELECT
      to_char(date_trunc('month', o.order_date), 'YYYY-MM') as report_month,
      SUM(o.total_amount) as total_revenue,
      COUNT(o.id) as order_count
    FROM public.orders o
    WHERE o.order_status_id = ANY(completed_status_ids) -- Chỉ tính đơn đã hoàn thành
      AND o.order_date >= date_trunc('month', p_start_date) -- Lọc theo khoảng thời gian
      AND o.order_date < date_trunc('month', p_end_date) + interval '1 month'
    GROUP BY date_trunc('month', o.order_date) -- Nhóm theo tháng
    ORDER BY 1; -- Sắp xếp theo tháng
END; $$;
comment on function public.get_monthly_revenue(date, date) is '[V3] RPC tính toán doanh thu và số lượng đơn hàng thành công theo từng tháng trong khoảng thời gian cho trước. Chỉ dành cho Admin.';

-- RPC: Lấy báo cáo sản phẩm bán chạy nhất (chi tiết hơn, cho Admin)
DROP FUNCTION IF EXISTS public.get_top_selling_products_report(integer, date, date);
CREATE OR REPLACE FUNCTION public.get_top_selling_products_report(p_limit integer DEFAULT 20, p_start_date date DEFAULT date_trunc('month', now()), p_end_date date DEFAULT now())
RETURNS TABLE (product_id bigint, product_name text, product_code text, brand_name text, total_quantity_sold bigint, total_revenue_generated numeric)
LANGUAGE plpgsql STABLE SECURITY DEFINER SET search_path = public AS $$
DECLARE completed_status_ids smallint[];
BEGIN
  -- 1. Kiểm tra quyền: Chỉ Admin
  IF NOT public.is_admin() THEN RAISE EXCEPTION 'AUTH_REQUIRED: Chỉ Admin mới có quyền xem báo cáo sản phẩm.'; END IF;
  -- 2. Lấy ID trạng thái hoàn thành
  SELECT array_agg(id) INTO completed_status_ids FROM public.order_statuses WHERE name IN ('Đã giao', 'Đã hoàn thành');
  -- 3. Tính tổng số lượng và doanh thu theo sản phẩm
  RETURN QUERY
    SELECT
      p.id as product_id,
      p.name as product_name,
      p.product_code,
      b.name as brand_name,
      SUM(oi.quantity)::bigint as total_quantity_sold,
      SUM(oi.quantity * oi.unit_price_at_order) as total_revenue_generated
    FROM public.products p
    JOIN public.product_variants pv ON p.id = pv.product_id
    JOIN public.order_items oi ON pv.id = oi.variant_id
    JOIN public.orders o ON oi.order_id = o.id
    LEFT JOIN public.brands b ON p.brand_id = b.id
    WHERE p.deleted_at IS NULL AND pv.deleted_at IS NULL
      AND o.order_status_id = ANY(completed_status_ids) -- Chỉ tính đơn hoàn thành
      AND o.order_date >= p_start_date -- Lọc theo khoảng thời gian
      AND o.order_date < p_end_date + interval '1 day'
    GROUP BY p.id, b.name -- Nhóm theo sản phẩm gốc
    ORDER BY total_quantity_sold DESC -- Sắp xếp theo số lượng bán
    LIMIT p_limit; -- Giới hạn kết quả
END; $$;
comment on function public.get_top_selling_products_report(integer, date, date) is '[V3] RPC lấy báo cáo chi tiết các sản phẩm bán chạy nhất (số lượng và doanh thu) trong khoảng thời gian. Chỉ dành cho Admin.';

-- RPC: Lấy các tùy chọn lọc cho trang danh sách sản phẩm (PLP)
DROP FUNCTION IF EXISTS public.get_plp_filter_options();
CREATE OR REPLACE FUNCTION public.get_plp_filter_options()
RETURNS json LANGUAGE plpgsql STABLE SET search_path = public AS $$
DECLARE result json;
BEGIN
  -- Tập hợp dữ liệu từ các bảng phân loại thành một JSON duy nhất
  SELECT json_build_object(
    'brands', (SELECT json_agg(json_build_object('id', id, 'name', name) ORDER BY name) FROM public.brands),
    'categories', (SELECT json_agg(json_build_object('id', id, 'name', name, 'slug', slug, 'parent_category_id', parent_category_id, 'image_url', image_url) ORDER BY display_order, name) FROM public.categories),
    'genders', (SELECT json_agg(json_build_object('id', id, 'name', name) ORDER BY id) FROM public.genders),
    'perfumeTypes', (SELECT json_agg(json_build_object('id', id, 'name', name) ORDER BY id) FROM public.perfume_types),
    'concentrations', (SELECT json_agg(json_build_object('id', id, 'name', name) ORDER BY id) FROM public.concentrations),
    'ingredients', (SELECT json_agg(json_build_object('id', id, 'name', name) ORDER BY name) FROM public.ingredients), -- Thêm thành phần vào bộ lọc
    'volumes', (SELECT json_agg(DISTINCT volume_ml ORDER BY volume_ml) FROM public.product_variants WHERE deleted_at IS NULL), -- Lấy các dung tích đang có
    'priceRanges', (SELECT json_agg(range_obj) FROM (VALUES -- Định nghĩa sẵn các khoảng giá
        ('{"min": 0, "max": 1000000, "label": "Dưới 1 triệu"}'::jsonb),
        ('{"min": 1000000, "max": 2000000, "label": "1 - 2 triệu"}'::jsonb),
        ('{"min": 2000000, "max": 5000000, "label": "2 - 5 triệu"}'::jsonb),
        ('{"min": 5000000, "max": 10000000, "label": "5 - 10 triệu"}'::jsonb),
        ('{"min": 10000000, "max": 9007199254740991, "label": "Trên 10 triệu"}'::jsonb) -- Số lớn để đại diện cho "trở lên"
      ) AS ranges(range_obj))
  ) INTO result;
  RETURN result; -- Trả về JSON chứa tất cả các tùy chọn lọc
END; $$;
comment on function public.get_plp_filter_options() is '[V3] RPC lấy danh sách các tùy chọn (thương hiệu, danh mục, giới tính, thành phần, dung tích, khoảng giá...) để hiển thị bộ lọc trên trang danh sách sản phẩm (PLP). Có thể gọi bởi mọi người dùng.';

-- RPC: Lấy chi tiết đơn hàng an toàn bằng access_token (cho khách vãng lai)
DROP FUNCTION IF EXISTS public.get_order_details_by_token(uuid);
CREATE OR REPLACE FUNCTION public.get_order_details_by_token(p_token uuid)
RETURNS json LANGUAGE plpgsql STABLE SECURITY DEFINER SET search_path = public AS $$
DECLARE order_details json;
BEGIN
  -- Tìm đơn hàng dựa trên access_token
  SELECT json_strip_nulls(json_build_object(
      -- Thông tin đơn hàng (chỉ các trường an toàn cho khách xem)
      'order', row_to_json(o_filtered.*),
      -- Danh sách các sản phẩm trong đơn (kèm ảnh, sku, slug)
      'items', (SELECT json_agg(oi_filtered.*)
                FROM (SELECT oi.id, oi.product_name, oi.variant_volume_ml, oi.quantity, oi.unit_price_at_order, pv.sku, p.slug as product_slug,
                             (SELECT pi.image_url FROM public.product_images pi WHERE pi.product_id = p.id AND pi.is_main = true ORDER BY pi.display_order, pi.id LIMIT 1) as image_url
                      FROM public.order_items oi
                      JOIN public.product_variants pv ON oi.variant_id = pv.id
                      JOIN public.products p ON pv.product_id = p.id
                      WHERE oi.order_id = o_filtered.id
                     ) as oi_filtered
               ),
      -- Tên trạng thái và phương thức thanh toán
      'status_name', (SELECT os.name FROM public.order_statuses os WHERE os.id = o_filtered.order_status_id),
      'payment_method_name', (SELECT pm.name FROM public.payment_methods pm WHERE pm.id = o_filtered.payment_method_id),
      -- Thông tin hủy đơn (nếu có)
      'cancelled_by_details', CASE
                                WHEN o_filtered.cancelled_by = 'user' THEN jsonb_build_object('type', 'user', 'reason', o_filtered.cancellation_reason)
                                WHEN o_filtered.cancelled_by = 'admin' THEN jsonb_build_object('type', 'admin', 'reason', o_filtered.cancellation_reason)
                                ELSE null
                              END,
      -- Thông tin giao hàng thất bại (nếu có)
      'delivery_failure_details', CASE
                                    WHEN o_filtered.delivery_failure_reason IS NOT NULL THEN jsonb_build_object('reason', o_filtered.delivery_failure_reason, 'timestamp', o_filtered.delivery_failure_timestamp)
                                    ELSE null
                                  END
    )) INTO order_details
  FROM ( SELECT -- Chọn lọc các cột an toàn từ bảng orders
                o.id, o.access_token, o.guest_name, o.guest_email, o.guest_phone, o.recipient_name, o.recipient_phone,
                o.province_city, o.district, o.ward, o.street_address, o.order_date, o.delivery_notes, o.payment_method_id,
                o.payment_status, o.order_status_id,
                o.subtotal_amount, o.discount_amount,
                o.shipping_fee, o.total_amount, o.cancellation_reason, o.cancelled_by, o.completed_at,
                o.delivery_failure_reason, o.delivery_failure_timestamp -- Thêm cột mới
                -- KHÔNG trả về user_id, cancelled_by_user_id, assigned_shipper_id cho khách
         FROM public.orders o WHERE o.access_token = p_token
  ) as o_filtered;

  -- Nếu không tìm thấy đơn hàng với token này
  IF order_details IS NULL THEN RAISE EXCEPTION 'ORDER_NOT_FOUND: Không tìm thấy đơn hàng với mã tra cứu này.'; END IF;

  RETURN order_details; -- Trả về JSON chi tiết đơn hàng
END; $$;
comment on function public.get_order_details_by_token(uuid) is '[V3] RPC cho phép khách vãng lai (hoặc bất kỳ ai có token) xem chi tiết đơn hàng một cách an toàn bằng `access_token`. Trả về thông tin đơn hàng, sản phẩm, hủy đơn, giao thất bại. **Cần SECURITY DEFINER.**';

-- RPC: Người dùng tự hủy đơn hàng của mình
DROP FUNCTION IF EXISTS public.cancel_order_by_user(p_order_id bigint, p_reason text);
CREATE OR REPLACE FUNCTION public.cancel_order_by_user(p_order_id bigint, p_reason text)
RETURNS void LANGUAGE plpgsql SECURITY DEFINER SET search_path = public AS $$
DECLARE
  target_order public.orders%rowtype;
  current_status_name text;
  cancelled_status_id smallint;
  allowed_cancel_statuses text[] := ARRAY['Chờ xác nhận', 'Đã xác nhận']; -- Các trạng thái cho phép user hủy
  cod_method_id smallint;
BEGIN
  -- 1. Kiểm tra đăng nhập
  IF auth.uid() IS NULL THEN RAISE EXCEPTION 'AUTH_REQUIRED: Bạn cần đăng nhập để hủy đơn hàng.'; END IF;
  -- 2. Kiểm tra lý do hợp lệ
  IF p_reason IS NULL OR trim(p_reason) = '' THEN RAISE EXCEPTION 'VALIDATION_ERROR: Vui lòng cung cấp lý do hủy đơn.'; END IF;

  -- 3. Lấy thông tin đơn hàng và kiểm tra quyền sở hữu
  SELECT * INTO target_order FROM public.orders WHERE id = p_order_id AND user_id = auth.uid();
  IF target_order IS NULL THEN RAISE EXCEPTION 'NOT_FOUND: Không tìm thấy đơn hàng hoặc bạn không có quyền hủy đơn này.'; END IF;

  -- 4. Lấy thông tin trạng thái hiện tại và ID trạng thái hủy
  SELECT name INTO current_status_name FROM public.order_statuses WHERE id = target_order.order_status_id;
  SELECT id INTO cancelled_status_id FROM public.order_statuses WHERE name = 'Đã hủy';
  SELECT id INTO cod_method_id FROM public.payment_methods WHERE name = 'COD';

  -- 5. Kiểm tra nếu đã hủy rồi
  IF current_status_name = 'Đã hủy' THEN RAISE NOTICE 'Đơn hàng đã được hủy trước đó.'; RETURN; END IF;

  -- 6. Kiểm tra trạng thái hiện tại có cho phép hủy không
  IF NOT (current_status_name = ANY(allowed_cancel_statuses)) THEN
    RAISE EXCEPTION 'ACTION_NOT_ALLOWED: Bạn chỉ có thể hủy đơn hàng khi ở trạng thái %.', array_to_string(allowed_cancel_statuses, ' hoặc ');
  END IF;

  -- 7. **QUAN TRỌNG**: Kiểm tra nếu đã thanh toán online thì không cho hủy (cần quy trình hoàn tiền riêng)
  IF target_order.payment_status = 'Paid' AND target_order.payment_method_id != cod_method_id THEN
      RAISE EXCEPTION 'ACTION_NOT_ALLOWED: Không thể hủy đơn hàng đã thanh toán online. Vui lòng liên hệ hỗ trợ.';
  END IF;

  -- 8. Cập nhật trạng thái đơn hàng thành hủy
  UPDATE public.orders
  SET order_status_id = cancelled_status_id,
      cancellation_reason = p_reason,
      cancelled_by = 'user', -- Đánh dấu là user hủy
      cancelled_by_user_id = auth.uid() -- Lưu ID user đã hủy
  WHERE id = p_order_id;

  -- Lưu ý: Trigger log_admin_activity sẽ KHÔNG ghi log hành động này vì do user thực hiện.
  -- Nếu cần log hành động của user, cần cơ chế log riêng hoặc gọi 1 hàm log khác ở đây.

END; $$;
comment on function public.cancel_order_by_user(bigint, text) is '[V3] RPC cho người dùng ĐÃ ĐĂNG NHẬP tự hủy đơn hàng của chính họ. Chỉ cho phép hủy ở trạng thái nhất định (vd: Chờ xác nhận) và chưa thanh toán online. Yêu cầu lý do.';

-- RPC: Admin/Staff hủy đơn hàng
DROP FUNCTION IF EXISTS public.cancel_order_by_admin(p_order_id bigint, p_reason text);
CREATE OR REPLACE FUNCTION public.cancel_order_by_admin(p_order_id bigint, p_reason text)
RETURNS void LANGUAGE plpgsql SECURITY DEFINER SET search_path = public AS $$
DECLARE
  target_order public.orders%rowtype;
  current_status_name text;
  cancelled_status_id smallint;
  cod_method_id smallint;
BEGIN
  -- 1. Kiểm tra quyền Admin/Staff
  IF NOT public.is_staff() THEN RAISE EXCEPTION 'AUTH_REQUIRED: Chỉ Admin/Staff mới có quyền hủy đơn hàng.'; END IF;
  -- 2. Kiểm tra lý do
  IF p_reason IS NULL OR trim(p_reason) = '' THEN RAISE EXCEPTION 'VALIDATION_ERROR: Vui lòng cung cấp lý do hủy đơn.'; END IF;

  -- 3. Lấy thông tin đơn hàng
  SELECT * INTO target_order FROM public.orders WHERE id = p_order_id;
  IF target_order IS NULL THEN RAISE EXCEPTION 'NOT_FOUND: Không tìm thấy đơn hàng.'; END IF;

  -- 4. Lấy trạng thái
  SELECT name INTO current_status_name FROM public.order_statuses WHERE id = target_order.order_status_id;
  SELECT id INTO cancelled_status_id FROM public.order_statuses WHERE name = 'Đã hủy';
  SELECT id INTO cod_method_id FROM public.payment_methods WHERE name = 'COD';

  -- 5. Kiểm tra nếu đã hủy
  IF current_status_name = 'Đã hủy' THEN RAISE NOTICE 'Đơn hàng này đã được hủy trước đó.'; RETURN; END IF;

  -- 6. **QUAN TRỌNG**: Quy tắc nghiệp vụ: Admin có được hủy đơn đã thanh toán online không?
  -- Nếu KHÔNG, thêm kiểm tra:
  -- IF target_order.payment_status = 'Paid' AND target_order.payment_method_id != cod_method_id THEN
  --     RAISE EXCEPTION 'ACTION_NOT_ALLOWED: Không thể hủy đơn hàng đã thanh toán online qua chức năng này. Cần quy trình hoàn tiền riêng.';
  -- END IF;
  -- Nếu CÓ (ví dụ: để xử lý hoàn tiền thủ công sau), thì bỏ qua kiểm tra trên.

  -- 7. Quy tắc nghiệp vụ: Có cho phép hủy đơn đã hoàn thành không?
  -- IF current_status_name = 'Đã hoàn thành' THEN RAISE EXCEPTION 'ACTION_NOT_ALLOWED: Không thể hủy đơn hàng đã hoàn thành.'; END IF;

  -- 8. Cập nhật đơn hàng
  UPDATE public.orders
  SET order_status_id = cancelled_status_id,
      cancellation_reason = p_reason,
      cancelled_by = 'admin', -- Đánh dấu admin/staff hủy
      cancelled_by_user_id = auth.uid() -- Lưu ID admin/staff đã hủy
  WHERE id = p_order_id;
  -- Trigger log_admin_activity sẽ tự động ghi log hành động này.

END; $$;
comment on function public.cancel_order_by_admin(bigint, text) is '[V3] RPC cho Admin/Staff hủy một đơn hàng bất kỳ (cần xem xét quy tắc với đơn đã thanh toán/hoàn thành). Yêu cầu lý do.';


-- RPC: Shipper cập nhật trạng thái đơn hàng (chỉ đơn được gán)
DROP FUNCTION IF EXISTS public.update_order_status_by_shipper(p_order_id bigint, p_new_status_name text);
CREATE OR REPLACE FUNCTION public.update_order_status_by_shipper(p_order_id bigint, p_new_status_name text)
RETURNS void LANGUAGE plpgsql SECURITY DEFINER SET search_path = public AS $$
DECLARE
  target_order public.orders%rowtype;
  current_status_id smallint;
  current_status_name text;
  new_status_id smallint;
  -- Định nghĩa các bước chuyển trạng thái hợp lệ cho Shipper
  allowed_transitions jsonb := '{
      "Đã xác nhận": ["Đang xử lý", "Đang giao"], -- Cần xác định rõ Shipper có quyền bắt đầu xử lý hay chỉ nhận giao
      "Đang xử lý": ["Đang giao"],
      "Đang giao": ["Đã giao"] -- Shipper chỉ có thể chuyển thành "Đã giao"
    }'::jsonb;
  allowed_target_statuses text[];
BEGIN
  -- 1. Kiểm tra role Shipper
  IF NOT public.is_shipper() THEN RAISE EXCEPTION 'AUTH_REQUIRED: Chỉ người giao hàng mới có quyền cập nhật trạng thái này.'; END IF;

  -- 2. **QUAN TRỌNG**: Kiểm tra xem Shipper có được GÁN cho đơn hàng này không
  SELECT * INTO target_order FROM public.orders WHERE id = p_order_id AND assigned_shipper_id = auth.uid();
  IF target_order IS NULL THEN RAISE EXCEPTION 'ACTION_NOT_ALLOWED: Bạn không được gán cho đơn hàng này hoặc đơn hàng không tồn tại.'; END IF;

  -- 3. Lấy thông tin trạng thái
  SELECT id, name INTO current_status_id, current_status_name FROM public.order_statuses WHERE id = target_order.order_status_id;
  SELECT id INTO new_status_id FROM public.order_statuses WHERE name = p_new_status_name;

  -- 4. Kiểm tra trạng thái mới hợp lệ
  IF new_status_id IS NULL THEN RAISE EXCEPTION 'VALIDATION_ERROR: Trạng thái mới không hợp lệ "%".', p_new_status_name; END IF;
  IF current_status_id = new_status_id THEN RETURN; END IF; -- Không có gì thay đổi

  -- 5. Kiểm tra bước chuyển trạng thái có được phép cho shipper không
  allowed_target_statuses := ARRAY(SELECT jsonb_array_elements_text(allowed_transitions->current_status_name));
  IF allowed_target_statuses IS NULL OR NOT (p_new_status_name = ANY(allowed_target_statuses)) THEN
      RAISE EXCEPTION 'ACTION_NOT_ALLOWED: Người giao hàng không thể chuyển trạng thái từ "%" sang "%".', current_status_name, p_new_status_name;
  END IF;

  -- 6. Kiểm tra các trạng thái cuối cùng (double check với trigger prevent_invalid_status_transitions)
  IF current_status_name IN ('Đã giao', 'Đã hoàn thành', 'Đã hủy') THEN
      RAISE EXCEPTION 'ACTION_NOT_ALLOWED: Không thể thay đổi trạng thái đơn hàng "%".', current_status_name;
  END IF;

  -- 7. Cập nhật trạng thái đơn hàng
  UPDATE public.orders
  SET order_status_id = new_status_id
  WHERE id = p_order_id;

  -- Không cần ghi log admin ở đây vì do shipper thực hiện

END; $$;
comment on function public.update_order_status_by_shipper(bigint, text) is '[V3] RPC cho Shipper cập nhật trạng thái đơn hàng ĐÃ ĐƯỢC GÁN cho họ, theo các bước chuyển hợp lệ (vd: Đang xử lý -> Đang giao).';

-- RPC: Shipper xác nhận đã thu tiền COD (cho đơn được gán)
DROP FUNCTION IF EXISTS public.confirm_cod_payment_by_shipper(p_order_id bigint);
CREATE OR REPLACE FUNCTION public.confirm_cod_payment_by_shipper(p_order_id bigint)
RETURNS void LANGUAGE plpgsql SECURITY DEFINER SET search_path = public AS $$
DECLARE
  target_order public.orders%rowtype;
  cod_method_id smallint;
  delivered_status_id smallint;
BEGIN
  -- 1. Kiểm tra role Shipper
  IF NOT public.is_shipper() THEN RAISE EXCEPTION 'AUTH_REQUIRED: Chỉ người giao hàng mới có quyền xác nhận thu tiền COD.'; END IF;

  -- 2. **QUAN TRỌNG**: Kiểm tra Shipper được gán cho đơn này
  SELECT * INTO target_order FROM public.orders WHERE id = p_order_id AND assigned_shipper_id = auth.uid();
  IF target_order IS NULL THEN RAISE EXCEPTION 'ACTION_NOT_ALLOWED: Bạn không được gán cho đơn hàng này hoặc đơn hàng không tồn tại.'; END IF;

  -- 3. Kiểm tra có phải đơn COD không
  SELECT id INTO cod_method_id FROM public.payment_methods WHERE name = 'COD';
  IF target_order.payment_method_id != cod_method_id THEN
      RAISE EXCEPTION 'ACTION_NOT_ALLOWED: Đơn hàng này không phải là đơn COD.';
  END IF;

   -- 4. Kiểm tra trạng thái đơn hàng phải là 'Đã giao'
  SELECT id INTO delivered_status_id FROM public.order_statuses WHERE name = 'Đã giao';
  IF target_order.order_status_id != delivered_status_id THEN
       RAISE EXCEPTION 'ACTION_NOT_ALLOWED: Chỉ có thể xác nhận thu tiền cho đơn hàng đã ở trạng thái "Đã giao".';
  END IF;

  -- 5. Kiểm tra nếu đã thanh toán rồi thì bỏ qua
  IF target_order.payment_status = 'Paid' THEN
      RAISE NOTICE 'Đơn hàng #% đã được xác nhận thanh toán COD trước đó.', p_order_id; RETURN;
  END IF;

  -- 6. Cập nhật trạng thái thanh toán của đơn hàng thành 'Paid'
  UPDATE public.orders
  SET payment_status = 'Paid'
  WHERE id = p_order_id;

  -- Có thể thêm log riêng cho hành động của shipper nếu cần

END; $$;
comment on function public.confirm_cod_payment_by_shipper(bigint) is '[V3] RPC cho Shipper xác nhận đã thu tiền mặt cho đơn hàng COD ĐÃ ĐƯỢC GÁN cho họ và ở trạng thái "Đã giao". Cập nhật `orders.payment_status` = ''Paid''.';

-- RPC (MỚI V3): Shipper ghi nhận giao hàng thất bại
DROP FUNCTION IF EXISTS public.record_delivery_failure_by_shipper(bigint, text);
CREATE OR REPLACE FUNCTION public.record_delivery_failure_by_shipper(p_order_id bigint, p_reason text)
RETURNS void LANGUAGE plpgsql SECURITY DEFINER SET search_path = public AS $$
DECLARE
  target_order public.orders%rowtype;
  delivering_status_id smallint;
BEGIN
  -- 1. Kiểm tra role Shipper
  IF NOT public.is_shipper() THEN RAISE EXCEPTION 'AUTH_REQUIRED: Chỉ người giao hàng mới có quyền ghi nhận thất bại.'; END IF;
  -- 2. Kiểm tra lý do hợp lệ
  IF p_reason IS NULL OR trim(p_reason) = '' THEN RAISE EXCEPTION 'VALIDATION_ERROR: Vui lòng cung cấp lý do giao hàng thất bại.'; END IF;
  -- 3. Kiểm tra Shipper được gán cho đơn này
  SELECT * INTO target_order FROM public.orders WHERE id = p_order_id AND assigned_shipper_id = auth.uid();
  IF target_order IS NULL THEN RAISE EXCEPTION 'ACTION_NOT_ALLOWED: Bạn không được gán cho đơn hàng này hoặc đơn hàng không tồn tại.'; END IF;
  -- 4. Kiểm tra trạng thái đơn hàng phải là 'Đang giao'
  SELECT id INTO delivering_status_id FROM public.order_statuses WHERE name = 'Đang giao';
  IF target_order.order_status_id != delivering_status_id THEN
       RAISE EXCEPTION 'ACTION_NOT_ALLOWED: Chỉ có thể ghi nhận thất bại cho đơn hàng đang ở trạng thái "Đang giao".';
  END IF;
  -- 5. Cập nhật lý do và thời điểm thất bại
  UPDATE public.orders
  SET delivery_failure_reason = p_reason,
      delivery_failure_timestamp = now()
  WHERE id = p_order_id;
END; $$;
comment on function public.record_delivery_failure_by_shipper(bigint, text) is '[V3] RPC cho Shipper ghi nhận lý do giao hàng thất bại cho đơn hàng được gán và đang ở trạng thái "Đang giao". Chỉ cập nhật thông tin, không đổi trạng thái đơn.';


-- RPC: Người dùng đánh dấu đơn hàng đã hoàn thành
DROP FUNCTION IF EXISTS public.mark_order_completed_by_user(p_order_id bigint);
CREATE OR REPLACE FUNCTION public.mark_order_completed_by_user(p_order_id bigint)
RETURNS void LANGUAGE plpgsql SECURITY DEFINER SET search_path = public AS $$
DECLARE
  target_order public.orders%rowtype;
  current_status_name text;
  delivered_status_id smallint;
  completed_status_id smallint;
BEGIN
  -- 1. Kiểm tra đăng nhập
  IF auth.uid() IS NULL THEN RAISE EXCEPTION 'AUTH_REQUIRED: Bạn cần đăng nhập.'; END IF;

  -- 2. Lấy đơn hàng và kiểm tra sở hữu
  SELECT * INTO target_order FROM public.orders WHERE id = p_order_id AND user_id = auth.uid();
  IF target_order IS NULL THEN RAISE EXCEPTION 'NOT_FOUND: Không tìm thấy đơn hàng hoặc bạn không có quyền.'; END IF;

  -- 3. Lấy thông tin trạng thái
  SELECT id, name INTO delivered_status_id, current_status_name FROM public.order_statuses WHERE id = target_order.order_status_id;
  SELECT id INTO completed_status_id FROM public.order_statuses WHERE name = 'Đã hoàn thành';

  -- 4. Kiểm tra trạng thái hiện tại phải là 'Đã giao'
  IF current_status_name != 'Đã giao' THEN
    RAISE EXCEPTION 'ACTION_NOT_ALLOWED: Chỉ có thể xác nhận hoàn thành đơn hàng đã ở trạng thái "Đã giao".';
  END IF;

  -- 5. **QUAN TRỌNG**: Kiểm tra trạng thái thanh toán phải là 'Paid'
  IF target_order.payment_status != 'Paid' THEN
    RAISE EXCEPTION 'ACTION_NOT_ALLOWED: Thanh toán cho đơn hàng này chưa được xác nhận hoàn tất.';
  END IF;

  -- 6. Cập nhật trạng thái đơn hàng và thời điểm hoàn thành
  UPDATE public.orders
  SET order_status_id = completed_status_id,
      completed_at = now()
  WHERE id = p_order_id;

END; $$;
comment on function public.mark_order_completed_by_user(bigint) is '[V3] RPC cho người dùng ĐÃ ĐĂNG NHẬP đánh dấu đơn hàng của họ là đã hoàn thành. Yêu cầu đơn hàng phải ở trạng thái "Đã giao" và "Đã thanh toán" (`payment_status` = ''Paid'').';

-- RPC: Admin/Staff xác nhận thanh toán Chuyển khoản Ngân hàng
DROP FUNCTION IF EXISTS public.confirm_bank_transfer_payment(p_order_id bigint, p_transaction_details jsonb);
CREATE OR REPLACE FUNCTION public.confirm_bank_transfer_payment(p_order_id bigint, p_transaction_details jsonb DEFAULT NULL)
RETURNS void LANGUAGE plpgsql SECURITY DEFINER SET search_path = public AS $$
DECLARE
    target_order public.orders%rowtype;
    bank_method_id smallint;
    new_payment_id bigint;
BEGIN
    -- 1. Kiểm tra quyền Admin/Staff
    IF NOT public.is_staff() THEN RAISE EXCEPTION 'AUTH_REQUIRED: Chỉ Admin/Staff mới có quyền xác nhận thanh toán chuyển khoản.'; END IF;

    -- 2. Lấy thông tin đơn hàng
    SELECT * INTO target_order FROM public.orders WHERE id = p_order_id;
    IF target_order IS NULL THEN RAISE EXCEPTION 'NOT_FOUND: Không tìm thấy đơn hàng.'; END IF;

    -- 3. Kiểm tra phương thức thanh toán là Chuyển khoản
    SELECT id INTO bank_method_id FROM public.payment_methods WHERE name = 'Chuyển khoản ngân hàng';
    IF target_order.payment_method_id != bank_method_id THEN
        RAISE EXCEPTION 'ACTION_NOT_ALLOWED: Đơn hàng này không phải thanh toán bằng Chuyển khoản ngân hàng.';
    END IF;

    -- 4. Kiểm tra nếu đã thanh toán rồi
    IF target_order.payment_status = 'Paid' THEN
        RAISE NOTICE 'Đơn hàng #% đã được xác nhận thanh toán trước đó.', p_order_id; RETURN;
    END IF;

    -- 5. Cập nhật trạng thái thanh toán của đơn hàng
    UPDATE public.orders SET payment_status = 'Paid' WHERE id = p_order_id;

    -- 6. (Tùy chọn nhưng nên làm) Tạo bản ghi trong bảng payments để lưu vết
    INSERT INTO public.payments (order_id, payment_method_id, amount, status, payment_details, transaction_id)
    VALUES (p_order_id, bank_method_id, target_order.total_amount, 'Completed', p_transaction_details, 'BANK-' || p_order_id::text || '-' || to_char(now(), 'YYMMDDHH24MISS'))
    RETURNING id INTO new_payment_id;

    -- 7. Ghi log hành động (Trigger log_admin_activity cũng sẽ ghi log việc update orders.payment_status)
    INSERT INTO public.admin_activity_log (admin_user_id, activity_type, description, entity_type, entity_id, details)
    VALUES (auth.uid(), 'BANK_TRANSFER_CONFIRMED', 'Admin/Staff xác nhận thanh toán chuyển khoản cho đơn #' || p_order_id || '. Payment ID: ' || new_payment_id, 'order', p_order_id::text, p_transaction_details);

END; $$;
comment on function public.confirm_bank_transfer_payment(bigint, jsonb) is '[V3] RPC cho Admin/Staff xác nhận THỦ CÔNG rằng đã nhận được thanh toán Chuyển khoản Ngân hàng cho một đơn hàng. Cập nhật `orders.payment_status` và tạo bản ghi `payments`.';

-- RPC (MỚI V3): Admin/Staff điều chỉnh tồn kho thủ công
DROP FUNCTION IF EXISTS public.adjust_stock(bigint, integer, text);
CREATE OR REPLACE FUNCTION public.adjust_stock(p_variant_id bigint, p_change_amount integer, p_reason text)
RETURNS integer -- Trả về số lượng tồn kho mới
LANGUAGE plpgsql SECURITY DEFINER SET search_path = public AS $$
DECLARE
    current_stock integer;
    new_stock integer;
    variant_exists boolean;
BEGIN
    -- 1. Kiểm tra quyền Admin/Staff
    IF NOT public.is_staff() THEN RAISE EXCEPTION 'AUTH_REQUIRED: Chỉ Admin/Staff mới có quyền điều chỉnh tồn kho.'; END IF;

    -- 2. Kiểm tra đầu vào
    IF p_change_amount = 0 THEN RAISE EXCEPTION 'VALIDATION_ERROR: Số lượng thay đổi phải khác 0.'; END IF;
    IF p_reason IS NULL OR trim(p_reason) = '' THEN RAISE EXCEPTION 'VALIDATION_ERROR: Phải cung cấp lý do điều chỉnh kho.'; END IF;

    -- 3. Kiểm tra biến thể tồn tại và lấy tồn kho hiện tại (Lock bản ghi để tránh race condition)
    SELECT stock_quantity INTO current_stock
    FROM public.product_variants
    WHERE id = p_variant_id AND deleted_at IS NULL
    FOR UPDATE; -- Lock bản ghi đang được cập nhật

    IF NOT FOUND THEN RAISE EXCEPTION 'NOT_FOUND: Biến thể sản phẩm với ID % không tồn tại hoặc đã bị xóa.', p_variant_id; END IF;

    -- 4. Tính toán tồn kho mới
    new_stock := current_stock + p_change_amount;

    -- 5. Kiểm tra tồn kho âm
    IF new_stock < 0 THEN
        RAISE EXCEPTION 'VALIDATION_ERROR: Không thể điều chỉnh kho vì sẽ dẫn đến tồn kho âm (%) cho biến thể ID %.', new_stock, p_variant_id;
    END IF;

    -- 6. Cập nhật tồn kho cho biến thể
    UPDATE public.product_variants
    SET stock_quantity = new_stock
    WHERE id = p_variant_id;

    -- 7. Ghi log vào bảng inventory
    INSERT INTO public.inventory (variant_id, change_amount, reason, order_id, stock_after_change, updated_by)
    VALUES (p_variant_id, p_change_amount, p_reason, NULL, new_stock, auth.uid()); -- updated_by là người thực hiện

    -- 8. Ghi log admin activity
    INSERT INTO public.admin_activity_log (admin_user_id, activity_type, description, entity_type, entity_id, details)
    VALUES (auth.uid(), 'STOCK_ADJUSTMENT', 'Điều chỉnh kho cho variant #' || p_variant_id || '. Thay đổi: ' || p_change_amount || '. Lý do: ' || p_reason, 'product_variant', p_variant_id::text, jsonb_build_object('change_amount', p_change_amount, 'reason', p_reason, 'stock_before', current_stock, 'stock_after', new_stock));

    RETURN new_stock; -- Trả về số lượng tồn kho sau khi điều chỉnh
END; $$;
comment on function public.adjust_stock(bigint, integer, text) is '[V3] RPC cho Admin/Staff điều chỉnh tồn kho thủ công (nhập/xuất/kiểm kê). Cập nhật đồng bộ `product_variants.stock_quantity` và `inventory`, ghi log chi tiết. Ngăn tồn kho âm.';


-- ============================================================================
-- SECTION: RLS POLICIES (Access Control Rules - Version 3)
-- Định nghĩa các quy tắc truy cập dữ liệu cho từng vai trò người dùng.
-- ============================================================================

-- === USER POLICIES ===
-- Người dùng quản lý dữ liệu cá nhân của họ
DROP POLICY IF EXISTS "Users manage own addresses" ON public.addresses; create policy "Users manage own addresses" on public.addresses for all using (auth.uid() = user_id) with check (auth.uid() = user_id);
DROP POLICY IF EXISTS "Users manage own profile" ON public.profiles; create policy "Users manage own profile" on public.profiles for all using (auth.uid() = id) with check (auth.uid() = id);
DROP POLICY IF EXISTS "Users manage own shopping carts" ON public.shopping_carts; create policy "Users manage own shopping carts" on public.shopping_carts for all using (auth.uid() = user_id) with check (auth.uid() = user_id);
DROP POLICY IF EXISTS "Users manage own cart items" ON public.cart_items; create policy "Users manage own cart items" on public.cart_items for all using (exists (select 1 from public.shopping_carts where id = cart_id and user_id = auth.uid())) with check (exists (select 1 from public.shopping_carts where id = cart_id and user_id = auth.uid()));
DROP POLICY IF EXISTS "Users manage own wishlists" ON public.wishlists; create policy "Users manage own wishlists" on public.wishlists for all using (auth.uid() = user_id) with check (auth.uid() = user_id);
-- Người dùng xem dữ liệu đơn hàng của họ
DROP POLICY IF EXISTS "Users can view their own orders" ON public.orders; create policy "Users can view their own orders" on public.orders for select using (auth.uid() = user_id);
DROP POLICY IF EXISTS "Users can view items for own orders" ON public.order_items; create policy "Users can view items for own orders" on public.order_items for select using (exists (select 1 from public.orders where id = order_items.order_id and user_id = auth.uid()));
DROP POLICY IF EXISTS "Users can view payments for own orders" ON public.payments; create policy "Users can view payments for own orders" on public.payments for select using (exists (select 1 from public.orders where id = order_id and user_id = auth.uid()));
-- Người dùng quản lý đánh giá của họ (chỉ tạo nếu đã mua)
DROP POLICY IF EXISTS "Users can view own reviews" ON public.reviews; create policy "Users can view own reviews" on public.reviews for select using (auth.uid() = user_id);
DROP POLICY IF EXISTS "Users can insert reviews if purchased" ON public.reviews; create policy "Users can insert reviews if purchased" on public.reviews for insert with check (auth.uid() = user_id and public.has_user_purchased_product(product_id));
DROP POLICY IF EXISTS "Users can update own unapproved reviews" ON public.reviews; create policy "Users can update own unapproved reviews" on public.reviews for update using (auth.uid() = user_id and is_approved = false) with check (auth.uid() = user_id);
DROP POLICY IF EXISTS "Users can delete own reviews" ON public.reviews; create policy "Users can delete own reviews" on public.reviews for delete using (auth.uid() = user_id);
-- Các hành động khác của User (Hủy đơn, Hoàn thành đơn) được thực hiện qua RPC có kiểm tra quyền bên trong.

-- === PUBLIC ACCESS POLICIES ===
-- Cho phép mọi người (kể cả khách) đọc dữ liệu công khai
DROP POLICY IF EXISTS "Public read access for brands" ON public.brands; create policy "Public read access for brands" on public.brands for select using (true);
DROP POLICY IF EXISTS "Public read access for genders" ON public.genders; create policy "Public read access for genders" on public.genders for select using (true);
DROP POLICY IF EXISTS "Public read access for perfume types" ON public.perfume_types; create policy "Public read access for perfume types" on public.perfume_types for select using (true);
DROP POLICY IF EXISTS "Public read access for concentrations" ON public.concentrations; create policy "Public read access for concentrations" on public.concentrations for select using (true);
DROP POLICY IF EXISTS "Public read access for categories" ON public.categories; create policy "Public read access for categories" on public.categories for select using (true);
DROP POLICY IF EXISTS "Public read access for active products" ON public.products; create policy "Public read access for active products" on public.products for select using (deleted_at is null);
DROP POLICY IF EXISTS "Public read access for scents" ON public.scents; create policy "Public read access for scents" on public.scents for select using (true); -- Nhóm hương
DROP POLICY IF EXISTS "Public read access for ingredients" ON public.ingredients; create policy "Public read access for ingredients" on public.ingredients for select using (true); -- Thành phần
DROP POLICY IF EXISTS "Public read access for active product variants" ON public.product_variants; create policy "Public read access for active product variants" on public.product_variants for select using (deleted_at is null); -- Cho phép xem cả biến thể hết hàng, frontend sẽ xử lý việc hiển thị/cho phép mua
DROP POLICY IF EXISTS "Public read access for product ingredients" ON public.product_ingredients; create policy "Public read access for product ingredients" on public.product_ingredients for select using (true); -- Xem liên kết thành phần - tầng hương
DROP POLICY IF EXISTS "Public read access for product images" ON public.product_images; create policy "Public read access for product images" on public.product_images for select using (true);
DROP POLICY IF EXISTS "Public read access for product categories links" ON public.product_categories; create policy "Public read access for product categories links" on public.product_categories for select using (true);
DROP POLICY IF EXISTS "Public read access for product labels" ON public.product_labels; create policy "Public read access for product labels" on public.product_labels for select using (true);
DROP POLICY IF EXISTS "Public read access for product label assignments" ON public.product_label_assignments; create policy "Public read access for product label assignments" on public.product_label_assignments for select using (valid_until is null or valid_until >= now()); -- Chỉ hiển thị nhãn còn hạn
DROP POLICY IF EXISTS "Public read access for active discounts" ON public.discounts; create policy "Public read access for active discounts" on public.discounts for select using (is_active = true and (start_date is null or start_date <= now()) and (end_date is null or end_date >= now())); -- Chỉ hiển thị mã giảm giá đang hoạt động và còn hiệu lực
DROP POLICY IF EXISTS "Public read access for order statuses" ON public.order_statuses; create policy "Public read access for order statuses" on public.order_statuses for select using (true);
DROP POLICY IF EXISTS "Public read access for active payment methods" ON public.payment_methods; create policy "Public read access for active payment methods" on public.payment_methods for select using (is_active = true);
DROP POLICY IF EXISTS "Public read access for approved reviews" ON public.reviews; create policy "Public read access for approved reviews" on public.reviews for select using (is_approved = true); -- Chỉ xem được đánh giá đã duyệt
DROP POLICY IF EXISTS "Public read access for review replies" ON public.review_replies; create policy "Public read access for review replies" on public.review_replies for select using (true); -- Xem được phản hồi của admin/staff
DROP POLICY IF EXISTS "Public read access for active banners" ON public.banners; create policy "Public read access for active banners" on public.banners for select using (is_active = true and (start_date is null or start_date <= now()) and (end_date is null or end_date >= now())); -- Chỉ hiển thị banner đang hoạt động và còn hạn
DROP POLICY IF EXISTS "Public read access for shop settings" ON public.shop_settings; create policy "Public read access for shop settings" on public.shop_settings for select using (true);

-- === SHIPPER POLICIES ===
-- **CẢNH BÁO BẢO MẬT:** Các policy SELECT dưới đây cho phép Shipper đọc *toàn bộ cột* của dòng dữ liệu họ được phép.
-- **KHUYẾN NGHỊ MẠNH MẼ:** Tạo VIEW hoặc RPC riêng chỉ trả về các cột cần thiết (thông tin người nhận, địa chỉ, SĐT, ghi chú, trạng thái)
-- và cấp quyền trên VIEW/RPC đó cho Shipper, đồng thời **KHÔNG** cấp quyền SELECT trực tiếp trên bảng `orders` và `order_items` cho role 'shipper'.

DROP POLICY IF EXISTS "Shippers can view assigned orders" ON public.orders;
create policy "Shippers can view assigned orders" on public.orders for select
  using (
    public.is_shipper() and
    assigned_shipper_id = auth.uid() and -- **CHỈ ĐƠN ĐƯỢC GÁN**
    order_status_id in (select id from public.order_statuses where name in ('Đã xác nhận', 'Đang xử lý', 'Đang giao', 'Đã giao')) -- Trạng thái liên quan đến giao hàng
  );
comment on policy "Shippers can view assigned orders" on public.orders is '[V3] Shipper chỉ SELECT được đơn hàng được gán cho họ và ở trạng thái phù hợp. **CẢNH BÁO: Policy này cho phép xem tất cả các cột. Nên dùng VIEW/RPC để giới hạn cột dữ liệu cho Shipper!**';

DROP POLICY IF EXISTS "Shippers can view items for assigned orders" ON public.order_items;
create policy "Shippers can view items for assigned orders" on public.order_items for select
  using (
    public.is_shipper() and
    exists (select 1 from public.orders o
            where o.id = order_items.order_id
            and o.assigned_shipper_id = auth.uid() -- **CHỈ ITEM CỦA ĐƠN ĐƯỢC GÁN**
            and o.order_status_id in (select id from public.order_statuses where name in ('Đã xác nhận', 'Đang xử lý', 'Đang giao', 'Đã giao'))
           )
  );
comment on policy "Shippers can view items for assigned orders" on public.order_items is '[V3] Shipper chỉ SELECT được item thuộc các đơn hàng được gán cho họ. **CẢNH BÁO: Policy này cho phép xem tất cả các cột. Nên dùng VIEW/RPC để giới hạn cột dữ liệu cho Shipper!**';
-- Shipper không được phép UPDATE/INSERT/DELETE trực tiếp, phải thông qua RPC đã có kiểm tra quyền và logic.

-- === STAFF & ADMIN POLICIES ===
-- Staff có quyền xem/quản lý rộng hơn User nhưng hẹp hơn Admin
DROP POLICY IF EXISTS "Staff can view all orders" ON public.orders; create policy "Staff can view all orders" on public.orders for select using (public.is_staff());
DROP POLICY IF EXISTS "Staff can update orders" ON public.orders; create policy "Staff can update orders" on public.orders for update using (public.is_staff()) with check (public.is_staff()); -- Cho phép Staff cập nhật ghi chú, gán shipper,... Hủy đơn/đổi trạng thái nên qua RPC. **Cần đảm bảo trigger prevent_invalid_status_transitions hoạt động.**
DROP POLICY IF EXISTS "Staff can view all order items" ON public.order_items; create policy "Staff can view all order items" on public.order_items for select using (public.is_staff());
DROP POLICY IF EXISTS "Staff can view all payments" ON public.payments; create policy "Staff can view all payments" on public.payments for select using (public.is_staff());
DROP POLICY IF EXISTS "Staff can manage payments" ON public.payments; create policy "Staff can manage payments" on public.payments for all using (public.is_staff()) with check (public.is_staff()); -- Cho phép Staff cập nhật thủ công trạng thái thanh toán nếu cần (vd: qua RPC confirm_bank_transfer).
DROP POLICY IF EXISTS "Staff can view all reviews" ON public.reviews; create policy "Staff can view all reviews" on public.reviews for select using (public.is_staff());
DROP POLICY IF EXISTS "Staff can manage reviews (approve/update/delete)" ON public.reviews; create policy "Staff can manage reviews (approve/update/delete)" on public.reviews for all using (public.is_staff()) with check (public.is_staff()); -- Duyệt/phản hồi qua RPC, còn lại có thể trực tiếp.
DROP POLICY IF EXISTS "Staff can manage review replies" ON public.review_replies; create policy "Staff can manage review replies" on public.review_replies for all using (public.is_staff()) with check (public.is_staff());
DROP POLICY IF EXISTS "Staff can manage product data" ON public.products; create policy "Staff can manage product data" on public.products for all using (public.is_staff()) with check (public.is_staff()); -- Cho phép Staff quản lý sản phẩm
DROP POLICY IF EXISTS "Staff can manage product variants" ON public.product_variants; create policy "Staff can manage product variants" on public.product_variants for all using (public.is_staff()) with check (public.is_staff()); -- Cho phép Staff quản lý biến thể (Điều chỉnh kho qua RPC adjust_stock)
DROP POLICY IF EXISTS "Staff can manage product images" ON public.product_images; create policy "Staff can manage product images" on public.product_images for all using (public.is_staff()) with check (public.is_staff());
DROP POLICY IF EXISTS "Staff can manage product ingredients links" ON public.product_ingredients; create policy "Staff can manage product ingredients links" on public.product_ingredients for all using (public.is_staff()) with check (public.is_staff());
DROP POLICY IF EXISTS "Staff can manage product categories links" ON public.product_categories; create policy "Staff can manage product categories links" on public.product_categories for all using (public.is_staff()) with check (public.is_staff());
DROP POLICY IF EXISTS "Staff can manage product labels assignments" ON public.product_label_assignments; create policy "Staff can manage product labels assignments" on public.product_label_assignments for all using (public.is_staff()) with check (public.is_staff());
DROP POLICY IF EXISTS "Staff can manage banners" ON public.banners; create policy "Staff can manage banners" on public.banners for all using (public.is_staff()) with check (public.is_staff());
DROP POLICY IF EXISTS "Staff can manage categories" ON public.categories; create policy "Staff can manage categories" on public.categories for all using (public.is_staff()) with check (public.is_staff());
DROP POLICY IF EXISTS "Staff can manage brands" ON public.brands; create policy "Staff can manage brands" on public.brands for all using (public.is_staff()) with check (public.is_staff());
DROP POLICY IF EXISTS "Staff can manage ingredients" ON public.ingredients; create policy "Staff can manage ingredients" on public.ingredients for all using (public.is_staff()) with check (public.is_staff());
DROP POLICY IF EXISTS "Staff can manage scents" ON public.scents; create policy "Staff can manage scents" on public.scents for all using (public.is_staff()) with check (public.is_staff());
DROP POLICY IF EXISTS "Staff can manage discounts" ON public.discounts; create policy "Staff can manage discounts" on public.discounts for all using (public.is_staff()) with check (public.is_staff());


-- Admin có toàn quyền trên hầu hết các bảng (Đảm bảo có policy cho TẤT CẢ bảng)
DROP POLICY IF EXISTS "Admins can manage all addresses" ON public.addresses; create policy "Admins can manage all addresses" on public.addresses for all using (public.is_admin()) with check (public.is_admin());
DROP POLICY IF EXISTS "Admins can manage all profiles" ON public.profiles; create policy "Admins can manage all profiles" on public.profiles for all using (public.is_admin()) with check (public.is_admin());
DROP POLICY IF EXISTS "Admins can manage brands" ON public.brands; create policy "Admins can manage brands" on public.brands for all using (public.is_admin()) with check (public.is_admin());
DROP POLICY IF EXISTS "Admins can manage genders" ON public.genders; create policy "Admins can manage genders" on public.genders for all using (public.is_admin()) with check (public.is_admin());
DROP POLICY IF EXISTS "Admins can manage perfume types" ON public.perfume_types; create policy "Admins can manage perfume types" on public.perfume_types for all using (public.is_admin()) with check (public.is_admin());
DROP POLICY IF EXISTS "Admins can manage concentrations" ON public.concentrations; create policy "Admins can manage concentrations" on public.concentrations for all using (public.is_admin()) with check (public.is_admin());
DROP POLICY IF EXISTS "Admins can manage categories" ON public.categories; create policy "Admins can manage categories" on public.categories for all using (public.is_admin()) with check (public.is_admin());
DROP POLICY IF EXISTS "Admins can manage products" ON public.products; create policy "Admins can manage products" on public.products for all using (public.is_admin()) with check (public.is_admin());
DROP POLICY IF EXISTS "Admins can manage scents" ON public.scents; create policy "Admins can manage scents" on public.scents for all using (public.is_admin()) with check (public.is_admin());
DROP POLICY IF EXISTS "Admins can manage ingredients" ON public.ingredients; create policy "Admins can manage ingredients" on public.ingredients for all using (public.is_admin()) with check (public.is_admin());
DROP POLICY IF EXISTS "Admins can manage product variants" ON public.product_variants; create policy "Admins can manage product variants" on public.product_variants for all using (public.is_admin()) with check (public.is_admin());
DROP POLICY IF EXISTS "Admins can manage product ingredients links" ON public.product_ingredients; create policy "Admins can manage product ingredients links" on public.product_ingredients for all using (public.is_admin()) with check (public.is_admin());
DROP POLICY IF EXISTS "Admins can manage product images" ON public.product_images; create policy "Admins can manage product images" on public.product_images for all using (public.is_admin()) with check (public.is_admin());
DROP POLICY IF EXISTS "Admins can manage product categories links" ON public.product_categories; create policy "Admins can manage product categories links" on public.product_categories for all using (public.is_admin()) with check (public.is_admin());
DROP POLICY IF EXISTS "Admins can manage product labels" ON public.product_labels; create policy "Admins can manage product labels" on public.product_labels for all using (public.is_admin()) with check (public.is_admin());
DROP POLICY IF EXISTS "Admins can manage product label assignments" ON public.product_label_assignments; create policy "Admins can manage product label assignments" on public.product_label_assignments for all using (public.is_admin()) with check (public.is_admin());
DROP POLICY IF EXISTS "Admins can manage discounts" ON public.discounts; create policy "Admins can manage discounts" on public.discounts for all using (public.is_admin()) with check (public.is_admin());
DROP POLICY IF EXISTS "Admins can manage all shopping carts" ON public.shopping_carts; create policy "Admins can manage all shopping carts" on public.shopping_carts for all using (public.is_admin()) with check (public.is_admin());
DROP POLICY IF EXISTS "Admins can manage all cart items" ON public.cart_items; create policy "Admins can manage all cart items" on public.cart_items for all using (public.is_admin()) with check (public.is_admin());
DROP POLICY IF EXISTS "Admins can manage order statuses" ON public.order_statuses; create policy "Admins can manage order statuses" on public.order_statuses for all using (public.is_admin()) with check (public.is_admin());
DROP POLICY IF EXISTS "Admins can manage payment methods" ON public.payment_methods; create policy "Admins can manage payment methods" on public.payment_methods for all using (public.is_admin()) with check (public.is_admin());
DROP POLICY IF EXISTS "Admins can manage all orders" ON public.orders; create policy "Admins can manage all orders" on public.orders for all using (public.is_admin()) with check (public.is_admin()); -- Admin có toàn quyền trên orders
DROP POLICY IF EXISTS "Admins can manage all order items" ON public.order_items; create policy "Admins can manage all order items" on public.order_items for all using (public.is_admin()) with check (public.is_admin());
DROP POLICY IF EXISTS "Admins can manage all payments" ON public.payments; create policy "Admins can manage all payments" on public.payments for all using (public.is_admin()) with check (public.is_admin());
DROP POLICY IF EXISTS "Admins can manage inventory log" ON public.inventory; create policy "Admins can manage inventory log" on public.inventory for all using (public.is_admin()) with check (public.is_admin()); -- Chỉ Admin được sửa log kho (vd: điều chỉnh thủ công qua RPC adjust_stock). SELECT có thể cho Staff?
DROP POLICY IF EXISTS "Admins can manage all reviews" ON public.reviews; create policy "Admins can manage all reviews" on public.reviews for all using (public.is_admin()) with check (public.is_admin());
DROP POLICY IF EXISTS "Admins can manage all review replies" ON public.review_replies; create policy "Admins can manage all review replies" on public.review_replies for all using (public.is_admin()) with check (public.is_admin());
DROP POLICY IF EXISTS "Admins can manage all wishlists" ON public.wishlists; create policy "Admins can manage all wishlists" on public.wishlists for all using (public.is_admin()) with check (public.is_admin());
DROP POLICY IF EXISTS "Admins can view admin activity logs" ON public.admin_activity_log; create policy "Admins can view admin activity logs" on public.admin_activity_log for select using (public.is_admin());
DROP POLICY IF EXISTS "Admins/System can insert admin activity logs" ON public.admin_activity_log; create policy "Admins/System can insert admin activity logs" on public.admin_activity_log for insert with check (public.is_admin() or auth.role() = 'service_role'); -- Cho phép trigger/RPC ghi log
DROP POLICY IF EXISTS "Admins can manage banners" ON public.banners; create policy "Admins can manage banners" on public.banners for all using (public.is_admin()) with check (public.is_admin());
DROP POLICY IF EXISTS "Admins can manage shop settings" ON public.shop_settings; create policy "Admins can manage shop settings" on public.shop_settings for all using (public.is_admin()) with check (public.is_admin());


-- ============================================================================
-- SECTION: STORAGE BUCKETS & POLICIES (Lưu trữ File) V3
-- Định nghĩa các "thư mục" (buckets) để lưu file và chính sách truy cập.
-- ============================================================================

-- Tạo các Buckets (Nếu chưa tồn tại)
INSERT INTO storage.buckets (id, name, public, file_size_limit, allowed_mime_types) VALUES
  ('avatars', 'avatars', true, 5242880, ARRAY['image/jpeg', 'image/png', 'image/gif', 'image/webp']),        -- Ảnh đại diện user (5MB)
  ('logos', 'logos', true, 2097152, ARRAY['image/jpeg', 'image/png', 'image/gif', 'image/webp', 'image/svg+xml']), -- Logo thương hiệu/shop (2MB, cho phép SVG)
  ('products', 'products', true, 5242880, ARRAY['image/jpeg', 'image/png', 'image/gif', 'image/webp']),      -- Ảnh sản phẩm (5MB)
  ('banners', 'banners', true, 5242880, ARRAY['image/jpeg', 'image/png', 'image/gif', 'image/webp']),       -- Ảnh banner (5MB)
  ('categories', 'categories', true, 5242880, ARRAY['image/jpeg', 'image/png', 'image/gif', 'image/webp']) -- Ảnh danh mục (5MB)
ON CONFLICT (id) DO NOTHING; -- Bỏ qua nếu bucket đã tồn tại

-- Chính sách truy cập Storage (Storage Policies)
-- Xóa các policy cũ nếu tồn tại để tránh lỗi
DROP POLICY IF EXISTS "Public read access" ON storage.objects;
DROP POLICY IF EXISTS "Authenticated user can insert avatar" ON storage.objects;
DROP POLICY IF EXISTS "Owner can update own avatar" ON storage.objects;
DROP POLICY IF EXISTS "Owner can delete own avatar" ON storage.objects;
DROP POLICY IF EXISTS "Admin/Staff can manage business assets" ON storage.objects;

-- Tạo các policy mới
CREATE POLICY "Public read access" ON storage.objects FOR SELECT USING (bucket_id IN ('avatars', 'logos', 'products', 'banners', 'categories')); -- Chỉ cho phép đọc các bucket public đã định nghĩa
CREATE POLICY "Authenticated user can insert avatar" ON storage.objects FOR INSERT TO authenticated WITH CHECK (bucket_id = 'avatars'); -- User đăng nhập có thể upload avatar
CREATE POLICY "Owner can update own avatar" ON storage.objects FOR UPDATE TO authenticated USING ( bucket_id = 'avatars' AND auth.uid() = owner ) WITH CHECK ( bucket_id = 'avatars' AND auth.uid() = owner ); -- User chỉ sửa được avatar của mình
CREATE POLICY "Owner can delete own avatar" ON storage.objects FOR DELETE TO authenticated USING ( bucket_id = 'avatars' AND auth.uid() = owner ); -- User chỉ xóa được avatar của mình
CREATE POLICY "Admin/Staff can manage business assets" ON storage.objects FOR ALL USING (bucket_id IN ('logos', 'products', 'banners', 'categories') AND public.is_staff()) WITH CHECK (bucket_id IN ('logos', 'products', 'banners', 'categories') AND public.is_staff()); -- Staff/Admin quản lý các ảnh khác

-- ============================================================================
-- [V3 Recommendation] STORAGE PATH & NAMING CONVENTIONS
--
-- thư mục hay tên file bên trong buckets. Logic ứng dụng (Frontend/Backend)
-- khi upload file NÊN tuân theo các quy ước sau để đảm bảo tổ chức và
-- tránh xung đột tên:
--
-- - avatars:    `[user_id]/[uuid].[ext]` (Ví dụ: abc-123/f1e2d3c4.png)
-- - logos:
--   - Brand:  `brands/[brand_id]/logo.[ext]` (Ví dụ: brands/5/logo.svg)
--   - Shop:   `shop/logo.[ext]`
-- - products:   `[product_id]/[uuid].[ext]` (Ví dụ: products/101/a1b2c3d4.jpg) - UUID rất quan trọng ở đây.
-- - banners:    `[banner_id]/image.[ext]` hoặc `[uuid].[ext]` (Ví dụ: banners/e6f5d4c3.webp)
-- - categories: `[category_id]/image.[ext]` (Ví dụ: categories/12/cat-image.jpg)
--
-- Lưu ý:
--   - Sử dụng ID của đối tượng liên quan làm tên thư mục.
--   - Sử dụng UUID (v4) để sinh tên file duy nhất, đặc biệt cho ảnh sản phẩm.
--   - Tránh dùng trực tiếp tên file gốc từ người dùng.
--   - Logic này cần được implement trong code xử lý upload file.
-- ============================================================================

-- ============================================================================
-- SECTION: INDEXES (Chỉ mục tối ưu hóa truy vấn) V3
-- Tạo các index trên các cột thường dùng để lọc, join, sắp xếp.
-- ============================================================================

-- Indexes cho bảng products và các bảng liên quan
CREATE INDEX IF NOT EXISTS idx_products_brand_id ON public.products (brand_id);
CREATE INDEX IF NOT EXISTS idx_products_gender_id ON public.products (gender_id);
CREATE INDEX IF NOT EXISTS idx_products_perfume_type_id ON public.products (perfume_type_id);
CREATE INDEX IF NOT EXISTS idx_products_concentration_id ON public.products (concentration_id);
CREATE INDEX IF NOT EXISTS idx_products_slug ON public.products (slug);
CREATE INDEX IF NOT EXISTS idx_products_deleted_at ON public.products (deleted_at);

CREATE INDEX IF NOT EXISTS idx_product_variants_product_id ON public.product_variants (product_id);
CREATE INDEX IF NOT EXISTS idx_product_variants_sku ON public.product_variants (sku);
CREATE INDEX IF NOT EXISTS idx_product_variants_deleted_at ON public.product_variants (deleted_at);
CREATE INDEX IF NOT EXISTS idx_product_variants_price ON public.product_variants (price);
CREATE INDEX IF NOT EXISTS idx_product_variants_sale_price ON public.product_variants (sale_price);
CREATE INDEX IF NOT EXISTS idx_product_variants_stock_quantity ON public.product_variants (stock_quantity);
CREATE INDEX IF NOT EXISTS idx_product_variants_volume_ml ON public.product_variants (volume_ml); -- Cho bộ lọc dung tích

-- Indexes cho kim tự tháp hương mới
CREATE INDEX IF NOT EXISTS idx_product_ingredients_product_id ON public.product_ingredients (product_id);
CREATE INDEX IF NOT EXISTS idx_product_ingredients_ingredient_id ON public.product_ingredients (ingredient_id);
CREATE INDEX IF NOT EXISTS idx_product_ingredients_scent_type ON public.product_ingredients (scent_type);
CREATE INDEX IF NOT EXISTS idx_product_ingredients_prod_ingr_type ON public.product_ingredients (product_id, ingredient_id, scent_type); -- Index tổng hợp cho unique constraint

CREATE INDEX IF NOT EXISTS idx_product_categories_product_id ON public.product_categories (product_id);
CREATE INDEX IF NOT EXISTS idx_product_categories_category_id ON public.product_categories (category_id);

CREATE INDEX IF NOT EXISTS idx_product_images_product_id ON public.product_images (product_id);
CREATE INDEX IF NOT EXISTS idx_product_images_is_main ON public.product_images (is_main);

CREATE INDEX IF NOT EXISTS idx_product_label_assignments_product_id ON public.product_label_assignments (product_id);
CREATE INDEX IF NOT EXISTS idx_product_label_assignments_label_id ON public.product_label_assignments (label_id);
CREATE INDEX IF NOT EXISTS idx_product_label_assignments_valid_until ON public.product_label_assignments (valid_until);

-- Indexes cho giỏ hàng
CREATE INDEX IF NOT EXISTS idx_cart_items_cart_id ON public.cart_items (cart_id);
CREATE INDEX IF NOT EXISTS idx_cart_items_variant_id ON public.cart_items (variant_id);

-- Indexes cho đơn hàng và các bảng liên quan
CREATE INDEX IF NOT EXISTS idx_orders_user_id ON public.orders (user_id);
CREATE INDEX IF NOT EXISTS idx_orders_assigned_shipper_id ON public.orders (assigned_shipper_id);
CREATE INDEX IF NOT EXISTS idx_orders_order_status_id ON public.orders (order_status_id);
CREATE INDEX IF NOT EXISTS idx_orders_payment_status ON public.orders (payment_status);
CREATE INDEX IF NOT EXISTS idx_orders_order_date ON public.orders (order_date DESC);
CREATE INDEX IF NOT EXISTS idx_orders_access_token ON public.orders (access_token); -- Rất quan trọng cho tra cứu guest
CREATE INDEX IF NOT EXISTS idx_orders_cancelled_by ON public.orders (cancelled_by);
CREATE INDEX IF NOT EXISTS idx_orders_cancelled_by_user_id ON public.orders (cancelled_by_user_id);
CREATE INDEX IF NOT EXISTS idx_orders_completed_at ON public.orders (completed_at);
CREATE INDEX IF NOT EXISTS idx_orders_payment_method_id ON public.orders (payment_method_id);
CREATE INDEX IF NOT EXISTS idx_orders_delivery_failure_timestamp ON public.orders (delivery_failure_timestamp); -- Index cột mới

CREATE INDEX IF NOT EXISTS idx_order_items_order_id ON public.order_items (order_id);
CREATE INDEX IF NOT EXISTS idx_order_items_variant_id ON public.order_items (variant_id);

CREATE INDEX IF NOT EXISTS idx_payments_order_id ON public.payments (order_id);
CREATE INDEX IF NOT EXISTS idx_payments_transaction_id ON public.payments (transaction_id); -- Quan trọng cho đối soát online
CREATE INDEX IF NOT EXISTS idx_payments_status ON public.payments (status);

-- Indexes cho các bảng khác
CREATE INDEX IF NOT EXISTS idx_inventory_variant_id ON public.inventory (variant_id);
CREATE INDEX IF NOT EXISTS idx_inventory_timestamp ON public.inventory (timestamp DESC);

CREATE INDEX IF NOT EXISTS idx_reviews_product_id ON public.reviews (product_id);
CREATE INDEX IF NOT EXISTS idx_reviews_user_id ON public.reviews (user_id);
CREATE INDEX IF NOT EXISTS idx_reviews_is_approved ON public.reviews (is_approved);

CREATE INDEX IF NOT EXISTS idx_review_replies_review_id ON public.review_replies (review_id);

CREATE INDEX IF NOT EXISTS idx_wishlists_user_id ON public.wishlists (user_id);
CREATE INDEX IF NOT EXISTS idx_wishlists_product_id ON public.wishlists (product_id);

CREATE INDEX IF NOT EXISTS idx_admin_activity_log_admin_user_id ON public.admin_activity_log (admin_user_id);
CREATE INDEX IF NOT EXISTS idx_admin_activity_log_timestamp ON public.admin_activity_log (timestamp DESC);
CREATE INDEX IF NOT EXISTS idx_admin_activity_log_entity_id ON public.admin_activity_log (entity_type, entity_id); -- Index kết hợp

CREATE INDEX IF NOT EXISTS idx_profiles_default_address_id ON public.profiles (default_address_id);
CREATE INDEX IF NOT EXISTS idx_addresses_user_id ON public.addresses (user_id); -- Hữu ích để lấy địa chỉ của user

-- ============================================================================
-- SECTION: SEED DATA (Dữ liệu khởi tạo ban đầu) V3
-- Chèn một số dữ liệu cơ bản cần thiết cho hệ thống hoạt động.
-- ============================================================================

-- Seed Order Statuses (Vietnamese)
INSERT INTO public.order_statuses (name, description) VALUES
('Chờ xác nhận', 'Đơn hàng mới, chờ cửa hàng xác nhận.'),
('Đã xác nhận', 'Cửa hàng đã xác nhận đơn hàng, chờ xử lý.'),
('Đang xử lý', 'Đơn hàng đang được chuẩn bị tại kho.'),
('Đang giao', 'Đơn hàng đã được bàn giao cho người giao hàng nội bộ.'),
('Đã giao', 'Người giao hàng đã giao thành công tới khách.'),
('Đã hoàn thành', 'Khách hàng đã xác nhận nhận hàng hoặc tự động hoàn thành.'),
('Đã hủy', 'Đơn hàng đã bị hủy bởi khách hàng hoặc cửa hàng.')
ON CONFLICT (name) DO NOTHING; -- Bỏ qua nếu trạng thái đã tồn tại

-- Seed Payment Methods
INSERT INTO public.payment_methods (name, description, is_active) VALUES
('COD', 'Thanh toán khi nhận hàng', true),
('Momo QR', 'Thanh toán qua ví Momo bằng mã QR', true),
('Chuyển khoản ngân hàng', 'Chuyển khoản qua tài khoản ngân hàng', false)
ON CONFLICT (name) DO NOTHING; -- Bỏ qua nếu phương thức đã tồn tại

-- Seed Shop Settings (Ví dụ - Thay bằng thông tin thật)
INSERT INTO public.shop_settings (id, shop_name, contact_email, contact_phone, default_shipping_fee, order_confirmation_sender_email, address) VALUES
(1, 'MyBeauty', 'vuducminh366@gmail.com', '0363625119', 0, 'vuducminh366@gmail.com', 'P.Dương Lâm, Văn Quán, Hà Đông, TP.Hà Nội')
ON CONFLICT (id) DO UPDATE SET -- Cập nhật nếu dòng id=1 đã tồn tại
  shop_name = EXCLUDED.shop_name,
  contact_email = EXCLUDED.contact_email,
  contact_phone = EXCLUDED.contact_phone,
  default_shipping_fee = EXCLUDED.default_shipping_fee,
  order_confirmation_sender_email = EXCLUDED.order_confirmation_sender_email,
  address = EXCLUDED.address,
  -- Cập nhật các trường khác nếu cần
  updated_at = now();


-- ============================================================================
-- FINAL COMMENT: Setup Complete (V3 - Enhanced & Hardened).
--
-- This V3 script provides a highly robust and feature-rich foundation.
-- Key improvements over V2 include:
--   - Accurate Ingredient-based Note Pyramid.
--   - Shipper Delivery Failure Recording.
--   - Secure Manual Stock Adjustment RPC.
--   - Trigger for Single Main Product Image.
--   - Enhanced comments and stricter constraints.
--
-- REMEMBER THE CRITICAL NEXT STEPS:
--
-- 1.  **Auth Role Configuration:** Manually set 'role' ('admin', 'staff', 'shipper')
--     in Supabase Auth User Metadata.
-- 2.  **Shipper Assignment:** Implement Admin UI/Backend logic to update `orders.assigned_shipper_id`.
-- 3.  **Shipper Data Security:** **STRONGLY RECOMMENDED:** Create a database VIEW or specific RPCs
--     that return *only* necessary columns for shippers (recipient info, address, status)
--     instead of allowing direct table reads via RLS, even if RLS restricts rows. Grant permissions
--     on the VIEW/RPC and *revoke* direct SELECT on `orders`/`order_items` for the 'shipper' role.
-- 4.  **Backend Logic (CRITICAL):**
--     *   **Payment Gateway Integration (Momo/Others):** Implement API calls and a secure webhook endpoint
--       (e.g., Edge Function) to handle payment status updates, updating both `public.payments`
--       and `public.orders.payment_status`.
--     *   **Email Sending:** Implement logic (e.g., Edge Functions) for transactional emails
--       (order confirmation, shipping, etc.) using an external provider.
--     *   **Dynamic Product Filtering API:** Build the backend logic to construct dynamic SQL queries
--       based on combined filter criteria from the PLP.
-- 5.  **Frontend Logic:**
--     *   Call defined RPCs (cancel order, complete order, adjust stock, record failure, etc.).
--     *   Build interfaces for Admin, Staff, and Shipper roles.
--     *   Handle display logic for soft-deleted products in wishlists, etc.
-- 6.  **Auto-Completion Cron Job (Optional):** Implement a scheduled Edge Function if needed.
--
-- This V3 script sets you up for a successful and robust project!

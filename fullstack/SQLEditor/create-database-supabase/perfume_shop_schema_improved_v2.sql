-- Migration file for Perfume E-commerce Database (Improved Version 2)
-- This migration creates all necessary tables with proper RLS policies
-- for a perfume e-commerce application targeting the Vietnamese market

-- Enable necessary extensions
create extension if not exists "uuid-ossp";

-- Bảng addresses (Improved for Vietnamese market)
create table public.addresses (
id bigint generated by default as identity primary key,
user_id uuid references auth.users on delete cascade,
recipient_name text not null,
recipient_phone text not null,
province_city text not null,
district text not null,
ward text not null,
street_address text not null,
postal_code text, -- Made optional as per Vietnamese context
is_default boolean default false,
created_at timestamptz default now(),
updated_at timestamptz default now()
);

-- Enable RLS on addresses
alter table public.addresses enable row level security;

-- RLS policies for addresses
create policy "Users can view their own addresses"
on public.addresses for select
using (auth.uid() = user_id);

create policy "Users can insert their own addresses"
on public.addresses for insert
with check (auth.uid() = user_id);

create policy "Users can update their own addresses"
on public.addresses for update
using (auth.uid() = user_id);

create policy "Users can delete their own addresses"
on public.addresses for delete
using (auth.uid() = user_id);

-- Bảng profiles (Improved with simplified user info)
create table public.profiles (
id uuid not null primary key references auth.users on delete cascade,
display_name text,
phone_number text,
gender text, -- Added gender field
birth_date date, -- Added birth date field
avatar_url text, -- Added avatar URL field
default_address_id bigint references public.addresses on delete set null,
created_at timestamptz default now(),
updated_at timestamptz default now()
);

-- Enable RLS on profiles
alter table public.profiles enable row level security;

-- RLS policies for profiles
create policy "Users can view their own profile"
on public.profiles for select
using (auth.uid() = id);

create policy "Users can update their own profile"
on public.profiles for update
using (auth.uid() = id);

-- Trigger to create profile on user signup
create or replace function public.handle_new_user()
returns trigger 
security definer
set search_path = public
as $$
begin
insert into public.profiles (id)
values (new.id);
return new;
end;
$$ language plpgsql;

create trigger on_auth_user_created
after insert on auth.users
for each row execute procedure public.handle_new_user();

-- Bảng brands (Added logo_url)
create table public.brands (
id bigint generated by default as identity primary key,
name text unique not null,
description text,
logo_url text, -- Added logo URL field
created_at timestamptz default now(),
updated_at timestamptz default now()
);

-- Enable RLS on brands
alter table public.brands enable row level security;

-- RLS policies for brands
create policy "Brands are viewable by everyone"
on public.brands for select
to anon, authenticated
using (true);

-- Bảng genders
create table public.genders (
id smallint generated by default as identity primary key,
name text unique not null,
created_at timestamptz default now(),
updated_at timestamptz default now()
);

-- Enable RLS on genders
alter table public.genders enable row level security;

-- RLS policies for genders
create policy "Genders are viewable by everyone"
on public.genders for select
to anon, authenticated
using (true);

-- Insert default gender values
insert into public.genders (name) values
('Men'),
('Women'),
('Unisex');

-- Bảng perfume_types (New table for Niche, Designer, etc.)
create table public.perfume_types (
id smallint generated by default as identity primary key,
name text unique not null,
created_at timestamptz default now(),
updated_at timestamptz default now()
);

-- Enable RLS on perfume_types
alter table public.perfume_types enable row level security;

-- RLS policies for perfume_types
create policy "Perfume types are viewable by everyone"
on public.perfume_types for select
to anon, authenticated
using (true);

-- Insert default perfume type values
insert into public.perfume_types (name) values
('Designer'),
('Niche'),
('Artisanal'),
('Celebrity');

-- Bảng concentrations (New table for EDP, EDT, etc.)
create table public.concentrations (
id smallint generated by default as identity primary key,
name text unique not null,
description text,
created_at timestamptz default now(),
updated_at timestamptz default now()
);

-- Enable RLS on concentrations
alter table public.concentrations enable row level security;

-- RLS policies for concentrations
create policy "Concentrations are viewable by everyone"
on public.concentrations for select
to anon, authenticated
using (true);

-- Insert default concentration values
insert into public.concentrations (name, description) values
('Parfum', 'Highest concentration (20-30%)'),
('Eau de Parfum', 'High concentration (15-20%)'),
('Eau de Toilette', 'Medium concentration (5-15%)'),
('Eau de Cologne', 'Low concentration (2-4%)'),
('Eau Fraiche', 'Lowest concentration (1-3%)');

-- Bảng categories (Simplified for perfume shop)
create table public.categories (
id bigint generated by default as identity primary key,
name text not null unique,
slug text unique,
description text,
is_featured boolean default false, -- For featuring on homepage
display_order int default 0, -- For controlling display order
parent_category_id bigint references public.categories on delete set null,
created_at timestamptz default now(),
updated_at timestamptz default now()
);

-- Enable RLS on categories
alter table public.categories enable row level security;

-- RLS policies for categories
create policy "Categories are viewable by everyone"
on public.categories for select
to anon, authenticated
using (true);

-- Insert default categories
insert into public.categories (name, slug, is_featured, display_order) values
('New Arrivals', 'new-arrivals', true, 1),
('Best Sellers', 'best-sellers', true, 2),
('Sale', 'sale', true, 3),
('Gift Sets', 'gift-sets', true, 4);

-- Bảng products (Enhanced with perfume-specific fields)
create table public.products (
id bigint generated by default as identity primary key,
name text not null,
slug text unique,
product_code text, -- Added product code field
short_description text, -- Added short description
long_description text, -- Added long description
brand_id bigint references public.brands on delete set null,
gender_id smallint references public.genders on delete set null,
perfume_type_id smallint references public.perfume_types on delete set null, -- Added perfume type
concentration_id smallint references public.concentrations on delete set null, -- Added concentration
origin_country text, -- Added country of origin
release_year smallint, -- Added release year
style text, -- Added style (sexy, sweet, etc.)
sillage text, -- Added sillage (projection)
longevity text, -- Added longevity
created_at timestamptz default now(),
updated_at timestamptz default now(),
deleted_at timestamptz
);

-- Enable RLS on products
alter table public.products enable row level security;

-- RLS policies for products
create policy "Products are viewable by everyone"
on public.products for select
to anon, authenticated
using (deleted_at is null);

-- Bảng scents
create table public.scents (
id bigint generated by default as identity primary key,
name text unique not null,
description text,
created_at timestamptz default now(),
updated_at timestamptz default now()
);

-- Enable RLS on scents
alter table public.scents enable row level security;

-- RLS policies for scents
create policy "Scents are viewable by everyone"
on public.scents for select
to anon, authenticated
using (true);

-- Bảng ingredients
create table public.ingredients (
id bigint generated by default as identity primary key,
name text unique not null,
created_at timestamptz default now(),
updated_at timestamptz default now()
);

-- Enable RLS on ingredients
alter table public.ingredients enable row level security;

-- RLS policies for ingredients
create policy "Ingredients are viewable by everyone"
on public.ingredients for select
to anon, authenticated
using (true);

-- Bảng product_variants (Updated for perfume volumes)
create table public.product_variants (
id bigint generated by default as identity primary key,
product_id bigint not null references public.products on delete cascade,
volume_ml integer not null, -- Made required
price numeric not null,
sale_price numeric, -- Added sale price
sku text unique,
stock_quantity integer not null default 0,
created_at timestamptz default now(),
updated_at timestamptz default now(),
deleted_at timestamptz
);

-- Enable RLS on product_variants
alter table public.product_variants enable row level security;

-- RLS policies for product_variants
create policy "Product variants are viewable by everyone"
on public.product_variants for select
to anon, authenticated
using (deleted_at is null);

-- Bảng product_scents (Quan hệ nhiều-nhiều)
create table public.product_scents (
id bigint generated by default as identity primary key,
product_id bigint not null references public.products on delete cascade,
scent_id bigint not null references public.scents on delete cascade,
scent_type text not null check (scent_type in ('top', 'middle', 'base')), -- Added scent type
unique (product_id, scent_id, scent_type)
);

-- Enable RLS on product_scents
alter table public.product_scents enable row level security;

-- RLS policies for product_scents
create policy "Product scents are viewable by everyone"
on public.product_scents for select
to anon, authenticated
using (true);

-- Bảng product_ingredients (Quan hệ nhiều-nhiều)
create table public.product_ingredients (
id bigint generated by default as identity primary key,
product_id bigint not null references public.products on delete cascade,
ingredient_id bigint not null references public.ingredients on delete cascade,
unique (product_id, ingredient_id)
);

-- Enable RLS on product_ingredients
alter table public.product_ingredients enable row level security;

-- RLS policies for product_ingredients
create policy "Product ingredients are viewable by everyone"
on public.product_ingredients for select
to anon, authenticated
using (true);

-- Bảng product_images
create table public.product_images (
id bigint generated by default as identity primary key,
product_id bigint not null references public.products on delete cascade,
image_url text not null,
alt_text text,
is_main boolean default false,
display_order int default 0, -- Added display order
created_at timestamptz default now(),
updated_at timestamptz default now()
);

-- Enable RLS on product_images
alter table public.product_images enable row level security;

-- RLS policies for product_images
create policy "Product images are viewable by everyone"
on public.product_images for select
to anon, authenticated
using (true);

-- Bảng product_categories (Quan hệ nhiều-nhiều)
create table public.product_categories (
id bigint generated by default as identity primary key,
product_id bigint not null references public.products on delete cascade,
category_id bigint not null references public.categories on delete cascade,
unique (product_id, category_id)
);

-- Enable RLS on product_categories
alter table public.product_categories enable row level security;

-- RLS policies for product_categories
create policy "Product categories are viewable by everyone"
on public.product_categories for select
to anon, authenticated
using (true);

-- Bảng product_labels
create table public.product_labels (
id bigint generated by default as identity primary key,
name text unique not null,
color_code varchar(7),
created_at timestamptz default now(),
updated_at timestamptz default now()
);

-- Enable RLS on product_labels
alter table public.product_labels enable row level security;

-- RLS policies for product_labels
create policy "Product labels are viewable by everyone"
on public.product_labels for select
to anon, authenticated
using (true);

-- Insert default product labels
insert into public.product_labels (name, color_code) values
('New', '#4CAF50'),
('Sale', '#F44336'),
('Best Seller', '#FFC107'),
('Limited Edition', '#9C27B0');

-- Bảng product_label_assignments (Quan hệ nhiều-nhiều)
create table public.product_label_assignments (
id bigint generated by default as identity primary key,
product_id bigint not null references public.products on delete cascade,
label_id bigint not null references public.product_labels on delete cascade,
valid_until timestamptz, -- Added expiration date for labels
unique (product_id, label_id)
);

-- Enable RLS on product_label_assignments
alter table public.product_label_assignments enable row level security;

-- RLS policies for product_label_assignments
create policy "Product label assignments are viewable by everyone"
on public.product_label_assignments for select
to anon, authenticated
using (true);

-- Bảng discounts
create table public.discounts (
id bigint generated by default as identity primary key,
code text unique not null,
description text,
start_date timestamptz,
end_date timestamptz,
max_uses integer,
remaining_uses integer,
min_order_value numeric,
max_discount_amount numeric,
discount_percentage numeric,
is_active boolean default true,
created_at timestamptz default now(),
updated_at timestamptz default now()
);

-- Enable RLS on discounts
alter table public.discounts enable row level security;

-- RLS policies for discounts
create policy "Discounts are viewable by everyone"
on public.discounts for select
to anon, authenticated
using (true);

-- Bảng shopping_carts
create table public.shopping_carts (
id bigint generated by default as identity primary key,
user_id uuid references auth.users on delete cascade,
created_at timestamptz default now(),
updated_at timestamptz default now()
);

-- Enable RLS on shopping_carts
alter table public.shopping_carts enable row level security;

-- RLS policies for shopping_carts
create policy "Users can view their own shopping carts"
on public.shopping_carts for select
using (auth.uid() = user_id);

create policy "Users can insert their own shopping carts"
on public.shopping_carts for insert
with check (auth.uid() = user_id);

create policy "Users can update their own shopping carts"
on public.shopping_carts for update
using (auth.uid() = user_id);

create policy "Users can delete their own shopping carts"
on public.shopping_carts for delete
using (auth.uid() = user_id);

-- Bảng cart_items
create table public.cart_items (
id bigint generated by default as identity primary key,
cart_id bigint not null references public.shopping_carts on delete cascade,
variant_id bigint not null references public.product_variants on delete cascade,
quantity integer not null,
created_at timestamptz default now(),
updated_at timestamptz default now()
);

-- Enable RLS on cart_items
alter table public.cart_items enable row level security;

-- RLS policies for cart_items
create policy "Users can view their own cart items"
on public.cart_items for select
using (cart_id in (select id from public.shopping_carts where user_id = auth.uid()));

create policy "Users can insert their own cart items"
on public.cart_items for insert
with check (cart_id in (select id from public.shopping_carts where user_id = auth.uid()));

create policy "Users can update their own cart items"
on public.cart_items for update
using (cart_id in (select id from public.shopping_carts where user_id = auth.uid()));

create policy "Users can delete their own cart items"
on public.cart_items for delete
using (cart_id in (select id from public.shopping_carts where user_id = auth.uid()));

-- Bảng order_statuses
create table public.order_statuses (
id smallint generated by default as identity primary key,
name text unique not null
);

-- Enable RLS on order_statuses
alter table public.order_statuses enable row level security;

-- RLS policies for order_statuses
create policy "Order statuses are viewable by everyone"
on public.order_statuses for select
to anon, authenticated
using (true);

-- Insert initial order statuses
insert into public.order_statuses (name) values
('Pending'),
('Processing'),
('Shipped'),
('Delivered'),
('Cancelled'),
('Refunded');

-- Bảng payment_methods
create table public.payment_methods (
id smallint generated by default as identity primary key,
name text unique not null,
description text,
is_active boolean default true
);

-- Enable RLS on payment_methods
alter table public.payment_methods enable row level security;

-- RLS policies for payment_methods
create policy "Payment methods are viewable by everyone"
on public.payment_methods for select
to anon, authenticated
using (is_active = true);

-- Insert default payment methods
insert into public.payment_methods (name, description) values
('COD', 'Cash on Delivery'),
('Bank Transfer', 'Transfer to bank account'),
('Momo', 'Pay with Momo e-wallet'),
('ZaloPay', 'Pay with ZaloPay e-wallet'),
('VNPay', 'Pay with VNPay QR');

-- Bảng orders (Updated for Vietnamese market)
create table public.orders (
id bigint generated by default as identity primary key,
user_id uuid references auth.users on delete set null,
-- Guest information
guest_name text,
guest_email text,
guest_phone text,
-- Address information (for both registered and guest users)
recipient_name text not null,
recipient_phone text not null,
province_city text not null,
district text not null,
ward text not null,
street_address text not null,
-- Order details
order_date timestamptz default now(),
delivery_notes text,
payment_method_id smallint references public.payment_methods(id),
payment_status text check (payment_status in ('Pending', 'Paid', 'Failed', 'Refunded')),
order_status_id smallint references public.order_statuses(id),
tracking_number text,
discount_id bigint references public.discounts on delete set null,
subtotal_amount numeric not null,
discount_amount numeric default 0,
total_amount numeric not null,
created_at timestamptz default now(),
updated_at timestamptz default now()
);

-- Enable RLS on orders
alter table public.orders enable row level security;

-- RLS policies for orders
create policy "Users can view their own orders"
on public.orders for select
using (auth.uid() = user_id or auth.uid() is null);

create policy "Users can insert their own orders"
on public.orders for insert
with check (auth.uid() = user_id or auth.uid() is null);

-- Bảng order_items
create table public.order_items (
id bigint generated by default as identity primary key,
order_id bigint not null references public.orders on delete cascade,
variant_id bigint not null references public.product_variants on delete restrict,
product_name text not null, -- Store product name at time of order
variant_volume_ml integer not null, -- Store volume at time of order
quantity integer not null,
unit_price_at_order numeric not null,
created_at timestamptz default now(),
updated_at timestamptz default now()
);

-- Enable RLS on order_items
alter table public.order_items enable row level security;

-- RLS policies for order_items
create policy "Users can view their own order items"
on public.order_items for select
using (order_id in (select id from public.orders where user_id = auth.uid() or auth.uid() is null));

create policy "Users can insert their own order items"
on public.order_items for insert
with check (order_id in (select id from public.orders where user_id = auth.uid() or auth.uid() is null));

-- Bảng payments
create table public.payments (
id bigint generated by default as identity primary key,
order_id bigint not null references public.orders on delete cascade,
payment_date timestamptz default now(),
payment_method_id smallint references public.payment_methods(id),
transaction_id text,
amount numeric not null,
status text check (status in ('Pending', 'Completed', 'Failed', 'Refunded')),
payment_details jsonb, -- Store payment-specific details
created_at timestamptz default now(),
updated_at timestamptz default now()
);

-- Enable RLS on payments
alter table public.payments enable row level security;

-- RLS policies for payments
create policy "Users can view their own payments"
on public.payments for select
using (order_id in (select id from public.orders where user_id = auth.uid()));

-- Bảng inventory
create table public.inventory (
id bigint generated by default as identity primary key,
variant_id bigint not null references public.product_variants on delete cascade,
stock_quantity integer not null default 0,
last_stock_update timestamptz default now(),
created_at timestamptz default now(),
updated_at timestamptz default now()
);

-- Enable RLS on inventory
alter table public.inventory enable row level security;

-- RLS policies for inventory
create policy "Inventory is viewable by everyone"
on public.inventory for select
to anon, authenticated
using (true);

-- Bảng reviews (Updated with approval system)
create table public.reviews (
id bigint generated by default as identity primary key,
product_id bigint not null references public.products on delete cascade,
user_id uuid not null references auth.users on delete cascade,
rating smallint not null check (rating >= 1 and rating <= 5),
comment text,
is_approved boolean default false, -- Added approval flag
approved_by uuid references auth.users on delete set null, -- Added approver
approved_at timestamptz, -- Added approval timestamp
created_at timestamptz default now(),
updated_at timestamptz default now()
);

-- Enable RLS on reviews
alter table public.reviews enable row level security;

-- RLS policies for reviews
create policy "Approved reviews are viewable by everyone"
on public.reviews for select
to anon, authenticated
using (is_approved = true);

create policy "Users can view all their own reviews"
on public.reviews for select
using (auth.uid() = user_id);

create policy "Users can insert their own reviews"
on public.reviews for insert
with check (auth.uid() = user_id);

create policy "Users can update their own reviews"
on public.reviews for update
using (auth.uid() = user_id);

create policy "Users can delete their own reviews"
on public.reviews for delete
using (auth.uid() = user_id);

-- Bảng review_replies (New table for staff/admin replies)
create table public.review_replies (
id bigint generated by default as identity primary key,
review_id bigint not null references public.reviews on delete cascade,
staff_id uuid not null references auth.users on delete cascade,
reply_text text not null,
created_at timestamptz default now(),
updated_at timestamptz default now()
);

-- Enable RLS on review_replies
alter table public.review_replies enable row level security;

-- RLS policies for review_replies
create policy "Review replies are viewable by everyone"
on public.review_replies for select
to anon, authenticated
using (true);

-- Bảng wishlists
create table public.wishlists (
id bigint generated by default as identity primary key,
user_id uuid not null references auth.users on delete cascade,
product_id bigint not null references public.products on delete cascade, -- Changed to product_id
added_at timestamptz default now(),
unique (user_id, product_id)
);

-- Enable RLS on wishlists
alter table public.wishlists enable row level security;

-- RLS policies for wishlists
create policy "Users can view their own wishlists"
on public.wishlists for select
using (auth.uid() = user_id);

create policy "Users can insert into their own wishlists"
on public.wishlists for insert
with check (auth.uid() = user_id);

create policy "Users can update their own wishlists"
on public.wishlists for update
using (auth.uid() = user_id);

create policy "Users can delete from their own wishlists"
on public.wishlists for delete
using (auth.uid() = user_id);

-- Bảng admin_activity_log
create table public.admin_activity_log (
id bigint generated by default as identity primary key,
admin_user_id uuid not null references auth.users on delete cascade,
activity_type text not null,
description text,
entity_type text, -- Added entity type (product, order, etc.)
entity_id text, -- Added entity ID
timestamp timestamptz default now()
);

-- Enable RLS on admin_activity_log
alter table public.admin_activity_log enable row level security;

-- Bảng banners
create table public.banners (
id bigint generated by default as identity primary key,
title text not null,
subtitle text,
image_url text not null,
link_url text,
is_active boolean default true,
display_order int default 0, -- Added display order
start_date timestamptz,
end_date timestamptz,
created_at timestamptz default now(),
updated_at timestamptz default now()
);

-- Enable RLS on banners
alter table public.banners enable row level security;

-- RLS policies for banners
create policy "Banners are viewable by everyone"
on public.banners for select
to anon, authenticated
using (is_active = true and (start_date is null or start_date <= now()) and (end_date is null or end_date >= now()));

-- Bảng shop_settings (Updated with social media)
create table public.shop_settings (
id smallint primary key default 1, -- Đảm bảo chỉ có một bản ghi, ID luôn là 1
shop_name text not null,
contact_email text,
contact_phone text,
facebook_url text, -- Added social media
messenger_url text, -- Added messenger
zalo_url text, -- Added Zalo
instagram_url text, -- Added Instagram
tiktok_url text, -- Added TikTok
youtube_url text, -- Added YouTube
refund_policy_text text,
shipping_policy_text text, -- Added shipping policy
privacy_policy_text text, -- Added privacy policy
terms_conditions_text text, -- Added terms and conditions
created_at timestamptz default now(),
updated_at timestamptz default now(),
constraint single_row check (id = 1)
);

-- Enable RLS on shop_settings
alter table public.shop_settings enable row level security;

-- RLS policies for shop_settings
create policy "Shop settings are viewable by everyone"
on public.shop_settings for select
to anon, authenticated
using (true);

-- Create indexes to improve performance
create index idx_products_brand_id on public.products (brand_id);
create index idx_products_gender_id on public.products (gender_id);
create index idx_products_perfume_type_id on public.products (perfume_type_id);
create index idx_products_concentration_id on public.products (concentration_id);
create index idx_product_variants_product_id on public.product_variants (product_id);
create index idx_product_scents_product_id on public.product_scents (product_id);
create index idx_product_ingredients_product_id on public.product_ingredients (product_id);
create index idx_product_categories_product_id on public.product_categories (product_id);
create index idx_product_images_product_id on public.product_images (product_id);
create index idx_cart_items_cart_id on public.cart_items (cart_id);
create index idx_cart_items_variant_id on public.cart_items (variant_id);
create index idx_order_items_order_id on public.order_items (order_id);
create index idx_order_items_variant_id on public.order_items (variant_id);
create index idx_orders_user_id on public.orders (user_id);
create index idx_orders_payment_method_id on public.orders (payment_method_id);
create index idx_payments_order_id on public.payments (order_id);
create index idx_inventory_variant_id on public.inventory (variant_id);
create index idx_reviews_product_id on public.reviews (product_id);
create index idx_reviews_user_id on public.reviews (user_id);
create index idx_review_replies_review_id on public.review_replies (review_id);
create index idx_wishlists_user_id on public.wishlists (user_id);
create index idx_wishlists_product_id on public.wishlists (product_id);
create index idx_admin_activity_log_admin_user_id on public.admin_activity_log (admin_user_id);
create index idx_profiles_default_address_id on public.profiles (default_address_id);
create index idx_orders_order_status_id on public.orders (order_status_id);
create index idx_orders_discount_id on public.orders (discount_id);
create index idx_product_label_assignments_product_id on public.product_label_assignments (product_id);
create index idx_product_label_assignments_label_id on public.product_label_assignments (label_id);

-- Create function to update updated_at timestamp
create or replace function public.handle_updated_at()
returns trigger 
security definer
set search_path = public
as $$
begin
new.updated_at = now();
return new;
end;
$$ language plpgsql;

-- Create triggers for updated_at
create trigger set_updated_at
before update on public.addresses
for each row execute procedure public.handle_updated_at();

create trigger set_updated_at
before update on public.profiles
for each row execute procedure public.handle_updated_at();

create trigger set_updated_at
before update on public.brands
for each row execute procedure public.handle_updated_at();

create trigger set_updated_at
before update on public.genders
for each row execute procedure public.handle_updated_at();

create trigger set_updated_at
before update on public.perfume_types
for each row execute procedure public.handle_updated_at();

create trigger set_updated_at
before update on public.concentrations
for each row execute procedure public.handle_updated_at();

create trigger set_updated_at
before update on public.categories
for each row execute procedure public.handle_updated_at();

create trigger set_updated_at
before update on public.products
for each row execute procedure public.handle_updated_at();

create trigger set_updated_at
before update on public.scents
for each row execute procedure public.handle_updated_at();

create trigger set_updated_at
before update on public.ingredients
for each row execute procedure public.handle_updated_at();

create trigger set_updated_at
before update on public.product_variants
for each row execute procedure public.handle_updated_at();

create trigger set_updated_at
before update on public.product_images
for each row execute procedure public.handle_updated_at();

create trigger set_updated_at
before update on public.product_labels
for each row execute procedure public.handle_updated_at();

create trigger set_updated_at
before update on public.discounts
for each row execute procedure public.handle_updated_at();

create trigger set_updated_at
before update on public.shopping_carts
for each row execute procedure public.handle_updated_at();

create trigger set_updated_at
before update on public.cart_items
for each row execute procedure public.handle_updated_at();

create trigger set_updated_at
before update on public.orders
for each row execute procedure public.handle_updated_at();

create trigger set_updated_at
before update on public.order_items
for each row execute procedure public.handle_updated_at();

create trigger set_updated_at
before update on public.payments
for each row execute procedure public.handle_updated_at();

create trigger set_updated_at
before update on public.inventory
for each row execute procedure public.handle_updated_at();

create trigger set_updated_at
before update on public.reviews
for each row execute procedure public.handle_updated_at();

create trigger set_updated_at
before update on public.review_replies
for each row execute procedure public.handle_updated_at();

create trigger set_updated_at
before update on public.wishlists
for each row execute procedure public.handle_updated_at();

create trigger set_updated_at
before update on public.banners
for each row execute procedure public.handle_updated_at();

create trigger set_updated_at
before update on public.shop_settings
for each row execute procedure public.handle_updated_at();

-- Create custom claims function for role checking
create or replace function public.get_auth_role()
returns text 
security definer
set search_path = public
as $$
select coalesce(
nullif(current_setting('request.jwt.claims', true)::json->>'role', ''),
'authenticated'
)
$$ language sql stable;

-- Create helper function to check if user is admin
create or replace function public.is_admin()
returns boolean 
security definer
set search_path = public
as $$
select public.get_auth_role() = 'admin'
$$ language sql stable;

-- Create helper function to check if user is staff
create or replace function public.is_staff()
returns boolean 
security definer
set search_path = public
as $$
select public.get_auth_role() = 'staff' or public.get_auth_role() = 'admin'
$$ language sql stable;

-- Admin policies using the is_admin() function
create policy "Admins can manage all addresses"
on public.addresses
using (public.is_admin());

create policy "Admins can manage all profiles"
on public.profiles
using (public.is_admin());

create policy "Only admins can manage brands"
on public.brands
using (public.is_admin());

create policy "Only admins can manage genders"
on public.genders
using (public.is_admin());

create policy "Only admins can manage perfume types"
on public.perfume_types
using (public.is_admin());

create policy "Only admins can manage concentrations"
on public.concentrations
using (public.is_admin());

create policy "Only admins can manage categories"
on public.categories
using (public.is_admin());

create policy "Only admins can manage products"
on public.products
using (public.is_admin());

create policy "Only admins can manage scents"
on public.scents
using (public.is_admin());

create policy "Only admins can manage ingredients"
on public.ingredients
using (public.is_admin());

create policy "Only admins can manage product variants"
on public.product_variants
using (public.is_admin());

create policy "Only admins can manage product scents"
on public.product_scents
using (public.is_admin());

create policy "Only admins can manage product ingredients"
on public.product_ingredients
using (public.is_admin());

create policy "Only admins can manage product images"
on public.product_images
using (public.is_admin());

create policy "Only admins can manage product categories"
on public.product_categories
using (public.is_admin());

create policy "Only admins can manage product labels"
on public.product_labels
using (public.is_admin());

create policy "Only admins can manage product label assignments"
on public.product_label_assignments
using (public.is_admin());

create policy "Only admins can manage discounts"
on public.discounts
using (public.is_admin());

create policy "Admins can manage all shopping carts"
on public.shopping_carts
using (public.is_admin());

create policy "Admins can manage all cart items"
on public.cart_items
using (public.is_admin());

create policy "Only admins can manage order statuses"
on public.order_statuses
using (public.is_admin());

create policy "Only admins can manage payment methods"
on public.payment_methods
using (public.is_admin());

-- Staff policies using the is_staff() function
create policy "Staff can view all orders"
on public.orders
using (public.is_staff());

create policy "Staff can update orders"
on public.orders
using (public.is_staff());

create policy "Staff can view all order items"
on public.order_items
using (public.is_staff());

create policy "Staff can update order items"
on public.order_items
using (public.is_staff());

create policy "Staff can view all payments"
on public.payments
using (public.is_staff());

create policy "Staff can manage payments"
on public.payments
using (public.is_staff());

create policy "Only admins can manage inventory"
on public.inventory
using (public.is_admin());

create policy "Staff can view all reviews"
on public.reviews
using (public.is_staff());

create policy "Staff can approve reviews"
on public.reviews for update
using (public.is_staff());

create policy "Staff can reply to reviews"
on public.review_replies for insert
with check (public.is_staff());

create policy "Staff can manage review replies"
on public.review_replies
using (public.is_staff());

create policy "Admins can manage all wishlists"
on public.wishlists
using (public.is_admin());

create policy "Only admins can view admin activity logs"
on public.admin_activity_log
using (public.is_admin());

create policy "Only admins can insert admin activity logs"
on public.admin_activity_log
with check (public.is_admin());

create policy "Only admins can manage banners"
on public.banners
using (public.is_admin());

create policy "Only admins can manage shop settings"
on public.shop_settings
using (public.is_admin());

-- Create a function to check if a user has purchased a product (for review policies)
create or replace function public.has_user_purchased_product(product_id bigint)
returns boolean
security definer
set search_path = public
as $$
begin
return exists (
  select 1 
  from public.orders o
  join public.order_items oi on o.id = oi.order_id
  join public.product_variants pv on oi.variant_id = pv.id
  where o.user_id = auth.uid()
  and pv.product_id = product_id
  and o.order_status_id in (
    select id from public.order_statuses 
    where name in ('Delivered', 'Completed')
  )
);
end;
$$ language plpgsql;

-- Add a more restrictive review policy that only allows reviews from users who purchased the product
drop policy if exists "Users can insert their own reviews" on public.reviews;
create policy "Users can insert reviews for purchased products"
on public.reviews for insert
with check (
  auth.uid() = user_id and 
  public.has_user_purchased_product(product_id)
);

-- Add a function to automatically update inventory when order status changes to 'Shipped'
create or replace function public.update_inventory_on_order_shipped()
returns trigger
security definer
set search_path = public
as $$
begin
if new.order_status_id = (select id from public.order_statuses where name = 'Shipped') and 
   (old.order_status_id is null or old.order_status_id != new.order_status_id) then
  
  -- Update inventory for each item in the order
  update public.product_variants pv
  set stock_quantity = pv.stock_quantity - oi.quantity
  from public.order_items oi
  where oi.order_id = new.id and oi.variant_id = pv.id;
  
  -- Log the inventory update
  insert into public.admin_activity_log (admin_user_id, activity_type, description, entity_type, entity_id)
  values (auth.uid(), 'INVENTORY_UPDATE', 'Inventory updated automatically when order ' || new.id || ' was shipped', 'order', new.id::text);
end if;

return new;
end;
$$ language plpgsql;

-- Create trigger for inventory update
create trigger update_inventory_on_order_shipped
after update on public.orders
for each row execute procedure public.update_inventory_on_order_shipped();

-- Add a function to validate stock before adding to cart
create or replace function public.validate_stock_before_cart_insert()
returns trigger
security definer
set search_path = public
as $$
declare
available_stock integer;
begin
-- Get available stock
select stock_quantity into available_stock
from public.product_variants
where id = new.variant_id;

-- Check if enough stock is available
if available_stock < new.quantity then
  raise exception 'Not enough stock available. Only % items remaining.', available_stock;
end if;

return new;
end;
$$ language plpgsql;

-- Create trigger for stock validation
create trigger validate_stock_before_cart_insert
before insert or update on public.cart_items
for each row execute procedure public.validate_stock_before_cart_insert();

-- Add a function to automatically create a shopping cart for new users
create or replace function public.create_shopping_cart_for_new_user()
returns trigger
security definer
set search_path = public
as $$
begin
insert into public.shopping_carts (user_id)
values (new.id);
return new;
end;
$$ language plpgsql;

-- Create trigger for new user shopping cart
create trigger create_shopping_cart_for_new_user
after insert on auth.users
for each row execute procedure public.create_shopping_cart_for_new_user();

-- Add a function to generate slugs for products
create or replace function public.generate_slug(name text)
returns text
security definer
set search_path = public
as $$
begin
return lower(regexp_replace(name, '[^a-zA-Z0-9]+', '-', 'g'));
end;
$$ language plpgsql;

-- Create trigger to automatically generate slugs for products
create or replace function public.set_product_slug()
returns trigger
security definer
set search_path = public
as $$
begin
if new.slug is null or new.slug = '' then
  new.slug := public.generate_slug(new.name);
  
  -- Ensure slug is unique by appending a number if needed
  while exists (select 1 from public.products where slug = new.slug and id != new.id) loop
    new.slug := new.slug || '-' || floor(random() * 1000)::text;
  end loop;
end if;

return new;
end;
$$ language plpgsql;

-- Create trigger for product slug generation
create trigger set_product_slug
before insert or update on public.products
for each row execute procedure public.set_product_slug();

-- Create trigger to automatically generate slugs for categories
create or replace function public.set_category_slug()
returns trigger
security definer
set search_path = public
as $$
begin
if new.slug is null or new.slug = '' then
  new.slug := public.generate_slug(new.name);
  
  -- Ensure slug is unique by appending a number if needed
  while exists (select 1 from public.categories where slug = new.slug and id != new.id) loop
    new.slug := new.slug || '-' || floor(random() * 1000)::text;
  end loop;
end if;

return new;
end;
$$ language plpgsql;

-- Create trigger for category slug generation
create trigger set_category_slug
before insert or update on public.categories
for each row execute procedure public.set_category_slug();

-- Add a function to validate discount code usage
create or replace function public.validate_discount_code()
returns trigger
security definer
set search_path = public
as $$
declare
discount_record public.discounts%rowtype;
begin
-- Get discount record
select * into discount_record
from public.discounts
where id = new.discount_id;

-- Check if discount exists
if discount_record is null then
  return new; -- No discount applied
end if;

-- Check if discount is active (within date range)
if (discount_record.start_date is not null and discount_record.start_date > now()) or
   (discount_record.end_date is not null and discount_record.end_date < now()) or
   discount_record.is_active = false then
  raise exception 'Discount code is not active at this time';
end if;

-- Check if discount has remaining uses
if discount_record.max_uses is not null and 
   discount_record.remaining_uses is not null and 
   discount_record.remaining_uses <= 0 then
  raise exception 'Discount code has reached maximum usage limit';
end if;

-- Check minimum order value
if discount_record.min_order_value is not null and 
   new.subtotal_amount < discount_record.min_order_value then
  raise exception 'Order total does not meet minimum amount for this discount code';
end if;

-- Decrement remaining uses
if discount_record.remaining_uses is not null then
  update public.discounts
  set remaining_uses = remaining_uses - 1
  where id = new.discount_id;
end if;

return new;
end;
$$ language plpgsql;

-- Create trigger for discount validation
create trigger validate_discount_code
before insert on public.orders
for each row execute procedure public.validate_discount_code();

-- Add a function to calculate and update order total
create or replace function public.calculate_order_total()
returns trigger
security definer
set search_path = public
as $$
declare
items_total numeric := 0;
discount_amount numeric := 0;
discount_record public.discounts%rowtype;
begin
-- Calculate items total
select coalesce(sum(quantity * unit_price_at_order), 0) into items_total
from public.order_items
where order_id = new.id;

-- Set subtotal
new.subtotal_amount := items_total;

-- Apply discount if present
if new.discount_id is not null then
  select * into discount_record
  from public.discounts
  where id = new.discount_id;
  
  if discount_record.discount_percentage is not null then
    discount_amount := items_total * (discount_record.discount_percentage / 100);
    
    -- Apply maximum discount amount if specified
    if discount_record.max_discount_amount is not null and 
       discount_amount > discount_record.max_discount_amount then
      discount_amount := discount_record.max_discount_amount;
    end if;
  end if;
end if;

-- Update discount amount
new.discount_amount := discount_amount;

-- Update total amount
new.total_amount := items_total - discount_amount;

return new;
end;
$$ language plpgsql;

-- Create trigger for order total calculation
create trigger calculate_order_total
before insert or update on public.orders
for each row execute procedure public.calculate_order_total();

-- Add a function to log admin activities
create or replace function public.log_admin_activity()
returns trigger
security definer
set search_path = public
as $$
declare
activity_type text;
description text;
entity_type text;
entity_id text;
begin
-- Determine activity type, description, entity type and ID based on the table and operation
if TG_TABLE_NAME = 'products' then
  entity_type := 'product';
  entity_id := new.id::text;
  
  if TG_OP = 'INSERT' then
    activity_type := 'PRODUCT_CREATE';
    description := 'Created product: ' || new.name;
  elsif TG_OP = 'UPDATE' then
    activity_type := 'PRODUCT_UPDATE';
    description := 'Updated product: ' || new.name;
  elsif TG_OP = 'DELETE' then
    activity_type := 'PRODUCT_DELETE';
    description := 'Deleted product: ' || old.name;
    entity_id := old.id::text;
  end if;
elsif TG_TABLE_NAME = 'orders' then
  entity_type := 'order';
  entity_id := new.id::text;
  
  if TG_OP = 'UPDATE' and old.order_status_id != new.order_status_id then
    activity_type := 'ORDER_STATUS_CHANGE';
    description := 'Changed order #' || new.id || ' status from ' || 
                  (select name from public.order_statuses where id = old.order_status_id) || 
                  ' to ' || 
                  (select name from public.order_statuses where id = new.order_status_id);
  end if;
elsif TG_TABLE_NAME = 'reviews' then
  entity_type := 'review';
  entity_id := new.id::text;
  
  if TG_OP = 'UPDATE' and (old.is_approved is distinct from new.is_approved) and new.is_approved = true then
    activity_type := 'REVIEW_APPROVE';
    description := 'Approved review #' || new.id || ' for product #' || new.product_id;
  end if;
end if;

-- Log activity if type is determined
if activity_type is not null and (public.is_admin() or public.is_staff()) then
  insert into public.admin_activity_log (admin_user_id, activity_type, description, entity_type, entity_id)
  values (auth.uid(), activity_type, description, entity_type, entity_id);
end if;

return null;
end;
$$ language plpgsql;

-- Create triggers for admin activity logging
create trigger log_admin_activity_products
after insert or update or delete on public.products
for each row execute procedure public.log_admin_activity();

create trigger log_admin_activity_orders
after update on public.orders
for each row execute procedure public.log_admin_activity();

create trigger log_admin_activity_reviews
after update on public.reviews
for each row execute procedure public.log_admin_activity();

-- Add a function to approve reviews
create or replace function public.approve_review(review_id bigint)
returns void
security definer
set search_path = public
as $$
begin
  -- Check if user is staff or admin
  if not public.is_staff() then
    raise exception 'Only staff or admin can approve reviews';
  end if;
  
  -- Update review
  update public.reviews
  set 
    is_approved = true,
    approved_by = auth.uid(),
    approved_at = now()
  where id = review_id;
end;
$$ language plpgsql;

-- Add a function to reply to reviews
create or replace function public.reply_to_review(review_id bigint, reply_text text)
returns bigint
security definer
set search_path = public
as $$
declare
  new_reply_id bigint;
begin
  -- Check if user is staff or admin
  if not public.is_staff() then
    raise exception 'Only staff or admin can reply to reviews';
  end if;
  
  -- Insert reply
  insert into public.review_replies (review_id, staff_id, reply_text)
  values (review_id, auth.uid(), reply_text)
  returning id into new_reply_id;
  
  return new_reply_id;
end;
$$ language plpgsql;

-- Add comments to explain the schema
comment on table public.products is 'Stores perfume product information';
comment on table public.product_variants is 'Stores different sizes/variants of perfume products';
comment on table public.orders is 'Stores customer order information';
comment on table public.reviews is 'Stores customer reviews for products';
comment on table public.profiles is 'Stores extended user profile information';
comment on table public.addresses is 'Stores user shipping and billing addresses';
comment on table public.inventory is 'Tracks product variant inventory levels';
comment on table public.admin_activity_log is 'Logs all admin activities for auditing';
comment on table public.concentrations is 'Stores perfume concentration types (EDP, EDT, etc.)';
comment on table public.perfume_types is 'Stores perfume types (Designer, Niche, etc.)';
comment on table public.review_replies is 'Stores staff replies to customer reviews';
comment on table public.payment_methods is 'Stores available payment methods';


-- ============================================================================
-- SUPABASE COMPLETE SETUP SCRIPT (Run ONCE)
-- Creates tables, RLS, functions, triggers, storage for a perfume shop.
-- Includes secure guest order access via token.
-- ============================================================================

-- Required Extensions
create extension if not exists "uuid-ossp";

-- ============================================================================
-- SECTION: TABLES (Database Structure)
-- ============================================================================

-- Địa chỉ người dùng
create table public.addresses (
    id bigint generated by default as identity primary key,
    user_id uuid references auth.users on delete cascade,
    recipient_name text not null,
    recipient_phone text not null,
    province_city text not null,
    district text not null,
    ward text not null,
    street_address text not null,
    postal_code text, -- Optional in VN
    is_default boolean default false,
    created_at timestamptz default now(),
    updated_at timestamptz default now()
);
comment on table public.addresses is 'User shipping/billing addresses';

-- Thông tin mở rộng của người dùng (liên kết với auth.users)
create table public.profiles (
    id uuid not null primary key references auth.users on delete cascade,
    display_name text,
    phone_number text,
    gender text,
    birth_date date,
    avatar_url text, -- URL to avatar image in 'avatars' bucket
    default_address_id bigint references public.addresses on delete set null,
    created_at timestamptz default now(),
    updated_at timestamptz default now()
);
comment on table public.profiles is 'Extended user profile info';

-- Thương hiệu nước hoa
create table public.brands (
    id bigint generated by default as identity primary key,
    name text unique not null,
    description text,
    logo_url text, -- URL to brand logo in 'logos' bucket
    created_at timestamptz default now(),
    updated_at timestamptz default now()
);

-- Giới tính (Nam, Nữ, Unisex)
create table public.genders (
    id smallint generated by default as identity primary key,
    name text unique not null,
    created_at timestamptz default now(),
    updated_at timestamptz default now()
);

-- Loại nước hoa (Designer, Niche)
create table public.perfume_types (
    id smallint generated by default as identity primary key,
    name text unique not null,
    created_at timestamptz default now(),
    updated_at timestamptz default now()
);
comment on table public.perfume_types is 'Perfume types (Designer, Niche, etc.)';

-- Nồng độ (EDP, EDT, Extrait)
create table public.concentrations (
    id smallint generated by default as identity primary key,
    name text unique not null,
    description text,
    created_at timestamptz default now(),
    updated_at timestamptz default now()
);
comment on table public.concentrations is 'Perfume concentration types (EDP, EDT, etc.)';

-- Danh mục sản phẩm (có thể phân cấp)
create table public.categories (
    id bigint generated by default as identity primary key,
    name text not null unique,
    slug text unique, -- Auto-generated URL-friendly name
    description text,
    image_url text, -- URL to category image in 'categories' bucket
    is_featured boolean default false, -- Show on homepage?
    display_order int default 0, -- Control sorting
    parent_category_id bigint references public.categories on delete set null, -- For subcategories
    created_at timestamptz default now(),
    updated_at timestamptz default now()
);

-- Sản phẩm nước hoa chính
create table public.products (
    id bigint generated by default as identity primary key,
    name text not null,
    slug text unique, -- Auto-generated URL-friendly name
    product_code text,
    short_description text,
    long_description text,
    brand_id bigint references public.brands on delete set null,
    gender_id smallint references public.genders on delete set null,
    perfume_type_id smallint references public.perfume_types on delete set null,
    concentration_id smallint references public.concentrations on delete set null,
    origin_country text,
    release_year smallint,
    style text, -- e.g., Sexy, Sweet, Elegant
    sillage text, -- Projection level
    longevity text, -- How long it lasts
    created_at timestamptz default now(),
    updated_at timestamptz default now(),
    deleted_at timestamptz -- For soft deletes
);
comment on table public.products is 'Core perfume product information';

-- Các nhóm mùi hương (Woody, Citrus, Floral)
create table public.scents (
    id bigint generated by default as identity primary key,
    name text unique not null,
    description text,
    created_at timestamptz default now(),
    updated_at timestamptz default now()
);

-- Thành phần (Alcohol, Limonene, Linalool)
create table public.ingredients (
    id bigint generated by default as identity primary key,
    name text unique not null,
    created_at timestamptz default now(),
    updated_at timestamptz default now()
);

-- Phiên bản sản phẩm (theo dung tích, giá)
create table public.product_variants (
    id bigint generated by default as identity primary key,
    product_id bigint not null references public.products on delete cascade,
    volume_ml integer not null, -- e.g., 50, 100
    price numeric not null,
    sale_price numeric, -- Optional sale price
    sku text unique, -- Stock Keeping Unit
    stock_quantity integer not null default 0, -- Current inventory level
    created_at timestamptz default now(),
    updated_at timestamptz default now(),
    deleted_at timestamptz -- For soft deletes
);
comment on table public.product_variants is 'Different sizes/prices for a product. Stock source of truth.';

-- Liên kết Sản phẩm - Mùi hương (theo tầng hương)
create table public.product_scents (
    id bigint generated by default as identity primary key,
    product_id bigint not null references public.products on delete cascade,
    scent_id bigint not null references public.scents on delete cascade,
    scent_type text not null check (scent_type in ('top', 'middle', 'base')), -- Note type (Top, Middle, Base)
    unique (product_id, scent_id, scent_type)
);

-- Liên kết Sản phẩm - Thành phần
create table public.product_ingredients (
    id bigint generated by default as identity primary key,
    product_id bigint not null references public.products on delete cascade,
    ingredient_id bigint not null references public.ingredients on delete cascade,
    unique (product_id, ingredient_id)
);

-- Hình ảnh sản phẩm
create table public.product_images (
    id bigint generated by default as identity primary key,
    product_id bigint not null references public.products on delete cascade,
    image_url text not null, -- URL to image in 'products' bucket
    alt_text text,
    is_main boolean default false, -- Is this the primary image?
    display_order int default 0, -- Control sorting
    created_at timestamptz default now(),
    updated_at timestamptz default now()
);

-- Liên kết Sản phẩm - Danh mục
create table public.product_categories (
    id bigint generated by default as identity primary key,
    product_id bigint not null references public.products on delete cascade,
    category_id bigint not null references public.categories on delete cascade,
    unique (product_id, category_id)
);

-- Nhãn sản phẩm (Mới, Sale, Bán chạy)
create table public.product_labels (
    id bigint generated by default as identity primary key,
    name text unique not null,
    color_code varchar(7), -- e.g., #FF0000
    created_at timestamptz default now(),
    updated_at timestamptz default now()
);

-- Gán nhãn cho sản phẩm (có thể có hạn)
create table public.product_label_assignments (
    id bigint generated by default as identity primary key,
    product_id bigint not null references public.products on delete cascade,
    label_id bigint not null references public.product_labels on delete cascade,
    valid_until timestamptz, -- Optional expiration date for the label
    unique (product_id, label_id)
);

-- Mã giảm giá
create table public.discounts (
    id bigint generated by default as identity primary key,
    code text unique not null, -- The discount code itself
    description text,
    start_date timestamptz,
    end_date timestamptz,
    max_uses integer, -- Max times the code can be used overall
    remaining_uses integer, -- How many uses are left
    min_order_value numeric, -- Minimum cart value to apply
    max_discount_amount numeric, -- Max discount value (for percentage codes)
    discount_percentage numeric, -- Percentage off (NULL if fixed amount)
    is_active boolean default true,
    created_at timestamptz default now(),
    updated_at timestamptz default now()
);

-- Giỏ hàng (mỗi user có 1 giỏ)
create table public.shopping_carts (
    id bigint generated by default as identity primary key,
    user_id uuid references auth.users on delete cascade unique, -- One cart per user
    created_at timestamptz default now(),
    updated_at timestamptz default now()
);

-- Các sản phẩm trong giỏ hàng
create table public.cart_items (
    id bigint generated by default as identity primary key,
    cart_id bigint not null references public.shopping_carts on delete cascade,
    variant_id bigint not null references public.product_variants on delete cascade, -- Which specific variant?
    quantity integer not null check (quantity > 0),
    created_at timestamptz default now(),
    updated_at timestamptz default now(),
    unique(cart_id, variant_id) -- No duplicate variants in the same cart
);

-- Trạng thái đơn hàng (Chờ xử lý, Đang giao,...)
create table public.order_statuses (
    id smallint generated by default as identity primary key,
    name text unique not null
);

-- Phương thức thanh toán (COD, Momo,...)
create table public.payment_methods (
    id smallint generated by default as identity primary key,
    name text unique not null,
    description text,
    is_active boolean default true
);
comment on table public.payment_methods is 'Available payment methods';

-- Đơn hàng
create table public.orders (
    id bigint generated by default as identity primary key,
    access_token uuid not null default uuid_generate_v4() unique, -- Secure token for GUEST order lookup via RPC
    user_id uuid references auth.users on delete set null, -- Null if guest order
    -- Guest info (if user_id is NULL)
    guest_name text,
    guest_email text,
    guest_phone text,
    -- Shipping address (copied at time of order)
    recipient_name text not null,
    recipient_phone text not null,
    province_city text not null,
    district text not null,
    ward text not null,
    street_address text not null,
    -- Order details
    order_date timestamptz default now(),
    delivery_notes text,
    payment_method_id smallint references public.payment_methods(id),
    payment_status text check (payment_status in ('Pending', 'Paid', 'Failed', 'Refunded')) default 'Pending',
    order_status_id smallint references public.order_statuses(id),
    tracking_number text, -- Shipping tracking code
    discount_id bigint references public.discounts on delete set null, -- Applied discount
    subtotal_amount numeric not null default 0, -- Price before discount/shipping
    discount_amount numeric default 0, -- Calculated discount value
    shipping_fee numeric default 0, -- Shipping cost
    total_amount numeric not null default 0, -- Final price
    created_at timestamptz default now(),
    updated_at timestamptz default now()
);
comment on table public.orders is 'Customer orders. Includes secure access_token for guest lookup.';

-- Chi tiết các sản phẩm trong đơn hàng
create table public.order_items (
    id bigint generated by default as identity primary key,
    order_id bigint not null references public.orders on delete cascade,
    variant_id bigint not null references public.product_variants on delete restrict, -- Prevent deleting variant if in an order
    product_name text not null, -- Snapshot of name at time of order
    variant_volume_ml integer not null, -- Snapshot of volume at time of order
    quantity integer not null check (quantity > 0),
    unit_price_at_order numeric not null, -- Snapshot of price at time of order
    created_at timestamptz default now(),
    updated_at timestamptz default now()
);

-- Thông tin thanh toán chi tiết (nếu có)
create table public.payments (
    id bigint generated by default as identity primary key,
    order_id bigint not null references public.orders on delete cascade,
    payment_date timestamptz default now(),
    payment_method_id smallint references public.payment_methods(id),
    transaction_id text, -- ID from payment gateway
    amount numeric not null,
    status text check (status in ('Pending', 'Completed', 'Failed', 'Refunded')) default 'Pending',
    payment_details jsonb, -- Store extra data from gateway (e.g., card type)
    created_at timestamptz default now(),
    updated_at timestamptz default now()
);

-- Lịch sử thay đổi kho hàng (log)
create table public.inventory (
    id bigint generated by default as identity primary key,
    variant_id bigint not null references public.product_variants on delete cascade,
    change_amount integer not null, -- + for stock in, - for stock out
    reason text, -- e.g., 'Order Shipped', 'Stock Adjustment'
    order_id bigint references public.orders on delete set null, -- Link to order if applicable
    stock_after_change integer, -- Optional: snapshot of stock level after change
    updated_by uuid references auth.users on delete set null, -- Who made the change (if manual)
    timestamp timestamptz default now(),
    created_at timestamptz default now(),
    updated_at timestamptz default now()
);
comment on table public.inventory is 'Log of inventory changes. product_variants.stock_quantity is the source of truth.';

-- Đánh giá sản phẩm
create table public.reviews (
    id bigint generated by default as identity primary key,
    product_id bigint not null references public.products on delete cascade,
    user_id uuid not null references auth.users on delete cascade,
    order_item_id bigint references public.order_items on delete set null, -- Link review to a specific purchase (optional)
    rating smallint not null check (rating >= 1 and rating <= 5),
    comment text,
    is_approved boolean default false, -- Requires admin/staff approval
    approved_by uuid references auth.users on delete set null, -- Who approved it
    approved_at timestamptz, -- When it was approved
    created_at timestamptz default now(),
    updated_at timestamptz default now(),
    unique(user_id, product_id) -- One review per user per product
);
comment on table public.reviews is 'Customer product reviews (require approval)';

-- Phản hồi đánh giá (từ admin/staff)
create table public.review_replies (
    id bigint generated by default as identity primary key,
    review_id bigint not null references public.reviews on delete cascade,
    staff_id uuid not null references auth.users on delete cascade, -- User who replied (must be staff/admin)
    reply_text text not null,
    created_at timestamptz default now(),
    updated_at timestamptz default now()
);
comment on table public.review_replies is 'Staff/admin replies to customer reviews';

-- Danh sách yêu thích của người dùng
create table public.wishlists (
    id bigint generated by default as identity primary key,
    user_id uuid not null references auth.users on delete cascade,
    product_id bigint not null references public.products on delete cascade, -- Link to product, not variant
    added_at timestamptz default now(),
    unique (user_id, product_id)
);

-- Log hoạt động của admin/staff
create table public.admin_activity_log (
    id bigint generated by default as identity primary key,
    admin_user_id uuid references auth.users on delete set null, -- User performing action (or system)
    activity_type text not null, -- e.g., 'PRODUCT_UPDATE', 'ORDER_STATUS_CHANGE'
    description text,
    entity_type text, -- e.g., 'product', 'order'
    entity_id text, -- ID of the affected entity
    details jsonb, -- Store before/after data (optional)
    timestamp timestamptz default now()
);
comment on table public.admin_activity_log is 'Audit log for admin/staff actions';

-- Banner quảng cáo
create table public.banners (
    id bigint generated by default as identity primary key,
    title text not null,
    subtitle text,
    image_url text not null, -- URL to banner image in 'banners' bucket
    link_url text, -- Where the banner links to
    is_active boolean default true,
    display_order int default 0, -- Control sorting
    start_date timestamptz, -- Optional activation date
    end_date timestamptz, -- Optional expiration date
    created_at timestamptz default now(),
    updated_at timestamptz default now()
);

-- Cài đặt chung của cửa hàng (chỉ có 1 dòng)
create table public.shop_settings (
    id smallint primary key default 1, -- Enforces single row with id=1
    shop_name text not null,
    shop_logo_url text, -- URL to main shop logo in 'logos' bucket
    contact_email text,
    contact_phone text,
    address text, -- Shop physical address
    facebook_url text,
    messenger_url text,
    zalo_url text,
    instagram_url text,
    tiktok_url text,
    youtube_url text,
    refund_policy_text text, -- Store policy text (can be HTML)
    shipping_policy_text text,
    privacy_policy_text text,
    terms_conditions_text text,
    default_shipping_fee numeric default 0, -- Default shipping cost if not calculated
    created_at timestamptz default now(),
    updated_at timestamptz default now(),
    constraint single_row check (id = 1)
);
comment on table public.shop_settings is 'Global shop settings (single row)';

-- ============================================================================
-- SECTION: ROW LEVEL SECURITY (RLS) - Enable RLS for all tables
-- ============================================================================

alter table public.addresses enable row level security;
alter table public.profiles enable row level security;
alter table public.brands enable row level security;
alter table public.genders enable row level security;
alter table public.perfume_types enable row level security;
alter table public.concentrations enable row level security;
alter table public.categories enable row level security;
alter table public.products enable row level security;
alter table public.scents enable row level security;
alter table public.ingredients enable row level security;
alter table public.product_variants enable row level security;
alter table public.product_scents enable row level security;
alter table public.product_ingredients enable row level security;
alter table public.product_images enable row level security;
alter table public.product_categories enable row level security;
alter table public.product_labels enable row level security;
alter table public.product_label_assignments enable row level security;
alter table public.discounts enable row level security;
alter table public.shopping_carts enable row level security;
alter table public.cart_items enable row level security;
alter table public.order_statuses enable row level security;
alter table public.payment_methods enable row level security;
alter table public.orders enable row level security;
alter table public.order_items enable row level security;
alter table public.payments enable row level security;
alter table public.inventory enable row level security;
alter table public.reviews enable row level security;
alter table public.review_replies enable row level security;
alter table public.wishlists enable row level security;
alter table public.admin_activity_log enable row level security;
alter table public.banners enable row level security;
alter table public.shop_settings enable row level security;

-- ============================================================================
-- SECTION: FUNCTIONS & TRIGGERS (Automations & Helpers)
-- ============================================================================

-- FUNCTION: Create profile when a new user signs up in auth.users
DROP FUNCTION IF EXISTS public.handle_new_user();
CREATE OR REPLACE FUNCTION public.handle_new_user()
RETURNS TRIGGER SECURITY DEFINER SET search_path = public AS $$
BEGIN
  INSERT INTO public.profiles (id, display_name, phone_number)
  VALUES (NEW.id, NEW.raw_user_meta_data->>'display_name', NEW.raw_user_meta_data->>'phone_number');
  RETURN NEW;
END;
$$ LANGUAGE plpgsql;

-- TRIGGER: Call handle_new_user after user insert
DROP TRIGGER IF EXISTS on_auth_user_created_profile ON auth.users;
CREATE TRIGGER on_auth_user_created_profile
AFTER INSERT ON auth.users FOR EACH ROW EXECUTE PROCEDURE public.handle_new_user();

-- FUNCTION: Create shopping cart for new user
DROP FUNCTION IF EXISTS public.create_shopping_cart_for_new_user();
CREATE OR REPLACE FUNCTION public.create_shopping_cart_for_new_user()
RETURNS TRIGGER SECURITY DEFINER SET search_path = public AS $$
BEGIN
  INSERT INTO public.shopping_carts (user_id) VALUES (NEW.id);
  RETURN NEW;
END;
$$ LANGUAGE plpgsql;

-- TRIGGER: Call create_shopping_cart_for_new_user after user insert
DROP TRIGGER IF EXISTS on_auth_user_created_cart ON auth.users;
CREATE TRIGGER on_auth_user_created_cart
AFTER INSERT ON auth.users FOR EACH ROW EXECUTE PROCEDURE public.create_shopping_cart_for_new_user();

-- FUNCTION: Automatically update 'updated_at' timestamp on row update
DROP FUNCTION IF EXISTS public.handle_updated_at();
create or replace function public.handle_updated_at()
returns trigger security definer set search_path = public as $$
begin
  new.updated_at = now();
  return new;
end;
$$ language plpgsql;

-- TRIGGERS: Apply handle_updated_at to all tables with 'updated_at'
create trigger set_updated_at before update on public.addresses for each row execute procedure public.handle_updated_at();
create trigger set_updated_at before update on public.profiles for each row execute procedure public.handle_updated_at();
create trigger set_updated_at before update on public.brands for each row execute procedure public.handle_updated_at();
create trigger set_updated_at before update on public.genders for each row execute procedure public.handle_updated_at();
create trigger set_updated_at before update on public.perfume_types for each row execute procedure public.handle_updated_at();
create trigger set_updated_at before update on public.concentrations for each row execute procedure public.handle_updated_at();
create trigger set_updated_at before update on public.categories for each row execute procedure public.handle_updated_at();
create trigger set_updated_at before update on public.products for each row execute procedure public.handle_updated_at();
create trigger set_updated_at before update on public.scents for each row execute procedure public.handle_updated_at();
create trigger set_updated_at before update on public.ingredients for each row execute procedure public.handle_updated_at();
create trigger set_updated_at before update on public.product_variants for each row execute procedure public.handle_updated_at();
create trigger set_updated_at before update on public.product_images for each row execute procedure public.handle_updated_at();
create trigger set_updated_at before update on public.product_labels for each row execute procedure public.handle_updated_at();
create trigger set_updated_at before update on public.discounts for each row execute procedure public.handle_updated_at();
create trigger set_updated_at before update on public.shopping_carts for each row execute procedure public.handle_updated_at();
create trigger set_updated_at before update on public.cart_items for each row execute procedure public.handle_updated_at();
create trigger set_updated_at before update on public.orders for each row execute procedure public.handle_updated_at();
create trigger set_updated_at before update on public.order_items for each row execute procedure public.handle_updated_at();
create trigger set_updated_at before update on public.payments for each row execute procedure public.handle_updated_at();
create trigger set_updated_at before update on public.inventory for each row execute procedure public.handle_updated_at();
create trigger set_updated_at before update on public.reviews for each row execute procedure public.handle_updated_at();
create trigger set_updated_at before update on public.review_replies for each row execute procedure public.handle_updated_at();
create trigger set_updated_at before update on public.wishlists for each row execute procedure public.handle_updated_at();
create trigger set_updated_at before update on public.banners for each row execute procedure public.handle_updated_at();
create trigger set_updated_at before update on public.shop_settings for each row execute procedure public.handle_updated_at();

-- FUNCTION: Get current user's role ('admin', 'staff', 'authenticated', 'anon') from auth metadata
DROP FUNCTION IF EXISTS public.get_auth_role();
CREATE OR REPLACE FUNCTION public.get_auth_role()
RETURNS TEXT LANGUAGE sql STABLE SECURITY DEFINER SET search_path = public AS $$
  SELECT CASE
    WHEN auth.uid() IS NULL THEN 'anon'
    ELSE coalesce((SELECT raw_app_meta_data->>'role' FROM auth.users WHERE id = auth.uid()), 'authenticated')
  END;
$$;
comment on function public.get_auth_role() is 'Gets user role from auth.users.raw_app_meta_data. Needs SECURITY DEFINER.';

-- FUNCTION: Helper to check if current user is admin
DROP FUNCTION IF EXISTS public.is_admin();
CREATE OR REPLACE FUNCTION public.is_admin()
RETURNS BOOLEAN LANGUAGE sql STABLE SECURITY DEFINER SET search_path = public
AS $$ SELECT public.get_auth_role() = 'admin'; $$;

-- FUNCTION: Helper to check if current user is staff or admin
DROP FUNCTION IF EXISTS public.is_staff();
CREATE OR REPLACE FUNCTION public.is_staff()
RETURNS BOOLEAN LANGUAGE sql STABLE SECURITY DEFINER SET search_path = public
AS $$ SELECT public.get_auth_role() IN ('staff', 'admin'); $$;

-- FUNCTION: Check if user has purchased a specific product (based on delivered orders)
DROP FUNCTION IF EXISTS public.has_user_purchased_product(bigint);
CREATE OR REPLACE FUNCTION public.has_user_purchased_product(p_product_id bigint)
RETURNS boolean LANGUAGE plpgsql STABLE SECURITY DEFINER SET search_path = public AS $$
DECLARE delivered_status_id smallint; BEGIN
  SELECT id INTO delivered_status_id FROM public.order_statuses WHERE name = 'Delivered';
  RETURN EXISTS (SELECT 1 FROM public.orders o JOIN public.order_items oi ON o.id = oi.order_id JOIN public.product_variants pv ON oi.variant_id = pv.id WHERE o.user_id = auth.uid() AND pv.product_id = p_product_id AND o.order_status_id = delivered_status_id);
END; $$;
comment on function public.has_user_purchased_product(bigint) is 'Checks if logged-in user purchased a product (order delivered). Used for review policy.';

-- FUNCTION: Update inventory stock when order status changes to 'Shipped'
DROP FUNCTION IF EXISTS public.update_inventory_on_order_shipped();
CREATE OR REPLACE FUNCTION public.update_inventory_on_order_shipped()
RETURNS TRIGGER LANGUAGE plpgsql SECURITY DEFINER SET search_path = public AS $$
DECLARE shipped_status_id smallint; item record; current_stock integer; BEGIN
  SELECT id INTO shipped_status_id FROM public.order_statuses WHERE name = 'Shipped';
  IF NEW.order_status_id = shipped_status_id AND (OLD.order_status_id IS NULL OR OLD.order_status_id != shipped_status_id) THEN
    FOR item IN SELECT variant_id, quantity FROM public.order_items WHERE order_id = NEW.id LOOP
      UPDATE public.product_variants pv SET stock_quantity = stock_quantity - item.quantity WHERE id = item.variant_id RETURNING stock_quantity INTO current_stock;
      INSERT INTO public.inventory (variant_id, change_amount, reason, order_id, stock_after_change, updated_by) VALUES (item.variant_id, -item.quantity, 'Order Shipped', NEW.id, current_stock, auth.uid());
    END LOOP;
    INSERT INTO public.admin_activity_log (admin_user_id, activity_type, description, entity_type, entity_id, details) VALUES (auth.uid(), 'INVENTORY_UPDATE', 'Stock decreased for order #' || NEW.id || ' shipped.', 'order', NEW.id::text, jsonb_build_object('order_id', NEW.id));
  END IF; RETURN NEW;
END; $$;

-- TRIGGER: Call update_inventory_on_order_shipped after order update
DROP TRIGGER IF EXISTS trigger_update_inventory_on_order_shipped ON public.orders;
CREATE TRIGGER trigger_update_inventory_on_order_shipped
AFTER UPDATE ON public.orders FOR EACH ROW EXECUTE PROCEDURE public.update_inventory_on_order_shipped();

-- FUNCTION: Validate stock before adding/updating cart items
DROP FUNCTION IF EXISTS public.validate_stock_before_cart_change();
CREATE OR REPLACE FUNCTION public.validate_stock_before_cart_change()
RETURNS TRIGGER LANGUAGE plpgsql SECURITY DEFINER SET search_path = public AS $$
DECLARE available_stock integer; product_name_text text; BEGIN
  SELECT pv.stock_quantity, p.name INTO available_stock, product_name_text FROM public.product_variants pv JOIN public.products p ON pv.product_id = p.id WHERE pv.id = NEW.variant_id;
  IF available_stock < NEW.quantity THEN RAISE EXCEPTION 'Không đủ hàng cho "%". Chỉ còn % sản phẩm.', product_name_text, available_stock; END IF;
  RETURN NEW;
END; $$;

-- TRIGGER: Call validate_stock_before_cart_change before cart item insert/update
DROP TRIGGER IF EXISTS trigger_validate_stock_before_cart_change ON public.cart_items;
CREATE TRIGGER trigger_validate_stock_before_cart_change
BEFORE INSERT OR UPDATE ON public.cart_items FOR EACH ROW EXECUTE PROCEDURE public.validate_stock_before_cart_change();

-- FUNCTION: Generate URL-friendly slug from text (basic Vietnamese support)
DROP FUNCTION IF EXISTS public.generate_slug(text);
CREATE OR REPLACE FUNCTION public.generate_slug(name_input text)
RETURNS text LANGUAGE sql IMMUTABLE STRICT SET search_path = public
AS $$ SELECT lower(regexp_replace(trim(name_input), '[^a-zA-Z0-9\u00C0-\u1EF9]+', '-', 'g')); $$;
comment on function public.generate_slug(text) is 'Generates URL slug. Sets search_path.';

-- FUNCTION: Auto-set product slug if empty or name changed
DROP FUNCTION IF EXISTS public.set_product_slug();
CREATE OR REPLACE FUNCTION public.set_product_slug()
RETURNS TRIGGER LANGUAGE plpgsql SECURITY DEFINER SET search_path = public AS $$
DECLARE base_slug text; final_slug text; counter integer := 0; BEGIN
  IF (TG_OP = 'INSERT' OR NEW.name != OLD.name) AND (NEW.slug IS NULL OR NEW.slug = '') THEN
    base_slug := public.generate_slug(NEW.name); final_slug := base_slug;
    WHILE EXISTS (SELECT 1 FROM public.products WHERE slug = final_slug AND (TG_OP = 'INSERT' OR id != OLD.id)) LOOP -- Fix for UPDATE
      counter := counter + 1; final_slug := base_slug || '-' || counter::text;
    END LOOP; NEW.slug := final_slug;
  END IF; RETURN NEW;
END; $$;

-- TRIGGER: Call set_product_slug before product insert/update
DROP TRIGGER IF EXISTS trigger_set_product_slug ON public.products;
CREATE TRIGGER trigger_set_product_slug BEFORE INSERT OR UPDATE OF name ON public.products FOR EACH ROW EXECUTE PROCEDURE public.set_product_slug(); -- Optimize trigger condition

-- FUNCTION: Auto-set category slug if empty or name changed
DROP FUNCTION IF EXISTS public.set_category_slug();
CREATE OR REPLACE FUNCTION public.set_category_slug()
RETURNS TRIGGER LANGUAGE plpgsql SECURITY DEFINER SET search_path = public AS $$
DECLARE base_slug text; final_slug text; counter integer := 0; BEGIN
  IF (TG_OP = 'INSERT' OR NEW.name != OLD.name) AND (NEW.slug IS NULL OR NEW.slug = '') THEN
    base_slug := public.generate_slug(NEW.name); final_slug := base_slug;
     WHILE EXISTS (SELECT 1 FROM public.categories WHERE slug = final_slug AND (TG_OP = 'INSERT' OR id != OLD.id)) LOOP -- Fix for UPDATE
      counter := counter + 1; final_slug := base_slug || '-' || counter::text;
    END LOOP; NEW.slug := final_slug;
  END IF; RETURN NEW;
END; $$;

-- TRIGGER: Call set_category_slug before category insert/update
DROP TRIGGER IF EXISTS trigger_set_category_slug ON public.categories;
CREATE TRIGGER trigger_set_category_slug BEFORE INSERT OR UPDATE OF name ON public.categories FOR EACH ROW EXECUTE PROCEDURE public.set_category_slug(); -- Optimize trigger condition

-- FUNCTION: Validate discount code before order insert (checks active, dates, uses, min value)
DROP FUNCTION IF EXISTS public.validate_discount_code();
CREATE OR REPLACE FUNCTION public.validate_discount_code()
RETURNS TRIGGER LANGUAGE plpgsql SECURITY DEFINER SET search_path = public AS $$
DECLARE d public.discounts%rowtype; BEGIN
  IF NEW.discount_id IS NOT NULL THEN
    SELECT * INTO d FROM public.discounts WHERE id = NEW.discount_id;
    IF d IS NULL THEN RAISE EXCEPTION 'Mã giảm giá không hợp lệ.'; END IF;
    IF d.is_active = false OR (d.start_date > now()) OR (d.end_date < now()) THEN RAISE EXCEPTION 'Mã "%" không hiệu lực.', d.code; END IF;
    IF d.remaining_uses <= 0 THEN RAISE EXCEPTION 'Mã "%" đã hết lượt.', d.code; END IF;
    IF d.min_order_value > NEW.subtotal_amount THEN RAISE EXCEPTION 'Đơn hàng chưa đủ giá trị tối thiểu % để dùng mã "%".', d.min_order_value, d.code; END IF;
    IF d.remaining_uses IS NOT NULL THEN UPDATE public.discounts SET remaining_uses = remaining_uses - 1 WHERE id = NEW.discount_id; END IF;
  END IF; RETURN NEW;
END; $$;

-- TRIGGER: Call validate_discount_code before order insert (after total calculation)
DROP TRIGGER IF EXISTS trigger_validate_discount_code ON public.orders;
CREATE TRIGGER trigger_validate_discount_code BEFORE INSERT ON public.orders FOR EACH ROW EXECUTE PROCEDURE public.validate_discount_code();

-- FUNCTION: Calculate order totals (discount, shipping, final total) before insert/update
DROP FUNCTION IF EXISTS public.calculate_order_total();
CREATE OR REPLACE FUNCTION public.calculate_order_total()
RETURNS TRIGGER LANGUAGE plpgsql SECURITY DEFINER SET search_path = public AS $$
DECLARE items_total numeric; disc_amt numeric := 0; ship_fee numeric; d public.discounts%rowtype; s public.shop_settings%rowtype; BEGIN
  items_total := NEW.subtotal_amount; -- Assume app provides correct subtotal
  SELECT * INTO s FROM public.shop_settings WHERE id = 1;
  ship_fee := coalesce(NEW.shipping_fee, s.default_shipping_fee, 0);
  IF NEW.discount_id IS NOT NULL THEN
    SELECT * INTO d FROM public.discounts WHERE id = NEW.discount_id;
    IF d IS NOT NULL THEN -- Discount exists
      IF d.discount_percentage IS NOT NULL THEN
        disc_amt := items_total * (d.discount_percentage / 100.0);
        IF d.max_discount_amount IS NOT NULL AND disc_amt > d.max_discount_amount THEN disc_amt := d.max_discount_amount; END IF;
      ELSIF d.max_discount_amount IS NOT NULL THEN -- Assume fixed amount if percentage is null and max_discount_amount is set
         disc_amt := d.max_discount_amount;
      END IF;
    END IF;
  END IF;
  NEW.discount_amount := disc_amt; NEW.shipping_fee := ship_fee; NEW.total_amount := items_total - disc_amt + ship_fee;
  IF NEW.total_amount < 0 THEN NEW.total_amount := 0; END IF;
  RETURN NEW;
END; $$;

-- TRIGGER: Call calculate_order_total before order insert/update (runs before discount validation)
DROP TRIGGER IF EXISTS trigger_calculate_order_total ON public.orders;
CREATE TRIGGER trigger_calculate_order_total BEFORE INSERT OR UPDATE ON public.orders FOR EACH ROW EXECUTE PROCEDURE public.calculate_order_total();

-- FUNCTION: Log admin/staff activity to admin_activity_log table
DROP FUNCTION IF EXISTS public.log_admin_activity();
CREATE OR REPLACE FUNCTION public.log_admin_activity()
RETURNS TRIGGER LANGUAGE plpgsql SECURITY DEFINER SET search_path = public AS $$
DECLARE act_type text; descrip text; ent_type text; ent_id text; dets jsonb; role text; old_j jsonb; new_j jsonb; BEGIN
  role := public.get_auth_role(); IF role NOT IN ('admin', 'staff') THEN RETURN NULL; END IF;
  ent_type := TG_TABLE_NAME;
  -- Capture details based on operation
  IF TG_OP = 'UPDATE' THEN old_j := to_jsonb(OLD); new_j := to_jsonb(NEW); dets := jsonb_build_object('old', old_j - 'updated_at', 'new', new_j - 'updated_at'); ent_id := OLD.id::text; -- Exclude updated_at from logs
  ELSIF TG_OP = 'DELETE' THEN old_j := to_jsonb(OLD); dets := jsonb_build_object('deleted', old_j); ent_id := OLD.id::text;
  ELSIF TG_OP = 'INSERT' THEN new_j := to_jsonb(NEW); dets := jsonb_build_object('created', new_j); ent_id := NEW.id::text; END IF;
  -- Determine activity type & description (simplified examples)
  IF ent_type = 'products' THEN act_type := 'PRODUCT_' || TG_OP; descrip := TG_OP || ' product: ' || coalesce(NEW.name, OLD.name);
  ELSIF ent_type = 'categories' THEN act_type := 'CATEGORY_' || TG_OP; descrip := TG_OP || ' category: ' || coalesce(NEW.name, OLD.name);
  ELSIF ent_type = 'brands' THEN act_type := 'BRAND_' || TG_OP; descrip := TG_OP || ' brand: ' || coalesce(NEW.name, OLD.name);
  ELSIF ent_type = 'discounts' THEN act_type := 'DISCOUNT_' || TG_OP; descrip := TG_OP || ' discount: ' || coalesce(NEW.code, OLD.code);
  ELSIF ent_type = 'orders' AND TG_OP = 'UPDATE' AND OLD.order_status_id IS DISTINCT FROM NEW.order_status_id THEN act_type := 'ORDER_STATUS_CHANGE'; descrip := 'Order #' || NEW.id || ' status changed.';
  ELSIF ent_type = 'reviews' THEN IF TG_OP = 'UPDATE' AND OLD.is_approved IS DISTINCT FROM NEW.is_approved THEN act_type := 'REVIEW_' || (CASE WHEN NEW.is_approved THEN 'APPROVE' ELSE 'UNAPPROVE' END); descrip := act_type || ' review #' || NEW.id; ELSIF TG_OP = 'DELETE' THEN act_type := 'REVIEW_DELETE'; descrip := 'Deleted review #' || OLD.id; END IF;
  ELSIF ent_type = 'review_replies' THEN act_type := 'REVIEW_REPLY_' || TG_OP; descrip := TG_OP || ' reply to review #' || coalesce(NEW.review_id, OLD.review_id);
  ELSIF ent_type = 'shop_settings' AND TG_OP = 'UPDATE' THEN act_type := 'SHOP_SETTINGS_UPDATE'; descrip := 'Updated shop settings';
  END IF;
  -- Insert log if activity type was determined
  IF act_type IS NOT NULL THEN INSERT INTO public.admin_activity_log (admin_user_id, activity_type, description, entity_type, entity_id, details) VALUES (auth.uid(), act_type, descrip, ent_type, ent_id, dets); END IF;
  RETURN NULL; -- Required for AFTER trigger
END; $$;

-- TRIGGERS: Call log_admin_activity after changes on key tables by admin/staff
DROP TRIGGER IF EXISTS trigger_log_admin_activity_products ON public.products; CREATE TRIGGER trigger_log_admin_activity_products AFTER INSERT OR UPDATE OR DELETE ON public.products FOR EACH ROW EXECUTE PROCEDURE public.log_admin_activity();
DROP TRIGGER IF EXISTS trigger_log_admin_activity_categories ON public.categories; CREATE TRIGGER trigger_log_admin_activity_categories AFTER INSERT OR UPDATE OR DELETE ON public.categories FOR EACH ROW EXECUTE PROCEDURE public.log_admin_activity();
DROP TRIGGER IF EXISTS trigger_log_admin_activity_brands ON public.brands; CREATE TRIGGER trigger_log_admin_activity_brands AFTER INSERT OR UPDATE OR DELETE ON public.brands FOR EACH ROW EXECUTE PROCEDURE public.log_admin_activity();
DROP TRIGGER IF EXISTS trigger_log_admin_activity_discounts ON public.discounts; CREATE TRIGGER trigger_log_admin_activity_discounts AFTER INSERT OR UPDATE OR DELETE ON public.discounts FOR EACH ROW EXECUTE PROCEDURE public.log_admin_activity();
DROP TRIGGER IF EXISTS trigger_log_admin_activity_orders ON public.orders; CREATE TRIGGER trigger_log_admin_activity_orders AFTER UPDATE ON public.orders FOR EACH ROW EXECUTE PROCEDURE public.log_admin_activity(); -- Log status changes etc.
DROP TRIGGER IF EXISTS trigger_log_admin_activity_reviews ON public.reviews; CREATE TRIGGER trigger_log_admin_activity_reviews AFTER UPDATE OR DELETE ON public.reviews FOR EACH ROW EXECUTE PROCEDURE public.log_admin_activity(); -- Log approve/delete
DROP TRIGGER IF EXISTS trigger_log_admin_activity_review_replies ON public.review_replies; CREATE TRIGGER trigger_log_admin_activity_review_replies AFTER INSERT OR UPDATE OR DELETE ON public.review_replies FOR EACH ROW EXECUTE PROCEDURE public.log_admin_activity();
DROP TRIGGER IF EXISTS trigger_log_admin_activity_shop_settings ON public.shop_settings; CREATE TRIGGER trigger_log_admin_activity_shop_settings AFTER UPDATE ON public.shop_settings FOR EACH ROW EXECUTE PROCEDURE public.log_admin_activity();

-- FUNCTION (RPC): Approve a review (staff/admin only)
DROP FUNCTION IF EXISTS public.approve_review(bigint);
CREATE OR REPLACE FUNCTION public.approve_review(p_review_id bigint)
RETURNS void LANGUAGE plpgsql SECURITY DEFINER SET search_path = public AS $$
BEGIN IF NOT public.is_staff() THEN RAISE EXCEPTION 'AUTH_REQUIRED: Staff/Admin only.'; END IF; UPDATE public.reviews SET is_approved = true, approved_by = auth.uid(), approved_at = now() WHERE id = p_review_id; END; $$;
comment on function public.approve_review(bigint) is 'RPC for staff/admin to approve a review.';

-- FUNCTION (RPC): Reply to a review (staff/admin only)
DROP FUNCTION IF EXISTS public.reply_to_review(bigint, text);
CREATE OR REPLACE FUNCTION public.reply_to_review(p_review_id bigint, p_reply_text text)
RETURNS bigint LANGUAGE plpgsql SECURITY DEFINER SET search_path = public AS $$
DECLARE new_reply_id bigint; BEGIN IF NOT public.is_staff() THEN RAISE EXCEPTION 'AUTH_REQUIRED: Staff/Admin only.'; END IF; INSERT INTO public.review_replies (review_id, staff_id, reply_text) VALUES (p_review_id, auth.uid(), p_reply_text) RETURNING id INTO new_reply_id; RETURN new_reply_id; END; $$;
comment on function public.reply_to_review(bigint, text) is 'RPC for staff/admin to reply to a review. Returns new reply ID.';

-- FUNCTION (RPC): Get best selling products (for homepage etc.)
DROP FUNCTION IF EXISTS public.get_best_selling_products(integer);
CREATE OR REPLACE FUNCTION public.get_best_selling_products(p_limit integer)
RETURNS TABLE (product_id bigint, product_name text, product_slug text, brand_name text, image_url text, total_sold bigint)
LANGUAGE plpgsql STABLE SECURITY DEFINER SET search_path = public AS $$
DECLARE completed_status_ids smallint[]; BEGIN SELECT array_agg(id) INTO completed_status_ids FROM public.order_statuses WHERE name IN ('Shipped', 'Delivered'); RETURN QUERY SELECT p.id, p.name, p.slug, b.name, (SELECT pi.image_url FROM public.product_images pi WHERE pi.product_id = p.id AND pi.is_main = true ORDER BY pi.display_order, pi.id LIMIT 1), SUM(oi.quantity)::bigint FROM public.products p JOIN public.product_variants pv ON p.id = pv.product_id JOIN public.order_items oi ON pv.id = oi.variant_id JOIN public.orders o ON oi.order_id = o.id LEFT JOIN public.brands b ON p.brand_id = b.id WHERE p.deleted_at IS NULL AND pv.deleted_at IS NULL AND o.order_status_id = ANY(completed_status_ids) GROUP BY p.id, b.name ORDER BY total_sold DESC LIMIT p_limit; END; $$;
comment on function public.get_best_selling_products(integer) is 'RPC: Gets best-selling products (based on completed orders). Needs SECURITY DEFINER.';

-- FUNCTION (RPC): Get monthly revenue report (for admin)
DROP FUNCTION IF EXISTS public.get_monthly_revenue(date, date);
CREATE OR REPLACE FUNCTION public.get_monthly_revenue(p_start_date date, p_end_date date)
RETURNS TABLE (report_month text, total_revenue numeric, order_count bigint)
LANGUAGE plpgsql STABLE SECURITY DEFINER SET search_path = public AS $$
DECLARE completed_status_ids smallint[]; BEGIN SELECT array_agg(id) INTO completed_status_ids FROM public.order_statuses WHERE name IN ('Shipped', 'Delivered'); RETURN QUERY SELECT to_char(date_trunc('month', o.order_date), 'YYYY-MM'), SUM(o.total_amount), COUNT(o.id) FROM public.orders o WHERE o.order_status_id = ANY(completed_status_ids) AND o.order_date >= date_trunc('month', p_start_date) AND o.order_date < date_trunc('month', p_end_date) + interval '1 month' GROUP BY date_trunc('month', o.order_date) ORDER BY 1; END; $$;
comment on function public.get_monthly_revenue(date, date) is 'RPC: Calculates monthly revenue from completed orders. Needs SECURITY DEFINER.';

-- FUNCTION (RPC): Get top selling products report (for admin)
DROP FUNCTION IF EXISTS public.get_top_selling_products_report(integer, date, date);
CREATE OR REPLACE FUNCTION public.get_top_selling_products_report(p_limit integer, p_start_date date, p_end_date date)
RETURNS TABLE (product_id bigint, product_name text, product_code text, brand_name text, total_quantity_sold bigint, total_revenue_generated numeric)
LANGUAGE plpgsql STABLE SECURITY DEFINER SET search_path = public AS $$
DECLARE completed_status_ids smallint[]; BEGIN SELECT array_agg(id) INTO completed_status_ids FROM public.order_statuses WHERE name IN ('Shipped', 'Delivered'); RETURN QUERY SELECT p.id, p.name, p.product_code, b.name, SUM(oi.quantity)::bigint, SUM(oi.quantity * oi.unit_price_at_order) FROM public.products p JOIN public.product_variants pv ON p.id = pv.product_id JOIN public.order_items oi ON pv.id = oi.variant_id JOIN public.orders o ON oi.order_id = o.id LEFT JOIN public.brands b ON p.brand_id = b.id WHERE p.deleted_at IS NULL AND pv.deleted_at IS NULL AND o.order_status_id = ANY(completed_status_ids) AND o.order_date >= p_start_date AND o.order_date < p_end_date + interval '1 day' GROUP BY p.id, b.name ORDER BY total_quantity_sold DESC LIMIT p_limit; END; $$;
comment on function public.get_top_selling_products_report(integer, date, date) is 'RPC: Gets top-selling products report (qty & revenue). Needs SECURITY DEFINER.';

-- FUNCTION (RPC): Get filter options for Product Listing Page (PLP)
DROP FUNCTION IF EXISTS public.get_plp_filter_options();
CREATE OR REPLACE FUNCTION public.get_plp_filter_options()
RETURNS json LANGUAGE plpgsql STABLE SET search_path = public AS $$
DECLARE result json; BEGIN SELECT json_build_object('brands', (SELECT json_agg(json_build_object('id', id, 'name', name) ORDER BY name) FROM public.brands),'categories', (SELECT json_agg(json_build_object('id', id, 'name', name, 'slug', slug, 'parent_category_id', parent_category_id, 'image_url', image_url) ORDER BY display_order) FROM public.categories),'genders', (SELECT json_agg(json_build_object('id', id, 'name', name) ORDER BY id) FROM public.genders),'perfumeTypes', (SELECT json_agg(json_build_object('id', id, 'name', name) ORDER BY id) FROM public.perfume_types),'concentrations', (SELECT json_agg(json_build_object('id', id, 'name', name) ORDER BY id) FROM public.concentrations),'priceRanges', (SELECT json_agg(json_build_object('min', range->>'min', 'max', range->>'max', 'label', range->>'label')) FROM json_array_elements('[{"min": 0, "max": 1000000, "label": "Dưới 1 triệu"},{"min": 1000000, "max": 2000000, "label": "1 - 2 triệu"},{"min": 2000000, "max": 5000000, "label": "2 - 5 triệu"},{"min": 5000000, "max": 10000000, "label": "5 - 10 triệu"},{"min": 10000000, "max": 9007199254740991, "label": "Trên 10 triệu"}]') AS range)) INTO result; RETURN result; END; $$;
comment on function public.get_plp_filter_options() is 'RPC: Retrieves filter options (brands, categories, etc.) for PLP.';

-- FUNCTION (RPC): Get order details securely using guest access token
DROP FUNCTION IF EXISTS public.get_order_details_by_token(uuid);
CREATE OR REPLACE FUNCTION public.get_order_details_by_token(p_token uuid)
RETURNS json LANGUAGE plpgsql STABLE SECURITY DEFINER SET search_path = public AS $$
DECLARE order_details json; BEGIN
  SELECT json_build_object(
      'order', row_to_json(o_filtered.*), -- Select only safe fields
      'items', (SELECT json_agg(oi.*) FROM public.order_items oi WHERE oi.order_id = o_filtered.id),
      'status_name', (SELECT os.name FROM public.order_statuses os WHERE os.id = o_filtered.order_status_id),
      'payment_method_name', (SELECT pm.name FROM public.payment_methods pm WHERE pm.id = o_filtered.payment_method_id)
    ) INTO order_details
  FROM ( SELECT o.id, o.access_token, o.guest_name, o.guest_email, o.guest_phone, o.recipient_name, o.recipient_phone,
                o.province_city, o.district, o.ward, o.street_address, o.order_date, o.delivery_notes, o.payment_method_id,
                o.payment_status, o.order_status_id, o.tracking_number, o.subtotal_amount, o.discount_amount,
                o.shipping_fee, o.total_amount -- Select specific safe fields, exclude user_id
         FROM public.orders o WHERE o.access_token = p_token
  ) as o_filtered;
  IF order_details IS NULL THEN RAISE EXCEPTION 'ORDER_NOT_FOUND'; END IF;
  RETURN order_details;
END; $$;
comment on function public.get_order_details_by_token(uuid) is 'RPC: Securely gets order details using guest token. Needs SECURITY DEFINER.';

-- ============================================================================
-- SECTION: RLS POLICIES (Access Control Rules)
-- ============================================================================

-- RLS: Users manage their own addresses
create policy "Users manage own addresses" on public.addresses for all using (auth.uid() = user_id) with check (auth.uid() = user_id);

-- RLS: Users manage their own profile
create policy "Users manage own profile" on public.profiles for all using (auth.uid() = id) with check (auth.uid() = id); -- Using 'all' and check is simpler

-- RLS: Users manage their own shopping cart & items
create policy "Users manage own shopping carts" on public.shopping_carts for all using (auth.uid() = user_id) with check (auth.uid() = user_id);
create policy "Users manage own cart items" on public.cart_items for all using (exists (select 1 from public.shopping_carts where id = cart_id and user_id = auth.uid())) with check (exists (select 1 from public.shopping_carts where id = cart_id and user_id = auth.uid()));

-- RLS: Orders/Items/Payments - Logged-in users only (Guests use RPC get_order_details_by_token)
-- NOTE: Order INSERT should ideally happen via backend using service_role key
create policy "Users can view their own orders" on public.orders for select using (auth.uid() = user_id);
-- create policy "Users can insert own orders" on public.orders for insert with check (auth.uid() = user_id); -- Disabled: Use service_role for inserts
create policy "Users can view items for own orders" on public.order_items for select using (exists (select 1 from public.orders where id = order_items.order_id and user_id = auth.uid()));
-- create policy "Users can insert items for own orders" on public.order_items for insert with check (exists (select 1 from public.orders where id = order_items.order_id and user_id = auth.uid())); -- Disabled: Use service_role for inserts
create policy "Users can view payments for own orders" on public.payments for select using (exists (select 1 from public.orders where id = order_id and user_id = auth.uid()));

-- RLS: Reviews - Users manage own reviews, insert only if purchased
create policy "Users can view own reviews" on public.reviews for select using (auth.uid() = user_id);
create policy "Users can insert reviews if purchased" on public.reviews for insert with check (auth.uid() = user_id and public.has_user_purchased_product(product_id));
create policy "Users can update own unapproved reviews" on public.reviews for update using (auth.uid() = user_id and is_approved = false) with check (auth.uid() = user_id);
create policy "Users can delete own reviews" on public.reviews for delete using (auth.uid() = user_id);

-- RLS: Wishlists - Users manage their own
create policy "Users manage own wishlists" on public.wishlists for all using (auth.uid() = user_id) with check (auth.uid() = user_id);

-- RLS: Public Access (Read-only for most lookup/product data)
create policy "Public read access for brands" on public.brands for select using (true);
create policy "Public read access for genders" on public.genders for select using (true);
create policy "Public read access for perfume types" on public.perfume_types for select using (true);
create policy "Public read access for concentrations" on public.concentrations for select using (true);
create policy "Public read access for categories" on public.categories for select using (true);
create policy "Public read access for active products" on public.products for select using (deleted_at is null);
create policy "Public read access for scents" on public.scents for select using (true);
create policy "Public read access for ingredients" on public.ingredients for select using (true);
create policy "Public read access for active product variants" on public.product_variants for select using (deleted_at is null);
create policy "Public read access for product scents" on public.product_scents for select using (true);
create policy "Public read access for product ingredients" on public.product_ingredients for select using (true);
create policy "Public read access for product images" on public.product_images for select using (true);
create policy "Public read access for product categories links" on public.product_categories for select using (true);
create policy "Public read access for product labels" on public.product_labels for select using (true);
create policy "Public read access for product label assignments" on public.product_label_assignments for select using (true);
create policy "Public read access for active discounts" on public.discounts for select using (is_active = true and (start_date is null or start_date <= now()) and (end_date is null or end_date >= now()));
create policy "Public read access for order statuses" on public.order_statuses for select using (true);
create policy "Public read access for active payment methods" on public.payment_methods for select using (is_active = true);
create policy "Public read access for approved reviews" on public.reviews for select using (is_approved = true);
create policy "Public read access for review replies" on public.review_replies for select using (true);
create policy "Public read access for active banners" on public.banners for select using (is_active = true and (start_date is null or start_date <= now()) and (end_date is null or end_date >= now()));
create policy "Public read access for shop settings" on public.shop_settings for select using (true);

-- RLS: Staff & Admin Access (Broader permissions)
create policy "Admins can manage all addresses" on public.addresses for all using (public.is_admin()) with check (public.is_admin());
create policy "Admins can manage all profiles" on public.profiles for all using (public.is_admin()) with check (public.is_admin());
create policy "Admins can manage brands" on public.brands for all using (public.is_admin()) with check (public.is_admin());
create policy "Admins can manage genders" on public.genders for all using (public.is_admin()) with check (public.is_admin());
create policy "Admins can manage perfume types" on public.perfume_types for all using (public.is_admin()) with check (public.is_admin());
create policy "Admins can manage concentrations" on public.concentrations for all using (public.is_admin()) with check (public.is_admin());
create policy "Admins can manage categories" on public.categories for all using (public.is_admin()) with check (public.is_admin());
create policy "Admins can manage products" on public.products for all using (public.is_admin()) with check (public.is_admin());
create policy "Admins can manage scents" on public.scents for all using (public.is_admin()) with check (public.is_admin());
create policy "Admins can manage ingredients" on public.ingredients for all using (public.is_admin()) with check (public.is_admin());
create policy "Admins can manage product variants" on public.product_variants for all using (public.is_admin()) with check (public.is_admin());
create policy "Admins can manage product scents" on public.product_scents for all using (public.is_admin()) with check (public.is_admin());
create policy "Admins can manage product ingredients" on public.product_ingredients for all using (public.is_admin()) with check (public.is_admin());
create policy "Admins can manage product images" on public.product_images for all using (public.is_admin()) with check (public.is_admin());
create policy "Admins can manage product categories links" on public.product_categories for all using (public.is_admin()) with check (public.is_admin());
create policy "Admins can manage product labels" on public.product_labels for all using (public.is_admin()) with check (public.is_admin());
create policy "Admins can manage product label assignments" on public.product_label_assignments for all using (public.is_admin()) with check (public.is_admin());
create policy "Admins can manage discounts" on public.discounts for all using (public.is_admin()) with check (public.is_admin());
create policy "Admins can manage all shopping carts" on public.shopping_carts for all using (public.is_admin()) with check (public.is_admin());
create policy "Admins can manage all cart items" on public.cart_items for all using (public.is_admin()) with check (public.is_admin());
create policy "Admins can manage order statuses" on public.order_statuses for all using (public.is_admin()) with check (public.is_admin());
create policy "Admins can manage payment methods" on public.payment_methods for all using (public.is_admin()) with check (public.is_admin());
create policy "Staff can view all orders" on public.orders for select using (public.is_staff()); -- Staff can view
create policy "Staff can update orders" on public.orders for update using (public.is_staff()) with check (public.is_staff()); -- Staff can update (status etc.)
create policy "Staff can view all order items" on public.order_items for select using (public.is_staff());
create policy "Staff can view all payments" on public.payments for select using (public.is_staff());
create policy "Staff can manage payments" on public.payments for all using (public.is_staff()) with check (public.is_staff()); -- Staff can update payment status
create policy "Admins can manage inventory" on public.inventory for all using (public.is_admin()) with check (public.is_admin()); -- Admin only for inventory log
create policy "Staff can view all reviews" on public.reviews for select using (public.is_staff());
create policy "Staff can manage reviews (approve/update)" on public.reviews for update using (public.is_staff()) with check (public.is_staff());
create policy "Staff can delete reviews" on public.reviews for delete using (public.is_staff());
create policy "Staff can manage review replies" on public.review_replies for all using (public.is_staff()) with check (public.is_staff());
create policy "Admins can manage all wishlists" on public.wishlists for all using (public.is_admin()) with check (public.is_admin());
create policy "Admins can view admin activity logs" on public.admin_activity_log for select using (public.is_admin());
create policy "Admins/System can insert admin activity logs" on public.admin_activity_log for insert with check (public.is_admin() or auth.role() = 'service_role');
create policy "Admins can manage banners" on public.banners for all using (public.is_admin()) with check (public.is_admin());
create policy "Admins can manage shop settings" on public.shop_settings for all using (public.is_admin()) with check (public.is_admin());

-- ============================================================================
-- SECTION: STORAGE BUCKETS & POLICIES (File Storage Setup)
-- ============================================================================

-- Buckets: Define storage locations, sizes, allowed types
INSERT INTO storage.buckets (id, name, public, file_size_limit, allowed_mime_types) VALUES ('avatars', 'avatars', true, 5242880, ARRAY['image/jpeg', 'image/png', 'image/gif', 'image/webp']) ON CONFLICT (id) DO NOTHING; -- User profile pics (5MB)
INSERT INTO storage.buckets (id, name, public, file_size_limit, allowed_mime_types) VALUES ('logos', 'logos', true, 2097152, ARRAY['image/jpeg', 'image/png', 'image/gif', 'image/webp', 'image/svg+xml']) ON CONFLICT (id) DO NOTHING; -- Brand/Shop logos (2MB, allows SVG)
INSERT INTO storage.buckets (id, name, public, file_size_limit, allowed_mime_types) VALUES ('products', 'products', true, 5242880, ARRAY['image/jpeg', 'image/png', 'image/gif', 'image/webp']) ON CONFLICT (id) DO NOTHING; -- Product images (5MB)
INSERT INTO storage.buckets (id, name, public, file_size_limit, allowed_mime_types) VALUES ('banners', 'banners', true, 5242880, ARRAY['image/jpeg', 'image/png', 'image/gif', 'image/webp']) ON CONFLICT (id) DO NOTHING; -- Banner images (5MB)
INSERT INTO storage.buckets (id, name, public, file_size_limit, allowed_mime_types) VALUES ('categories', 'categories', true, 5242880, ARRAY['image/jpeg', 'image/png', 'image/gif', 'image/webp']) ON CONFLICT (id) DO NOTHING; -- Category images (5MB)

-- Storage Policies: Control who can access/upload files
DROP POLICY IF EXISTS "Public read access" ON storage.objects; CREATE POLICY "Public read access" ON storage.objects FOR SELECT USING (true); -- Anyone can read files in public buckets
DROP POLICY IF EXISTS "Authenticated user can insert avatar" ON storage.objects; CREATE POLICY "Authenticated user can insert avatar" ON storage.objects FOR INSERT TO authenticated WITH CHECK (bucket_id = 'avatars'); -- Logged-in users can upload avatars
DROP POLICY IF EXISTS "Owner can update own avatar" ON storage.objects; CREATE POLICY "Owner can update own avatar" ON storage.objects FOR UPDATE TO authenticated USING ( bucket_id = 'avatars' AND auth.uid() = owner ) WITH CHECK ( bucket_id = 'avatars' AND auth.uid() = owner ); -- Users can update their own avatar
DROP POLICY IF EXISTS "Owner can delete own avatar" ON storage.objects; CREATE POLICY "Owner can delete own avatar" ON storage.objects FOR DELETE TO authenticated USING ( bucket_id = 'avatars' AND auth.uid() = owner ); -- Users can delete their own avatar
DROP POLICY IF EXISTS "Admin/Staff can manage business assets" ON storage.objects; CREATE POLICY "Admin/Staff can manage business assets" ON storage.objects FOR ALL USING (bucket_id IN ('logos', 'products', 'banners', 'categories') AND public.is_staff()) WITH CHECK (bucket_id IN ('logos', 'products', 'banners', 'categories') AND public.is_staff()); -- Staff/Admin can manage other images

-- ============================================================================
-- SECTION: INDEXES (Database Performance Optimization)
-- ============================================================================

-- Indexes on frequently queried columns
CREATE INDEX IF NOT EXISTS idx_products_brand_id ON public.products (brand_id);
CREATE INDEX IF NOT EXISTS idx_products_gender_id ON public.products (gender_id);
CREATE INDEX IF NOT EXISTS idx_products_perfume_type_id ON public.products (perfume_type_id);
CREATE INDEX IF NOT EXISTS idx_products_concentration_id ON public.products (concentration_id);
CREATE INDEX IF NOT EXISTS idx_products_slug ON public.products (slug);
CREATE INDEX IF NOT EXISTS idx_products_deleted_at ON public.products (deleted_at); -- For soft delete queries

CREATE INDEX IF NOT EXISTS idx_product_variants_product_id ON public.product_variants (product_id);
CREATE INDEX IF NOT EXISTS idx_product_variants_sku ON public.product_variants (sku);
CREATE INDEX IF NOT EXISTS idx_product_variants_deleted_at ON public.product_variants (deleted_at);

CREATE INDEX IF NOT EXISTS idx_product_scents_product_id ON public.product_scents (product_id);
CREATE INDEX IF NOT EXISTS idx_product_ingredients_product_id ON public.product_ingredients (product_id);
CREATE INDEX IF NOT EXISTS idx_product_categories_product_id ON public.product_categories (product_id);
CREATE INDEX IF NOT EXISTS idx_product_categories_category_id ON public.product_categories (category_id);

CREATE INDEX IF NOT EXISTS idx_product_images_product_id ON public.product_images (product_id);
CREATE INDEX IF NOT EXISTS idx_product_images_is_main ON public.product_images (is_main);

CREATE INDEX IF NOT EXISTS idx_cart_items_cart_id ON public.cart_items (cart_id);
CREATE INDEX IF NOT EXISTS idx_cart_items_variant_id ON public.cart_items (variant_id);

CREATE INDEX IF NOT EXISTS idx_order_items_order_id ON public.order_items (order_id);
CREATE INDEX IF NOT EXISTS idx_order_items_variant_id ON public.order_items (variant_id);

CREATE INDEX IF NOT EXISTS idx_orders_user_id ON public.orders (user_id);
CREATE INDEX IF NOT EXISTS idx_orders_order_status_id ON public.orders (order_status_id);
CREATE INDEX IF NOT EXISTS idx_orders_order_date ON public.orders (order_date DESC);
CREATE INDEX IF NOT EXISTS idx_orders_access_token ON public.orders (access_token); -- Crucial for guest order lookup

CREATE INDEX IF NOT EXISTS idx_payments_order_id ON public.payments (order_id);

CREATE INDEX IF NOT EXISTS idx_inventory_variant_id ON public.inventory (variant_id);
CREATE INDEX IF NOT EXISTS idx_inventory_timestamp ON public.inventory (timestamp DESC);

CREATE INDEX IF NOT EXISTS idx_reviews_product_id ON public.reviews (product_id);
CREATE INDEX IF NOT EXISTS idx_reviews_user_id ON public.reviews (user_id);
CREATE INDEX IF NOT EXISTS idx_reviews_is_approved ON public.reviews (is_approved);

CREATE INDEX IF NOT EXISTS idx_review_replies_review_id ON public.review_replies (review_id);

CREATE INDEX IF NOT EXISTS idx_wishlists_user_id ON public.wishlists (user_id);
CREATE INDEX IF NOT EXISTS idx_wishlists_product_id ON public.wishlists (product_id);

CREATE INDEX IF NOT EXISTS idx_admin_activity_log_admin_user_id ON public.admin_activity_log (admin_user_id);
CREATE INDEX IF NOT EXISTS idx_admin_activity_log_timestamp ON public.admin_activity_log (timestamp DESC);

CREATE INDEX IF NOT EXISTS idx_profiles_default_address_id ON public.profiles (default_address_id);

CREATE INDEX IF NOT EXISTS idx_product_label_assignments_product_id ON public.product_label_assignments (product_id);
CREATE INDEX IF NOT EXISTS idx_product_label_assignments_label_id ON public.product_label_assignments (label_id);

-- ============================================================================
-- FINAL COMMENT: Setup Complete.
-- Includes guest token access. Remember Auth config & frontend updates for guest view.
-- ============================================================================


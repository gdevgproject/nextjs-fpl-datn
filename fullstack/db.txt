-- Designed for a single execution on Supabase SQL Editor.

-- Enable necessary extensions
create extension if not exists "uuid-ossp";

-- ============================================================================
-- TABLES
-- ============================================================================

-- Bảng addresses (Improved for Vietnamese market)
create table public.addresses (
    id bigint generated by default as identity primary key,
    user_id uuid references auth.users on delete cascade,
    recipient_name text not null,
    recipient_phone text not null,
    province_city text not null,
    district text not null,
    ward text not null,
    street_address text not null,
    postal_code text, -- Made optional as per Vietnamese context
    is_default boolean default false,
    created_at timestamptz default now(),
    updated_at timestamptz default now()
);
comment on table public.addresses is 'Stores user shipping and billing addresses';

-- Bảng profiles (Improved with simplified user info)
create table public.profiles (
    id uuid not null primary key references auth.users on delete cascade,
    display_name text,
    phone_number text,
    gender text, -- Added gender field
    birth_date date, -- Added birth date field
    avatar_url text, -- Added avatar URL field
    default_address_id bigint references public.addresses on delete set null,
    created_at timestamptz default now(),
    updated_at timestamptz default now()
);
comment on table public.profiles is 'Stores extended user profile information';

-- Bảng brands (Added logo_url)
create table public.brands (
    id bigint generated by default as identity primary key,
    name text unique not null,
    description text,
    logo_url text, -- Added logo URL field
    created_at timestamptz default now(),
    updated_at timestamptz default now()
);

-- Bảng genders
create table public.genders (
    id smallint generated by default as identity primary key,
    name text unique not null,
    created_at timestamptz default now(),
    updated_at timestamptz default now()
);

-- Bảng perfume_types (New table for Niche, Designer, etc.)
create table public.perfume_types (
    id smallint generated by default as identity primary key,
    name text unique not null,
    created_at timestamptz default now(),
    updated_at timestamptz default now()
);
comment on table public.perfume_types is 'Stores perfume types (Designer, Niche, etc.)';

-- Bảng concentrations (New table for EDP, EDT, etc.)
create table public.concentrations (
    id smallint generated by default as identity primary key,
    name text unique not null,
    description text,
    created_at timestamptz default now(),
    updated_at timestamptz default now()
);
comment on table public.concentrations is 'Stores perfume concentration types (EDP, EDT, etc.)';

-- Bảng categories (Simplified for perfume shop)
create table public.categories (
    id bigint generated by default as identity primary key,
    name text not null unique,
    slug text unique,
    description text,
    is_featured boolean default false, -- For featuring on homepage
    display_order int default 0, -- For controlling display order
    parent_category_id bigint references public.categories on delete set null,
    created_at timestamptz default now(),
    updated_at timestamptz default now()
);

-- Bảng products (Enhanced with perfume-specific fields)
create table public.products (
    id bigint generated by default as identity primary key,
    name text not null,
    slug text unique,
    product_code text, -- Added product code field
    short_description text, -- Added short description
    long_description text, -- Added long description
    brand_id bigint references public.brands on delete set null,
    gender_id smallint references public.genders on delete set null,
    perfume_type_id smallint references public.perfume_types on delete set null, -- Added perfume type
    concentration_id smallint references public.concentrations on delete set null, -- Added concentration
    origin_country text, -- Added country of origin
    release_year smallint, -- Added release year
    style text, -- Added style (sexy, sweet, etc.)
    sillage text, -- Added sillage (projection)
    longevity text, -- Added longevity
    created_at timestamptz default now(),
    updated_at timestamptz default now(),
    deleted_at timestamptz
);
comment on table public.products is 'Stores perfume product information';

-- Bảng scents
create table public.scents (
    id bigint generated by default as identity primary key,
    name text unique not null,
    description text,
    created_at timestamptz default now(),
    updated_at timestamptz default now()
);

-- Bảng ingredients
create table public.ingredients (
    id bigint generated by default as identity primary key,
    name text unique not null,
    created_at timestamptz default now(),
    updated_at timestamptz default now()
);

-- Bảng product_variants (Updated for perfume volumes)
create table public.product_variants (
    id bigint generated by default as identity primary key,
    product_id bigint not null references public.products on delete cascade,
    volume_ml integer not null, -- Made required
    price numeric not null,
    sale_price numeric, -- Added sale price
    sku text unique,
    stock_quantity integer not null default 0,
    created_at timestamptz default now(),
    updated_at timestamptz default now(),
    deleted_at timestamptz
);
comment on table public.product_variants is 'Stores different sizes/variants of perfume products';

-- Bảng product_scents (Quan hệ nhiều-nhiều)
create table public.product_scents (
    id bigint generated by default as identity primary key,
    product_id bigint not null references public.products on delete cascade,
    scent_id bigint not null references public.scents on delete cascade,
    scent_type text not null check (scent_type in ('top', 'middle', 'base')), -- Added scent type
    unique (product_id, scent_id, scent_type)
);

-- Bảng product_ingredients (Quan hệ nhiều-nhiều)
create table public.product_ingredients (
    id bigint generated by default as identity primary key,
    product_id bigint not null references public.products on delete cascade,
    ingredient_id bigint not null references public.ingredients on delete cascade,
    unique (product_id, ingredient_id)
);

-- Bảng product_images
create table public.product_images (
    id bigint generated by default as identity primary key,
    product_id bigint not null references public.products on delete cascade,
    image_url text not null,
    alt_text text,
    is_main boolean default false,
    display_order int default 0, -- Added display order
    created_at timestamptz default now(),
    updated_at timestamptz default now()
);

-- Bảng product_categories (Quan hệ nhiều-nhiều)
create table public.product_categories (
    id bigint generated by default as identity primary key,
    product_id bigint not null references public.products on delete cascade,
    category_id bigint not null references public.categories on delete cascade,
    unique (product_id, category_id)
);

-- Bảng product_labels
create table public.product_labels (
    id bigint generated by default as identity primary key,
    name text unique not null,
    color_code varchar(7),
    created_at timestamptz default now(),
    updated_at timestamptz default now()
);

-- Bảng product_label_assignments (Quan hệ nhiều-nhiều)
create table public.product_label_assignments (
    id bigint generated by default as identity primary key,
    product_id bigint not null references public.products on delete cascade,
    label_id bigint not null references public.product_labels on delete cascade,
    valid_until timestamptz, -- Added expiration date for labels
    unique (product_id, label_id)
);

-- Bảng discounts
create table public.discounts (
    id bigint generated by default as identity primary key,
    code text unique not null,
    description text,
    start_date timestamptz,
    end_date timestamptz,
    max_uses integer,
    remaining_uses integer,
    min_order_value numeric,
    max_discount_amount numeric,
    discount_percentage numeric,
    is_active boolean default true,
    created_at timestamptz default now(),
    updated_at timestamptz default now()
);

-- Bảng shopping_carts
create table public.shopping_carts (
    id bigint generated by default as identity primary key,
    user_id uuid references auth.users on delete cascade unique, -- Added UNIQUE constraint
    created_at timestamptz default now(),
    updated_at timestamptz default now()
);

-- Bảng cart_items
create table public.cart_items (
    id bigint generated by default as identity primary key,
    cart_id bigint not null references public.shopping_carts on delete cascade,
    variant_id bigint not null references public.product_variants on delete cascade,
    quantity integer not null check (quantity > 0), -- Ensure quantity is positive
    created_at timestamptz default now(),
    updated_at timestamptz default now(),
    unique(cart_id, variant_id) -- Prevent duplicate variant in the same cart
);

-- Bảng order_statuses
create table public.order_statuses (
    id smallint generated by default as identity primary key,
    name text unique not null
);

-- Bảng payment_methods
create table public.payment_methods (
    id smallint generated by default as identity primary key,
    name text unique not null,
    description text,
    is_active boolean default true
);
comment on table public.payment_methods is 'Stores available payment methods';

-- Bảng orders (Updated for Vietnamese market)
create table public.orders (
    id bigint generated by default as identity primary key,
    user_id uuid references auth.users on delete set null,
    -- Guest information
    guest_name text,
    guest_email text,
    guest_phone text,
    -- Address information (for both registered and guest users)
    recipient_name text not null,
    recipient_phone text not null,
    province_city text not null,
    district text not null,
    ward text not null,
    street_address text not null,
    -- Order details
    order_date timestamptz default now(),
    delivery_notes text,
    payment_method_id smallint references public.payment_methods(id),
    payment_status text check (payment_status in ('Pending', 'Paid', 'Failed', 'Refunded')) default 'Pending',
    order_status_id smallint references public.order_statuses(id),
    tracking_number text,
    discount_id bigint references public.discounts on delete set null,
    subtotal_amount numeric not null default 0,
    discount_amount numeric default 0,
    shipping_fee numeric default 0, -- Added shipping fee
    total_amount numeric not null default 0,
    created_at timestamptz default now(),
    updated_at timestamptz default now()
);
comment on table public.orders is 'Stores customer order information';

-- Bảng order_items
create table public.order_items (
    id bigint generated by default as identity primary key,
    order_id bigint not null references public.orders on delete cascade,
    variant_id bigint not null references public.product_variants on delete restrict, -- Restrict deletion if variant is in an order
    product_name text not null, -- Store product name at time of order
    variant_volume_ml integer not null, -- Store volume at time of order
    quantity integer not null check (quantity > 0),
    unit_price_at_order numeric not null,
    created_at timestamptz default now(),
    updated_at timestamptz default now()
);

-- Bảng payments
create table public.payments (
    id bigint generated by default as identity primary key,
    order_id bigint not null references public.orders on delete cascade,
    payment_date timestamptz default now(),
    payment_method_id smallint references public.payment_methods(id),
    transaction_id text,
    amount numeric not null,
    status text check (status in ('Pending', 'Completed', 'Failed', 'Refunded')) default 'Pending',
    payment_details jsonb, -- Store payment-specific details
    created_at timestamptz default now(),
    updated_at timestamptz default now()
);

-- Bảng inventory (Consider purpose: logging vs. source of truth)
create table public.inventory (
    id bigint generated by default as identity primary key,
    variant_id bigint not null references public.product_variants on delete cascade,
    change_amount integer not null, -- Positive for stock in, negative for stock out
    reason text, -- e.g., 'Order Shipped', 'Stock Adjustment', 'Initial Stock'
    order_id bigint references public.orders on delete set null, -- Link to order if applicable
    stock_after_change integer, -- Optional: snapshot of stock after change
    updated_by uuid references auth.users on delete set null, -- User who made the change (if manual)
    timestamp timestamptz default now(),
    created_at timestamptz default now(),
    updated_at timestamptz default now()
);
comment on table public.inventory is 'Logs changes in product variant inventory levels. product_variants.stock_quantity is the source of truth.';


-- Bảng reviews (Updated with approval system)
create table public.reviews (
    id bigint generated by default as identity primary key,
    product_id bigint not null references public.products on delete cascade,
    user_id uuid not null references auth.users on delete cascade,
    order_item_id bigint references public.order_items on delete set null, -- Link review to specific purchase
    rating smallint not null check (rating >= 1 and rating <= 5),
    comment text,
    is_approved boolean default false, -- Added approval flag
    approved_by uuid references auth.users on delete set null, -- Added approver
    approved_at timestamptz, -- Added approval timestamp
    created_at timestamptz default now(),
    updated_at timestamptz default now(),
    unique(user_id, product_id) -- Allow only one review per user per product
);
comment on table public.reviews is 'Stores customer reviews for products';

-- Bảng review_replies (New table for staff/admin replies)
create table public.review_replies (
    id bigint generated by default as identity primary key,
    review_id bigint not null references public.reviews on delete cascade,
    staff_id uuid not null references auth.users on delete cascade,
    reply_text text not null,
    created_at timestamptz default now(),
    updated_at timestamptz default now()
);
comment on table public.review_replies is 'Stores staff replies to customer reviews';

-- Bảng wishlists
create table public.wishlists (
    id bigint generated by default as identity primary key,
    user_id uuid not null references auth.users on delete cascade,
    product_id bigint not null references public.products on delete cascade, -- Changed to product_id
    added_at timestamptz default now(),
    unique (user_id, product_id)
);

-- Bảng admin_activity_log
create table public.admin_activity_log (
    id bigint generated by default as identity primary key,
    admin_user_id uuid references auth.users on delete set null, -- Allow system logs?
    activity_type text not null,
    description text,
    entity_type text, -- Added entity type (product, order, etc.)
    entity_id text, -- Added entity ID
    details jsonb, -- Store additional details like old/new values
    timestamp timestamptz default now()
);
comment on table public.admin_activity_log is 'Logs all admin/staff/system activities for auditing';

-- Bảng banners
create table public.banners (
    id bigint generated by default as identity primary key,
    title text not null,
    subtitle text,
    image_url text not null,
    link_url text,
    is_active boolean default true,
    display_order int default 0, -- Added display order
    start_date timestamptz,
    end_date timestamptz,
    created_at timestamptz default now(),
    updated_at timestamptz default now()
);

-- Bảng shop_settings (Updated with social media)
create table public.shop_settings (
    id smallint primary key default 1, -- Đảm bảo chỉ có một bản ghi, ID luôn là 1
    shop_name text not null,
    contact_email text,
    contact_phone text,
    address text, -- Added shop address
    facebook_url text, -- Added social media
    messenger_url text, -- Added messenger
    zalo_url text, -- Added Zalo
    instagram_url text, -- Added Instagram
    tiktok_url text, -- Added TikTok
    youtube_url text, -- Added YouTube
    refund_policy_text text,
    shipping_policy_text text, -- Added shipping policy
    privacy_policy_text text, -- Added privacy policy
    terms_conditions_text text, -- Added terms and conditions
    default_shipping_fee numeric default 0, -- Added default shipping fee
    created_at timestamptz default now(),
    updated_at timestamptz default now(),
    constraint single_row check (id = 1)
);

-- ============================================================================
-- ROW LEVEL SECURITY (RLS) - Enable RLS
-- ============================================================================

alter table public.addresses enable row level security;
alter table public.profiles enable row level security;
alter table public.brands enable row level security;
alter table public.genders enable row level security;
alter table public.perfume_types enable row level security;
alter table public.concentrations enable row level security;
alter table public.categories enable row level security;
alter table public.products enable row level security;
alter table public.scents enable row level security;
alter table public.ingredients enable row level security;
alter table public.product_variants enable row level security;
alter table public.product_scents enable row level security;
alter table public.product_ingredients enable row level security;
alter table public.product_images enable row level security;
alter table public.product_categories enable row level security;
alter table public.product_labels enable row level security;
alter table public.product_label_assignments enable row level security;
alter table public.discounts enable row level security;
alter table public.shopping_carts enable row level security;
alter table public.cart_items enable row level security;
alter table public.order_statuses enable row level security;
alter table public.payment_methods enable row level security;
alter table public.orders enable row level security;
alter table public.order_items enable row level security;
alter table public.payments enable row level security;
alter table public.inventory enable row level security;
alter table public.reviews enable row level security;
alter table public.review_replies enable row level security;
alter table public.wishlists enable row level security;
alter table public.admin_activity_log enable row level security;
alter table public.banners enable row level security;
alter table public.shop_settings enable row level security;

-- ============================================================================
-- FUNCTIONS & TRIGGERS - User Profile and Cart Creation
-- Use fixed version of handle_new_user
-- ============================================================================

-- Function to create profile on user signup (FIXED VERSION)
DROP FUNCTION IF EXISTS public.handle_new_user();
CREATE OR REPLACE FUNCTION public.handle_new_user()
RETURNS TRIGGER
SECURITY DEFINER
SET search_path = public
AS $$
BEGIN
  -- Chèn dữ liệu vào bảng profiles từ thông tin người dùng mới
  INSERT INTO public.profiles (
    id,                                      -- ID người dùng (từ auth.users)
    display_name,                            -- Tên hiển thị (từ metadata)
    phone_number,                            -- Số điện thoại (từ metadata)
    created_at,                              -- Thời gian tạo
    updated_at                               -- Thời gian cập nhật
  )
  VALUES (
    NEW.id,                                  -- Sử dụng ID từ bản ghi auth.users mới
    NEW.raw_user_meta_data->>'display_name', -- Lấy display_name từ metadata
    NEW.raw_user_meta_data->>'phone_number', -- Lấy phone_number từ metadata
    NOW(),                                   -- Thời gian hiện tại
    NOW()                                    -- Thời gian hiện tại
  );
  RETURN NEW;
END;
$$ LANGUAGE plpgsql;

-- Trigger for new user profile creation
DROP TRIGGER IF EXISTS on_auth_user_created_profile ON auth.users;
CREATE TRIGGER on_auth_user_created_profile
AFTER INSERT ON auth.users
FOR EACH ROW EXECUTE PROCEDURE public.handle_new_user();

-- Function to automatically create a shopping cart for new users
CREATE OR REPLACE FUNCTION public.create_shopping_cart_for_new_user()
RETURNS TRIGGER
SECURITY DEFINER
SET search_path = public
AS $$
BEGIN
  INSERT INTO public.shopping_carts (user_id)
  VALUES (NEW.id);
  RETURN NEW; -- Return NEW for AFTER trigger compatibility
END;
$$ LANGUAGE plpgsql;

-- Trigger for new user shopping cart creation
DROP TRIGGER IF EXISTS on_auth_user_created_cart ON auth.users;
CREATE TRIGGER on_auth_user_created_cart
AFTER INSERT ON auth.users
FOR EACH ROW EXECUTE PROCEDURE public.create_shopping_cart_for_new_user();


-- ============================================================================
-- FUNCTIONS & TRIGGERS - Handle updated_at
-- ============================================================================

-- Create function to update updated_at timestamp
create or replace function public.handle_updated_at()
returns trigger
security definer -- Consider if SECURITY INVOKER is sufficient
set search_path = public
as $$
begin
  new.updated_at = now();
  return new;
end;
$$ language plpgsql;

-- Create triggers for updated_at (Apply to relevant tables)
create trigger set_updated_at before update on public.addresses for each row execute procedure public.handle_updated_at();
create trigger set_updated_at before update on public.profiles for each row execute procedure public.handle_updated_at();
create trigger set_updated_at before update on public.brands for each row execute procedure public.handle_updated_at();
create trigger set_updated_at before update on public.genders for each row execute procedure public.handle_updated_at();
create trigger set_updated_at before update on public.perfume_types for each row execute procedure public.handle_updated_at();
create trigger set_updated_at before update on public.concentrations for each row execute procedure public.handle_updated_at();
create trigger set_updated_at before update on public.categories for each row execute procedure public.handle_updated_at();
create trigger set_updated_at before update on public.products for each row execute procedure public.handle_updated_at();
create trigger set_updated_at before update on public.scents for each row execute procedure public.handle_updated_at();
create trigger set_updated_at before update on public.ingredients for each row execute procedure public.handle_updated_at();
create trigger set_updated_at before update on public.product_variants for each row execute procedure public.handle_updated_at();
create trigger set_updated_at before update on public.product_images for each row execute procedure public.handle_updated_at();
create trigger set_updated_at before update on public.product_labels for each row execute procedure public.handle_updated_at();
create trigger set_updated_at before update on public.discounts for each row execute procedure public.handle_updated_at();
create trigger set_updated_at before update on public.shopping_carts for each row execute procedure public.handle_updated_at();
create trigger set_updated_at before update on public.cart_items for each row execute procedure public.handle_updated_at();
create trigger set_updated_at before update on public.orders for each row execute procedure public.handle_updated_at();
create trigger set_updated_at before update on public.order_items for each row execute procedure public.handle_updated_at();
create trigger set_updated_at before update on public.payments for each row execute procedure public.handle_updated_at();
create trigger set_updated_at before update on public.inventory for each row execute procedure public.handle_updated_at();
create trigger set_updated_at before update on public.reviews for each row execute procedure public.handle_updated_at();
create trigger set_updated_at before update on public.review_replies for each row execute procedure public.handle_updated_at();
create trigger set_updated_at before update on public.wishlists for each row execute procedure public.handle_updated_at();
create trigger set_updated_at before update on public.banners for each row execute procedure public.handle_updated_at();
create trigger set_updated_at before update on public.shop_settings for each row execute procedure public.handle_updated_at();

-- ============================================================================
-- FUNCTIONS - Role Checking (APPROACH 2: Read from app_metadata)
-- ============================================================================

-- Get user role by reading app_metadata from auth.users
DROP FUNCTION IF EXISTS public.get_auth_role();
CREATE OR REPLACE FUNCTION public.get_auth_role()
RETURNS TEXT
LANGUAGE sql STABLE SECURITY DEFINER SET search_path = public -- SECURITY DEFINER needed to read auth.users
AS $$
  SELECT
    CASE
      -- If not logged in, role is 'anon'
      WHEN auth.uid() IS NULL THEN 'anon'
      -- If logged in, try to read role from app_metadata
      ELSE coalesce(
        (SELECT raw_app_meta_data->>'role' FROM auth.users WHERE id = auth.uid()),
        'authenticated' -- Default to 'authenticated' if no role in metadata
      )
    END;
$$;

-- Helper function to check if user is admin
DROP FUNCTION IF EXISTS public.is_admin();
CREATE OR REPLACE FUNCTION public.is_admin()
RETURNS BOOLEAN
LANGUAGE sql STABLE SECURITY DEFINER SET search_path = public
AS $$
  SELECT public.get_auth_role() = 'admin';
$$;

-- Helper function to check if user is staff or admin
DROP FUNCTION IF EXISTS public.is_staff();
CREATE OR REPLACE FUNCTION public.is_staff()
RETURNS BOOLEAN
LANGUAGE sql STABLE SECURITY DEFINER SET search_path = public
AS $$
  SELECT public.get_auth_role() IN ('staff', 'admin');
$$;

-- ============================================================================
-- RLS POLICIES - User Specific Policies
-- ============================================================================

-- Addresses
create policy "Users can view their own addresses" on public.addresses for select using (auth.uid() = user_id);
create policy "Users can insert their own addresses" on public.addresses for insert with check (auth.uid() = user_id);
create policy "Users can update their own addresses" on public.addresses for update using (auth.uid() = user_id);
create policy "Users can delete their own addresses" on public.addresses for delete using (auth.uid() = user_id);

-- Profiles
create policy "Users can view their own profile" on public.profiles for select using (auth.uid() = id);
create policy "Users can update their own profile" on public.profiles for update using (auth.uid() = id);

-- Shopping Carts
create policy "Users can view their own shopping carts" on public.shopping_carts for select using (auth.uid() = user_id);
create policy "Users can insert their own shopping carts" on public.shopping_carts for insert with check (auth.uid() = user_id); -- Note: Trigger handles this
create policy "Users can update their own shopping carts" on public.shopping_carts for update using (auth.uid() = user_id);
create policy "Users can delete their own shopping carts" on public.shopping_carts for delete using (auth.uid() = user_id);

-- Cart Items
create policy "Users can view their own cart items" on public.cart_items for select using (exists (select 1 from public.shopping_carts where id = cart_id and user_id = auth.uid()));
create policy "Users can insert their own cart items" on public.cart_items for insert with check (exists (select 1 from public.shopping_carts where id = cart_id and user_id = auth.uid()));
create policy "Users can update their own cart items" on public.cart_items for update using (exists (select 1 from public.shopping_carts where id = cart_id and user_id = auth.uid()));
create policy "Users can delete their own cart items" on public.cart_items for delete using (exists (select 1 from public.shopping_carts where id = cart_id and user_id = auth.uid()));

-- Orders (Allow guest access check)
create policy "Users can view their own orders" on public.orders for select using (auth.uid() = user_id or auth.uid() is null); -- Allow select for guests (careful!)
create policy "Users can insert their own orders" on public.orders for insert with check (auth.uid() = user_id or auth.uid() is null); -- Allow insert for guests

-- Order Items (Allow guest access check)
create policy "Users can view their own order items" on public.order_items for select using (exists (select 1 from public.orders where id = order_id and (user_id = auth.uid() or auth.uid() is null)));
-- Generally, users shouldn't insert/update/delete order items directly
-- create policy "Users can insert their own order items" on public.order_items for insert with check (exists (select 1 from public.orders where id = order_id and (user_id = auth.uid() or auth.uid() is null)));

-- Payments
create policy "Users can view their own payments" on public.payments for select using (exists (select 1 from public.orders where id = order_id and user_id = auth.uid()));
-- Users generally don't manage payments directly

-- Reviews
create policy "Users can view all their own reviews" on public.reviews for select using (auth.uid() = user_id);
-- Insert policy requires purchase check (defined later with has_user_purchased_product function)
create policy "Users can update their own unapproved reviews" on public.reviews for update using (auth.uid() = user_id and is_approved = false);
create policy "Users can delete their own reviews" on public.reviews for delete using (auth.uid() = user_id);

-- Wishlists
create policy "Users can view their own wishlists" on public.wishlists for select using (auth.uid() = user_id);
create policy "Users can insert into their own wishlists" on public.wishlists for insert with check (auth.uid() = user_id);
-- Update doesn't make much sense for wishlists, usually just add/remove
-- create policy "Users can update their own wishlists" on public.wishlists for update using (auth.uid() = user_id);
create policy "Users can delete from their own wishlists" on public.wishlists for delete using (auth.uid() = user_id);

-- ============================================================================
-- RLS POLICIES - Public Access Policies
-- ============================================================================

create policy "Brands are viewable by everyone" on public.brands for select to anon, authenticated using (true);
create policy "Genders are viewable by everyone" on public.genders for select to anon, authenticated using (true);
create policy "Perfume types are viewable by everyone" on public.perfume_types for select to anon, authenticated using (true);
create policy "Concentrations are viewable by everyone" on public.concentrations for select to anon, authenticated using (true);
create policy "Categories are viewable by everyone" on public.categories for select to anon, authenticated using (true);
create policy "Products are viewable by everyone" on public.products for select to anon, authenticated using (deleted_at is null);
create policy "Scents are viewable by everyone" on public.scents for select to anon, authenticated using (true);
create policy "Ingredients are viewable by everyone" on public.ingredients for select to anon, authenticated using (true);
create policy "Product variants are viewable by everyone" on public.product_variants for select to anon, authenticated using (deleted_at is null);
create policy "Product scents are viewable by everyone" on public.product_scents for select to anon, authenticated using (true);
create policy "Product ingredients are viewable by everyone" on public.product_ingredients for select to anon, authenticated using (true);
create policy "Product images are viewable by everyone" on public.product_images for select to anon, authenticated using (true);
create policy "Product categories are viewable by everyone" on public.product_categories for select to anon, authenticated using (true);
create policy "Product labels are viewable by everyone" on public.product_labels for select to anon, authenticated using (true);
create policy "Product label assignments are viewable by everyone" on public.product_label_assignments for select to anon, authenticated using (true);
create policy "Active discounts are viewable by everyone" on public.discounts for select to anon, authenticated using (is_active = true and (start_date is null or start_date <= now()) and (end_date is null or end_date >= now()));
create policy "Order statuses are viewable by everyone" on public.order_statuses for select to anon, authenticated using (true);
create policy "Active payment methods are viewable by everyone" on public.payment_methods for select to anon, authenticated using (is_active = true);
-- Inventory view policy depends on requirements. Making it public for now.
create policy "Inventory logs are viewable by everyone" on public.inventory for select to anon, authenticated using (true);
create policy "Approved reviews are viewable by everyone" on public.reviews for select to anon, authenticated using (is_approved = true);
create policy "Review replies are viewable by everyone" on public.review_replies for select to anon, authenticated using (true);
create policy "Active banners are viewable by everyone" on public.banners for select to anon, authenticated using (is_active = true and (start_date is null or start_date <= now()) and (end_date is null or end_date >= now()));
create policy "Shop settings are viewable by everyone" on public.shop_settings for select to anon, authenticated using (true);


-- ============================================================================
-- RLS POLICIES - Staff & Admin Policies (Using is_staff() and is_admin())
-- These MUST come AFTER the role checking functions are defined
-- ============================================================================

-- Admin full management policies (using covers SELECT, INSERT, UPDATE, DELETE)
create policy "Admins can manage all addresses" on public.addresses using (public.is_admin());
create policy "Admins can manage all profiles" on public.profiles using (public.is_admin());
create policy "Only admins can manage brands" on public.brands using (public.is_admin());
create policy "Only admins can manage genders" on public.genders using (public.is_admin());
create policy "Only admins can manage perfume types" on public.perfume_types using (public.is_admin());
create policy "Only admins can manage concentrations" on public.concentrations using (public.is_admin());
create policy "Only admins can manage categories" on public.categories using (public.is_admin());
create policy "Only admins can manage products" on public.products using (public.is_admin());
create policy "Only admins can manage scents" on public.scents using (public.is_admin());
create policy "Only admins can manage ingredients" on public.ingredients using (public.is_admin());
create policy "Only admins can manage product variants" on public.product_variants using (public.is_admin());
create policy "Only admins can manage product scents" on public.product_scents using (public.is_admin());
create policy "Only admins can manage product ingredients" on public.product_ingredients using (public.is_admin());
create policy "Only admins can manage product images" on public.product_images using (public.is_admin());
create policy "Only admins can manage product categories" on public.product_categories using (public.is_admin());
create policy "Only admins can manage product labels" on public.product_labels using (public.is_admin());
create policy "Only admins can manage product label assignments" on public.product_label_assignments using (public.is_admin());
create policy "Only admins can manage discounts" on public.discounts using (public.is_admin()); -- Overwrites public view for admin
create policy "Admins can manage all shopping carts" on public.shopping_carts using (public.is_admin());
create policy "Admins can manage all cart items" on public.cart_items using (public.is_admin());
create policy "Only admins can manage order statuses" on public.order_statuses using (public.is_admin());
create policy "Only admins can manage payment methods" on public.payment_methods using (public.is_admin()); -- Overwrites public view for admin
-- Staff policies (more granular)
create policy "Staff can view all orders" on public.orders for select using (public.is_staff());
create policy "Staff can update orders" on public.orders for update using (public.is_staff()) with check (public.is_staff());
create policy "Staff can view all order items" on public.order_items for select using (public.is_staff());
-- Staff generally don't update order items directly
-- create policy "Staff can update order items" on public.order_items for update using (public.is_staff()) with check (public.is_staff());
create policy "Staff can view all payments" on public.payments for select using (public.is_staff());
create policy "Staff can manage payments" on public.payments for all using (public.is_staff()); -- Allow staff CRUD on payments
-- Inventory: Assuming only Admin manages inventory logs directly
create policy "Only admins can manage inventory" on public.inventory using (public.is_admin());
create policy "Staff can view all reviews" on public.reviews for select using (public.is_staff());
create policy "Staff can approve reviews" on public.reviews for update using (public.is_staff()) with check (public.is_staff()); -- Check required for update RLS
create policy "Staff can reply to reviews" on public.review_replies for insert with check (public.is_staff());
create policy "Staff can manage review replies" on public.review_replies for all using (public.is_staff());
create policy "Admins can manage all wishlists" on public.wishlists using (public.is_admin());
create policy "Only admins can view admin activity logs" on public.admin_activity_log for select using (public.is_admin());
create policy "Only admins/system can insert admin activity logs" on public.admin_activity_log for insert with check (public.is_admin() or auth.uid() is null); -- Allow system inserts? Or restrict to admin
create policy "Only admins can manage banners" on public.banners using (public.is_admin()); -- Overwrites public view for admin
create policy "Only admins can manage shop settings" on public.shop_settings using (public.is_admin()); -- Overwrites public view for admin


-- ============================================================================
-- FUNCTIONS & TRIGGERS - Business Logic & Automation
-- ============================================================================

-- Function to check if a user has purchased a product (for review policies)
DROP FUNCTION IF EXISTS public.has_user_purchased_product(bigint);
CREATE OR REPLACE FUNCTION public.has_user_purchased_product(p_product_id bigint)
RETURNS boolean
LANGUAGE plpgsql STABLE SECURITY DEFINER SET search_path = public
AS $$
DECLARE
  delivered_status_id smallint;
BEGIN
  SELECT id INTO delivered_status_id FROM public.order_statuses WHERE name = 'Delivered'; -- Or 'Completed' if used

  RETURN EXISTS (
    SELECT 1
    FROM public.orders o
    JOIN public.order_items oi ON o.id = oi.order_id
    JOIN public.product_variants pv ON oi.variant_id = pv.id
    WHERE o.user_id = auth.uid()
      AND pv.product_id = p_product_id
      AND o.order_status_id = delivered_status_id
  );
END;
$$;

-- Add review policy that uses the purchase check function
-- Drop the generic user insert policy if it exists from initial setup
-- drop policy if exists "Users can insert their own reviews" on public.reviews;
create policy "Users can insert reviews for purchased products"
on public.reviews for insert
with check (
  auth.uid() = user_id and
  public.has_user_purchased_product(product_id)
);


-- Function to update inventory and log when order status changes to 'Shipped'
DROP FUNCTION IF EXISTS public.update_inventory_on_order_shipped();
CREATE OR REPLACE FUNCTION public.update_inventory_on_order_shipped()
RETURNS TRIGGER
LANGUAGE plpgsql SECURITY DEFINER SET search_path = public
AS $$
DECLARE
  shipped_status_id smallint;
  item record;
  current_stock integer;
BEGIN
  SELECT id INTO shipped_status_id FROM public.order_statuses WHERE name = 'Shipped';

  -- Check if the status is updated TO 'Shipped'
  IF NEW.order_status_id = shipped_status_id AND (OLD.order_status_id IS NULL OR OLD.order_status_id != shipped_status_id) THEN
    -- Loop through order items
    FOR item IN SELECT variant_id, quantity FROM public.order_items WHERE order_id = NEW.id LOOP
      -- Update stock in product_variants (source of truth)
      UPDATE public.product_variants pv
      SET stock_quantity = stock_quantity - item.quantity
      WHERE id = item.variant_id
      RETURNING stock_quantity INTO current_stock;

      -- Log the change in the inventory table
      INSERT INTO public.inventory (variant_id, change_amount, reason, order_id, stock_after_change, updated_by)
      VALUES (item.variant_id, -item.quantity, 'Order Shipped', NEW.id, current_stock, NEW.user_id); -- Or null if system action?
    END LOOP;

    -- Log the overall action in admin_activity_log
    INSERT INTO public.admin_activity_log (admin_user_id, activity_type, description, entity_type, entity_id, details)
    VALUES (
        auth.uid(), -- Assumes staff/admin triggered the update
        'INVENTORY_UPDATE',
        'Stock decreased due to order ' || NEW.id || ' shipped.',
        'order',
        NEW.id::text,
        jsonb_build_object('order_id', NEW.id)
     );
  END IF;

  RETURN NEW;
END;
$$;

-- Trigger for inventory update
DROP TRIGGER IF EXISTS trigger_update_inventory_on_order_shipped ON public.orders;
CREATE TRIGGER trigger_update_inventory_on_order_shipped
AFTER UPDATE ON public.orders
FOR EACH ROW EXECUTE PROCEDURE public.update_inventory_on_order_shipped();


-- Function to validate stock before adding/updating cart items
DROP FUNCTION IF EXISTS public.validate_stock_before_cart_change();
CREATE OR REPLACE FUNCTION public.validate_stock_before_cart_change()
RETURNS TRIGGER
LANGUAGE plpgsql SECURITY DEFINER SET search_path = public
AS $$
DECLARE
  available_stock integer;
  product_name_text text;
BEGIN
  -- Get available stock and product name
  SELECT pv.stock_quantity, p.name
  INTO available_stock, product_name_text
  FROM public.product_variants pv
  JOIN public.products p ON pv.product_id = p.id
  WHERE pv.id = NEW.variant_id;

  -- Check if enough stock is available
  IF available_stock < NEW.quantity THEN
    RAISE EXCEPTION 'Không đủ hàng cho "%". Chỉ còn % sản phẩm.', product_name_text, available_stock;
  END IF;

  RETURN NEW;
END;
$$;

-- Trigger for stock validation on cart
DROP TRIGGER IF EXISTS trigger_validate_stock_before_cart_change ON public.cart_items;
CREATE TRIGGER trigger_validate_stock_before_cart_change
BEFORE INSERT OR UPDATE ON public.cart_items
FOR EACH ROW EXECUTE PROCEDURE public.validate_stock_before_cart_change();


-- Function to generate slugs (basic version)
DROP FUNCTION IF EXISTS public.generate_slug(text);
CREATE OR REPLACE FUNCTION public.generate_slug(name_input text)
RETURNS text
LANGUAGE sql IMMUTABLE STRICT -- Mark as IMMUTABLE and STRICT
AS $$
  SELECT lower(regexp_replace(trim(name_input), '[^a-zA-Z0-9\u00C0-\u1EF9]+', '-', 'g'))
  -- Basic Vietnamese character support added (\u00C0-\u1EF9) - needs testing/refinement
$$;


-- Trigger function to automatically set slugs for products
DROP FUNCTION IF EXISTS public.set_product_slug();
CREATE OR REPLACE FUNCTION public.set_product_slug()
RETURNS TRIGGER
LANGUAGE plpgsql SECURITY DEFINER SET search_path = public
AS $$
DECLARE
  base_slug text;
  final_slug text;
  counter integer := 0;
BEGIN
  IF (TG_OP = 'INSERT' OR NEW.name != OLD.name) AND (NEW.slug IS NULL OR NEW.slug = '') THEN
    base_slug := public.generate_slug(NEW.name);
    final_slug := base_slug;

    -- Ensure slug is unique by appending a number if needed
    WHILE EXISTS (SELECT 1 FROM public.products WHERE slug = final_slug AND id != NEW.id) LOOP
      counter := counter + 1;
      final_slug := base_slug || '-' || counter::text;
    END LOOP;
    NEW.slug := final_slug;
  END IF;
  RETURN NEW;
END;
$$;

-- Trigger for product slug generation
DROP TRIGGER IF EXISTS trigger_set_product_slug ON public.products;
CREATE TRIGGER trigger_set_product_slug
BEFORE INSERT OR UPDATE ON public.products
FOR EACH ROW EXECUTE PROCEDURE public.set_product_slug();


-- Trigger function to automatically set slugs for categories
DROP FUNCTION IF EXISTS public.set_category_slug();
CREATE OR REPLACE FUNCTION public.set_category_slug()
RETURNS TRIGGER
LANGUAGE plpgsql SECURITY DEFINER SET search_path = public
AS $$
DECLARE
  base_slug text;
  final_slug text;
  counter integer := 0;
BEGIN
  IF (TG_OP = 'INSERT' OR NEW.name != OLD.name) AND (NEW.slug IS NULL OR NEW.slug = '') THEN
    base_slug := public.generate_slug(NEW.name);
    final_slug := base_slug;

    -- Ensure slug is unique by appending a number if needed
    WHILE EXISTS (SELECT 1 FROM public.categories WHERE slug = final_slug AND id != NEW.id) LOOP
      counter := counter + 1;
      final_slug := base_slug || '-' || counter::text;
    END LOOP;
    NEW.slug := final_slug;
  END IF;
  RETURN NEW;
END;
$$;

-- Trigger for category slug generation
DROP TRIGGER IF EXISTS trigger_set_category_slug ON public.categories;
CREATE TRIGGER trigger_set_category_slug
BEFORE INSERT OR UPDATE ON public.categories
FOR EACH ROW EXECUTE PROCEDURE public.set_category_slug();


-- Function to validate discount code usage before order insert
DROP FUNCTION IF EXISTS public.validate_discount_code();
CREATE OR REPLACE FUNCTION public.validate_discount_code()
RETURNS TRIGGER
LANGUAGE plpgsql SECURITY DEFINER SET search_path = public
AS $$
DECLARE
  discount_record public.discounts%rowtype;
BEGIN
  -- Only run if a discount_id is provided
  IF NEW.discount_id IS NOT NULL THEN
    -- Get discount record
    SELECT * INTO discount_record
    FROM public.discounts
    WHERE id = NEW.discount_id;

    -- Check if discount exists
    IF discount_record IS NULL THEN
      RAISE EXCEPTION 'Mã giảm giá không hợp lệ.';
    END IF;

    -- Check if discount is active
    IF discount_record.is_active = false OR
       (discount_record.start_date IS NOT NULL AND discount_record.start_date > now()) OR
       (discount_record.end_date IS NOT NULL AND discount_record.end_date < now()) THEN
      RAISE EXCEPTION 'Mã giảm giá "%" không còn hiệu lực hoặc chưa bắt đầu.', discount_record.code;
    END IF;

    -- Check remaining uses
    IF discount_record.max_uses IS NOT NULL AND
       discount_record.remaining_uses IS NOT NULL AND
       discount_record.remaining_uses <= 0 THEN
      RAISE EXCEPTION 'Mã giảm giá "%" đã hết lượt sử dụng.', discount_record.code;
    END IF;

    -- Check minimum order value (use NEW.subtotal_amount calculated by the other trigger)
    IF discount_record.min_order_value IS NOT NULL AND
       NEW.subtotal_amount < discount_record.min_order_value THEN
      RAISE EXCEPTION 'Đơn hàng chưa đạt giá trị tối thiểu % để sử dụng mã "%".', discount_record.min_order_value, discount_record.code;
    END IF;

    -- Decrement remaining uses (only if applicable)
    IF discount_record.remaining_uses IS NOT NULL THEN
      UPDATE public.discounts
      SET remaining_uses = remaining_uses - 1
      WHERE id = NEW.discount_id;
    END IF;
  END IF; -- End check for NEW.discount_id IS NOT NULL

  RETURN NEW;
END;
$$;

-- Trigger for discount validation (runs AFTER calculate_order_total)
DROP TRIGGER IF EXISTS trigger_validate_discount_code ON public.orders;
CREATE TRIGGER trigger_validate_discount_code
BEFORE INSERT ON public.orders -- Runs before insert
FOR EACH ROW EXECUTE PROCEDURE public.validate_discount_code();


-- Function to calculate and update order total (Subtotal, Discount, Shipping, Total)
DROP FUNCTION IF EXISTS public.calculate_order_total();
CREATE OR REPLACE FUNCTION public.calculate_order_total()
RETURNS TRIGGER
LANGUAGE plpgsql SECURITY DEFINER SET search_path = public
AS $$
DECLARE
  items_total numeric := 0;
  calculated_discount_amount numeric := 0;
  calculated_shipping_fee numeric := 0; -- Add logic later if needed
  discount_record public.discounts%rowtype;
  settings_record public.shop_settings%rowtype;
BEGIN
  -- Calculate items total from associated order_items (This trigger runs on INSERT/UPDATE of orders, items might not exist yet on INSERT)
  -- ***** IMPORTANT: This calculation needs to happen *after* order_items are inserted, or be based on cart data passed somehow. *****
  -- ***** Let's assume subtotal is set correctly by the application BEFORE saving the order, or calculated differently. *****
  -- ***** For now, we'll assume NEW.subtotal_amount is provided correctly. *****
  items_total := NEW.subtotal_amount;

  -- Get shop settings for default shipping fee
  SELECT * INTO settings_record FROM public.shop_settings WHERE id = 1;
  calculated_shipping_fee := coalesce(NEW.shipping_fee, settings_record.default_shipping_fee, 0); -- Use order's fee if set, else default, else 0

  -- Apply discount if present and valid
  IF NEW.discount_id IS NOT NULL THEN
    SELECT * INTO discount_record
    FROM public.discounts
    WHERE id = NEW.discount_id;

    -- Ensure discount record was found (already validated by previous trigger, but good practice)
    IF discount_record IS NOT NULL THEN
      IF discount_record.discount_percentage IS NOT NULL THEN
        calculated_discount_amount := items_total * (discount_record.discount_percentage / 100.0);

        -- Apply maximum discount amount if specified
        IF discount_record.max_discount_amount IS NOT NULL AND
           calculated_discount_amount > discount_record.max_discount_amount THEN
          calculated_discount_amount := discount_record.max_discount_amount;
        END IF;
      ELSE
         -- Handle fixed amount discounts if you add that feature
         calculated_discount_amount := 0; -- Placeholder
      END IF;
    END IF;
  END IF;

  -- Update order fields
  NEW.subtotal_amount := items_total; -- Ensure it's set
  NEW.discount_amount := calculated_discount_amount;
  NEW.shipping_fee := calculated_shipping_fee;
  NEW.total_amount := items_total - calculated_discount_amount + calculated_shipping_fee;

  -- Ensure total is not negative
  IF NEW.total_amount < 0 THEN
      NEW.total_amount := 0;
  END IF;

  RETURN NEW;
END;
$$;

-- Trigger for order total calculation (Runs BEFORE discount validation)
DROP TRIGGER IF EXISTS trigger_calculate_order_total ON public.orders;
CREATE TRIGGER trigger_calculate_order_total
BEFORE INSERT OR UPDATE ON public.orders
FOR EACH ROW EXECUTE PROCEDURE public.calculate_order_total();


-- Function to log admin/staff activities
DROP FUNCTION IF EXISTS public.log_admin_activity();
CREATE OR REPLACE FUNCTION public.log_admin_activity()
RETURNS TRIGGER
LANGUAGE plpgsql SECURITY DEFINER SET search_path = public
AS $$
DECLARE
  activity_type text := NULL;
  description text := NULL;
  entity_type text := NULL;
  entity_id text := NULL;
  details jsonb := NULL;
  actor_role text;
  old_data jsonb := NULL;
  new_data jsonb := NULL;
BEGIN
  -- Only log if triggered by staff or admin
  actor_role := public.get_auth_role();
  IF actor_role NOT IN ('admin', 'staff') THEN
    RETURN NULL; -- Exit if not admin or staff
  END IF;

  entity_type := TG_TABLE_NAME;

  -- Capture old/new data for details (optional)
  IF TG_OP = 'UPDATE' THEN
    old_data := to_jsonb(OLD);
    new_data := to_jsonb(NEW);
    details := jsonb_build_object('old', old_data, 'new', new_data);
    entity_id := OLD.id::text; -- Use OLD.id for update/delete consistency
  ELSIF TG_OP = 'DELETE' THEN
    old_data := to_jsonb(OLD);
    details := jsonb_build_object('deleted', old_data);
    entity_id := OLD.id::text;
  ELSIF TG_OP = 'INSERT' THEN
    new_data := to_jsonb(NEW);
    details := jsonb_build_object('created', new_data);
    entity_id := NEW.id::text;
  END IF;


  -- Determine activity type and description based on table and operation
  IF TG_TABLE_NAME = 'products' THEN
    IF TG_OP = 'INSERT' THEN activity_type := 'PRODUCT_CREATE'; description := 'Created product: ' || NEW.name;
    ELSIF TG_OP = 'UPDATE' THEN activity_type := 'PRODUCT_UPDATE'; description := 'Updated product: ' || NEW.name;
    ELSIF TG_OP = 'DELETE' THEN activity_type := 'PRODUCT_DELETE'; description := 'Deleted product: ' || OLD.name; END IF;
  ELSIF TG_TABLE_NAME = 'categories' THEN
    IF TG_OP = 'INSERT' THEN activity_type := 'CATEGORY_CREATE'; description := 'Created category: ' || NEW.name;
    ELSIF TG_OP = 'UPDATE' THEN activity_type := 'CATEGORY_UPDATE'; description := 'Updated category: ' || NEW.name;
    ELSIF TG_OP = 'DELETE' THEN activity_type := 'CATEGORY_DELETE'; description := 'Deleted category: ' || OLD.name; END IF;
  ELSIF TG_TABLE_NAME = 'brands' THEN
     IF TG_OP = 'INSERT' THEN activity_type := 'BRAND_CREATE'; description := 'Created brand: ' || NEW.name;
     ELSIF TG_OP = 'UPDATE' THEN activity_type := 'BRAND_UPDATE'; description := 'Updated brand: ' || NEW.name;
     ELSIF TG_OP = 'DELETE' THEN activity_type := 'BRAND_DELETE'; description := 'Deleted brand: ' || OLD.name; END IF;
   ELSIF TG_TABLE_NAME = 'discounts' THEN
     IF TG_OP = 'INSERT' THEN activity_type := 'DISCOUNT_CREATE'; description := 'Created discount: ' || NEW.code;
     ELSIF TG_OP = 'UPDATE' THEN activity_type := 'DISCOUNT_UPDATE'; description := 'Updated discount: ' || NEW.code;
     ELSIF TG_OP = 'DELETE' THEN activity_type := 'DISCOUNT_DELETE'; description := 'Deleted discount: ' || OLD.code; END IF;
  ELSIF TG_TABLE_NAME = 'orders' THEN
    IF TG_OP = 'UPDATE' AND OLD.order_status_id IS DISTINCT FROM NEW.order_status_id THEN
      activity_type := 'ORDER_STATUS_CHANGE';
      description := 'Changed order #' || NEW.id || ' status from ' ||
                    coalesce((SELECT name FROM public.order_statuses WHERE id = OLD.order_status_id), 'NULL') || ' to ' ||
                    coalesce((SELECT name FROM public.order_statuses WHERE id = NEW.order_status_id), 'NULL');
    END IF;
    -- Add more checks for other order updates if needed
  ELSIF TG_TABLE_NAME = 'reviews' THEN
    IF TG_OP = 'UPDATE' AND OLD.is_approved IS DISTINCT FROM NEW.is_approved THEN
      IF NEW.is_approved = true THEN
         activity_type := 'REVIEW_APPROVE';
         description := 'Approved review #' || NEW.id;
      ELSE
         activity_type := 'REVIEW_UNAPPROVE';
         description := 'Unapproved review #' || NEW.id;
      END IF;
    ELSIF TG_OP = 'DELETE' THEN
       activity_type := 'REVIEW_DELETE';
       description := 'Deleted review #' || OLD.id;
    END IF;
  ELSIF TG_TABLE_NAME = 'review_replies' THEN
      IF TG_OP = 'INSERT' THEN activity_type := 'REVIEW_REPLY_CREATE'; description := 'Replied to review #' || NEW.review_id;
      ELSIF TG_OP = 'UPDATE' THEN activity_type := 'REVIEW_REPLY_UPDATE'; description := 'Updated reply to review #' || NEW.review_id;
      ELSIF TG_OP = 'DELETE' THEN activity_type := 'REVIEW_REPLY_DELETE'; description := 'Deleted reply to review #' || OLD.review_id; END IF;
  -- Add logs for other tables like users (role change), settings, etc.
  END IF;

  -- Log activity if type is determined
  IF activity_type IS NOT NULL THEN
    INSERT INTO public.admin_activity_log (admin_user_id, activity_type, description, entity_type, entity_id, details)
    VALUES (auth.uid(), activity_type, description, entity_type, entity_id, details);
  END IF;

  -- AFTER triggers should return NULL
  RETURN NULL;
END;
$$;

-- Create triggers for admin activity logging (Apply to tables managed by admin/staff)
DROP TRIGGER IF EXISTS trigger_log_admin_activity_products ON public.products;
CREATE TRIGGER trigger_log_admin_activity_products AFTER INSERT OR UPDATE OR DELETE ON public.products FOR EACH ROW EXECUTE PROCEDURE public.log_admin_activity();

DROP TRIGGER IF EXISTS trigger_log_admin_activity_categories ON public.categories;
CREATE TRIGGER trigger_log_admin_activity_categories AFTER INSERT OR UPDATE OR DELETE ON public.categories FOR EACH ROW EXECUTE PROCEDURE public.log_admin_activity();

DROP TRIGGER IF EXISTS trigger_log_admin_activity_brands ON public.brands;
CREATE TRIGGER trigger_log_admin_activity_brands AFTER INSERT OR UPDATE OR DELETE ON public.brands FOR EACH ROW EXECUTE PROCEDURE public.log_admin_activity();

DROP TRIGGER IF EXISTS trigger_log_admin_activity_discounts ON public.discounts;
CREATE TRIGGER trigger_log_admin_activity_discounts AFTER INSERT OR UPDATE OR DELETE ON public.discounts FOR EACH ROW EXECUTE PROCEDURE public.log_admin_activity();

DROP TRIGGER IF EXISTS trigger_log_admin_activity_orders ON public.orders;
CREATE TRIGGER trigger_log_admin_activity_orders AFTER UPDATE ON public.orders FOR EACH ROW EXECUTE PROCEDURE public.log_admin_activity(); -- Only log updates for now

DROP TRIGGER IF EXISTS trigger_log_admin_activity_reviews ON public.reviews;
CREATE TRIGGER trigger_log_admin_activity_reviews AFTER UPDATE OR DELETE ON public.reviews FOR EACH ROW EXECUTE PROCEDURE public.log_admin_activity(); -- Log approval/delete

DROP TRIGGER IF EXISTS trigger_log_admin_activity_review_replies ON public.review_replies;
CREATE TRIGGER trigger_log_admin_activity_review_replies AFTER INSERT OR UPDATE OR DELETE ON public.review_replies FOR EACH ROW EXECUTE PROCEDURE public.log_admin_activity();

-- Add triggers for other relevant tables (banners, settings, payment_methods, etc.) if needed


-- ============================================================================
-- FUNCTIONS - Helper Functions for Admin/Staff (Callable via RPC)
-- ============================================================================

-- Add a function to approve reviews
DROP FUNCTION IF EXISTS public.approve_review(bigint);
CREATE OR REPLACE FUNCTION public.approve_review(p_review_id bigint)
RETURNS void
LANGUAGE plpgsql SECURITY DEFINER SET search_path = public
AS $$
BEGIN
  -- Check if user is staff or admin
  IF NOT public.is_staff() THEN
    RAISE EXCEPTION 'AUTH_REQUIRED: Chỉ có nhân viên hoặc quản trị viên mới có thể duyệt đánh giá.';
  END IF;

  -- Update review
  UPDATE public.reviews
  SET
    is_approved = true,
    approved_by = auth.uid(),
    approved_at = now()
  WHERE id = p_review_id;

  -- Log this action
   INSERT INTO public.admin_activity_log (admin_user_id, activity_type, description, entity_type, entity_id)
   VALUES (auth.uid(), 'REVIEW_APPROVE', 'Approved review #' || p_review_id, 'review', p_review_id::text);

END;
$$;

-- Add a function to reply to reviews
DROP FUNCTION IF EXISTS public.reply_to_review(bigint, text);
CREATE OR REPLACE FUNCTION public.reply_to_review(p_review_id bigint, p_reply_text text)
RETURNS bigint -- Return the new reply ID
LANGUAGE plpgsql SECURITY DEFINER SET search_path = public
AS $$
DECLARE
  new_reply_id bigint;
BEGIN
  -- Check if user is staff or admin
  IF NOT public.is_staff() THEN
    RAISE EXCEPTION 'AUTH_REQUIRED: Chỉ có nhân viên hoặc quản trị viên mới có thể phản hồi đánh giá.';
  END IF;

  -- Insert reply
  INSERT INTO public.review_replies (review_id, staff_id, reply_text)
  VALUES (p_review_id, auth.uid(), p_reply_text)
  RETURNING id INTO new_reply_id;

   -- Log this action (handled by trigger trigger_log_admin_activity_review_replies)

  RETURN new_reply_id;
END;
$$;


-- ============================================================================
-- INDEXES
-- ============================================================================

-- Index cho bảng products
CREATE INDEX IF NOT EXISTS idx_products_brand_id ON public.products (brand_id);
CREATE INDEX IF NOT EXISTS idx_products_gender_id ON public.products (gender_id);
CREATE INDEX IF NOT EXISTS idx_products_perfume_type_id ON public.products (perfume_type_id);
CREATE INDEX IF NOT EXISTS idx_products_concentration_id ON public.products (concentration_id);
CREATE INDEX IF NOT EXISTS idx_products_slug ON public.products (slug); -- Index slug
CREATE INDEX IF NOT EXISTS idx_products_created_at ON public.products (created_at DESC); -- Dùng cho sắp xếp sản phẩm mới nhất
CREATE INDEX IF NOT EXISTS idx_products_deleted_at ON public.products (deleted_at); -- Lọc sản phẩm active

-- Index cho bảng product_variants
CREATE INDEX IF NOT EXISTS idx_product_variants_product_id ON public.product_variants (product_id);
CREATE INDEX IF NOT EXISTS idx_product_variants_sku ON public.product_variants (sku); -- Index SKU
CREATE INDEX IF NOT EXISTS idx_product_variants_price ON public.product_variants (price); -- Lọc/sắp xếp theo giá
CREATE INDEX IF NOT EXISTS idx_product_variants_sale_price ON public.product_variants (sale_price); -- Lọc sản phẩm đang giảm giá
CREATE INDEX IF NOT EXISTS idx_product_variants_deleted_at ON public.product_variants (deleted_at); -- Lọc variant active

-- Index cho bảng product_scents, product_ingredients, product_categories
CREATE INDEX IF NOT EXISTS idx_product_scents_product_id ON public.product_scents (product_id);
CREATE INDEX IF NOT EXISTS idx_product_ingredients_product_id ON public.product_ingredients (product_id);
CREATE INDEX IF NOT EXISTS idx_product_categories_product_id ON public.product_categories (product_id);
CREATE INDEX IF NOT EXISTS idx_product_categories_category_id ON public.product_categories (category_id); -- Index category_id

-- Index cho bảng product_images
CREATE INDEX IF NOT EXISTS idx_product_images_product_id ON public.product_images (product_id);
CREATE INDEX IF NOT EXISTS idx_product_images_is_main ON public.product_images (is_main); -- Lọc ảnh chính

-- Index cho bảng cart_items
CREATE INDEX IF NOT EXISTS idx_cart_items_cart_id ON public.cart_items (cart_id);
CREATE INDEX IF NOT EXISTS idx_cart_items_variant_id ON public.cart_items (variant_id);

-- Index cho bảng order_items
CREATE INDEX IF NOT EXISTS idx_order_items_order_id ON public.order_items (order_id);
CREATE INDEX IF NOT EXISTS idx_order_items_variant_id ON public.order_items (variant_id);

-- Index cho bảng orders
CREATE INDEX IF NOT EXISTS idx_orders_user_id ON public.orders (user_id);
CREATE INDEX IF NOT EXISTS idx_orders_payment_method_id ON public.orders (payment_method_id);
CREATE INDEX IF NOT EXISTS idx_orders_order_status_id ON public.orders (order_status_id);
CREATE INDEX IF NOT EXISTS idx_orders_discount_id ON public.orders (discount_id);
CREATE INDEX IF NOT EXISTS idx_orders_order_date ON public.orders (order_date DESC); -- Sắp xếp đơn hàng theo ngày

-- Index cho bảng payments
CREATE INDEX IF NOT EXISTS idx_payments_order_id ON public.payments (order_id);

-- Index cho bảng inventory
CREATE INDEX IF NOT EXISTS idx_inventory_variant_id ON public.inventory (variant_id);
CREATE INDEX IF NOT EXISTS idx_inventory_timestamp ON public.inventory (timestamp DESC); -- Sắp xếp lịch sử tồn kho

-- Index cho bảng reviews
CREATE INDEX IF NOT EXISTS idx_reviews_product_id ON public.reviews (product_id);
CREATE INDEX IF NOT EXISTS idx_reviews_user_id ON public.reviews (user_id);
CREATE INDEX IF NOT EXISTS idx_reviews_is_approved ON public.reviews (is_approved); -- Lọc review đã được duyệt

-- Index cho bảng review_replies
CREATE INDEX IF NOT EXISTS idx_review_replies_review_id ON public.review_replies (review_id);

-- Index cho bảng wishlists
CREATE INDEX IF NOT EXISTS idx_wishlists_user_id ON public.wishlists (user_id);
CREATE INDEX IF NOT EXISTS idx_wishlists_product_id ON public.wishlists (product_id);

-- Index cho bảng admin_activity_log
CREATE INDEX IF NOT EXISTS idx_admin_activity_log_admin_user_id ON public.admin_activity_log (admin_user_id);
CREATE INDEX IF NOT EXISTS idx_admin_activity_log_timestamp ON public.admin_activity_log (timestamp DESC); -- Sắp xếp log theo thời gian

-- Index cho bảng profiles
CREATE INDEX IF NOT EXISTS idx_profiles_default_address_id ON public.profiles (default_address_id);

-- Index cho bảng product_label_assignments
CREATE INDEX IF NOT EXISTS idx_product_label_assignments_product_id ON public.product_label_assignments (product_id);
CREATE INDEX IF NOT EXISTS idx_product_label_assignments_label_id ON public.product_label_assignments (label_id);

-- ============================================================================
-- END OF SCRIPT
-- ============================================================================

